/* soapC.cpp
   Generated by gSOAP 2.8.63 for zbxhwbservice.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.63 2018-02-24 02:08:37 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__ArrayOfBase64Binary:
		return soap_in_ns1__ArrayOfBase64Binary(soap, NULL, NULL, "ns1:ArrayOfBase64Binary");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTo_ns1__GetYjzhZskAlarmTypes:
		return soap_in_PointerTo_ns1__GetYjzhZskAlarmTypes(soap, NULL, NULL, "ns1:GetYjzhZskAlarmTypes");
	case SOAP_TYPE_PointerTo_ns1__SelectYjzhDevice:
		return soap_in_PointerTo_ns1__SelectYjzhDevice(soap, NULL, NULL, "ns1:SelectYjzhDevice");
	case SOAP_TYPE_PointerTo_ns1__SelectYjzhStation:
		return soap_in_PointerTo_ns1__SelectYjzhStation(soap, NULL, NULL, "ns1:SelectYjzhStation");
	case SOAP_TYPE_PointerTo_ns1__SaveMapFile:
		return soap_in_PointerTo_ns1__SaveMapFile(soap, NULL, NULL, "ns1:SaveMapFile");
	case SOAP_TYPE_PointerTo_ns1__GzGetDeviceStruct:
		return soap_in_PointerTo_ns1__GzGetDeviceStruct(soap, NULL, NULL, "ns1:GzGetDeviceStruct");
	case SOAP_TYPE_PointerTo_ns1__GzGetTypeList:
		return soap_in_PointerTo_ns1__GzGetTypeList(soap, NULL, NULL, "ns1:GzGetTypeList");
	case SOAP_TYPE_PointerTo_ns1__SGCDrawEmf:
		return soap_in_PointerTo_ns1__SGCDrawEmf(soap, NULL, NULL, "ns1:SGCDrawEmf");
	case SOAP_TYPE_PointerTo_ns1__FlowChartEmf:
		return soap_in_PointerTo_ns1__FlowChartEmf(soap, NULL, NULL, "ns1:FlowChartEmf");
	case SOAP_TYPE_PointerTo_ns1__GetZhouQi:
		return soap_in_PointerTo_ns1__GetZhouQi(soap, NULL, NULL, "ns1:GetZhouQi");
	case SOAP_TYPE_PointerTo_ns1__JiChaoQi:
		return soap_in_PointerTo_ns1__JiChaoQi(soap, NULL, NULL, "ns1:JiChaoQi");
	case SOAP_TYPE_PointerTo_ns1__ChaoQi:
		return soap_in_PointerTo_ns1__ChaoQi(soap, NULL, NULL, "ns1:ChaoQi");
	case SOAP_TYPE_PointerTo_ns1__OpenMapExe:
		return soap_in_PointerTo_ns1__OpenMapExe(soap, NULL, NULL, "ns1:OpenMapExe");
	case SOAP_TYPE_PointerTo_ns1__GetEmfPngFile:
		return soap_in_PointerTo_ns1__GetEmfPngFile(soap, NULL, NULL, "ns1:GetEmfPngFile");
	case SOAP_TYPE_PointerTo_ns1__GetEmfPngVer:
		return soap_in_PointerTo_ns1__GetEmfPngVer(soap, NULL, NULL, "ns1:GetEmfPngVer");
	case SOAP_TYPE_PointerTo_ns1__OpenProcess:
		return soap_in_PointerTo_ns1__OpenProcess(soap, NULL, NULL, "ns1:OpenProcess");
	case SOAP_TYPE_PointerTo_ns1__GetMangeMapUpdate:
		return soap_in_PointerTo_ns1__GetMangeMapUpdate(soap, NULL, NULL, "ns1:GetMangeMapUpdate");
	case SOAP_TYPE_PointerTo_ns1__GetUnitMapVer:
		return soap_in_PointerTo_ns1__GetUnitMapVer(soap, NULL, NULL, "ns1:GetUnitMapVer");
	case SOAP_TYPE_PointerTo_ns1__UpdateGzclMap:
		return soap_in_PointerTo_ns1__UpdateGzclMap(soap, NULL, NULL, "ns1:UpdateGzclMap");
	case SOAP_TYPE_PointerTo_ns1__GetMapListTime:
		return soap_in_PointerTo_ns1__GetMapListTime(soap, NULL, NULL, "ns1:GetMapListTime");
	case SOAP_TYPE_PointerTo_ns1__ServerLevel:
		return soap_in_PointerTo_ns1__ServerLevel(soap, NULL, NULL, "ns1:ServerLevel");
	case SOAP_TYPE_PointerTo_ns1__GetTableData:
		return soap_in_PointerTo_ns1__GetTableData(soap, NULL, NULL, "ns1:GetTableData");
	case SOAP_TYPE_PointerTo_ns1__GetMap:
		return soap_in_PointerTo_ns1__GetMap(soap, NULL, NULL, "ns1:GetMap");
	case SOAP_TYPE_PointerTo_ns1__CheckMapVer:
		return soap_in_PointerTo_ns1__CheckMapVer(soap, NULL, NULL, "ns1:CheckMapVer");
	case SOAP_TYPE_PointerTo_ns1__GetMangeXb:
		return soap_in_PointerTo_ns1__GetMangeXb(soap, NULL, NULL, "ns1:GetMangeXb");
	case SOAP_TYPE_PointerTo_ns1__GetMangeUnit:
		return soap_in_PointerTo_ns1__GetMangeUnit(soap, NULL, NULL, "ns1:GetMangeUnit");
	case SOAP_TYPE_PointerTo_ns1__GetMaList:
		return soap_in_PointerTo_ns1__GetMaList(soap, NULL, NULL, "ns1:GetMaList");
	case SOAP_TYPE_PointerTo_ns1__GetMapDeviceData:
		return soap_in_PointerTo_ns1__GetMapDeviceData(soap, NULL, NULL, "ns1:GetMapDeviceData");
	case SOAP_TYPE_PointerTo_ns1__GetMapTabName:
		return soap_in_PointerTo_ns1__GetMapTabName(soap, NULL, NULL, "ns1:GetMapTabName");
	case SOAP_TYPE_PointerTo_ns1__GetMapUpdateTime:
		return soap_in_PointerTo_ns1__GetMapUpdateTime(soap, NULL, NULL, "ns1:GetMapUpdateTime");
	case SOAP_TYPE_PointerTo_ns1__WriteFile:
		return soap_in_PointerTo_ns1__WriteFile(soap, NULL, NULL, "ns1:WriteFile");
	case SOAP_TYPE_PointerTo_ns1__DownLoadFile:
		return soap_in_PointerTo_ns1__DownLoadFile(soap, NULL, NULL, "ns1:DownLoadFile");
	case SOAP_TYPE_PointerTo_ns1__ExecuteSqlForFile:
		return soap_in_PointerTo_ns1__ExecuteSqlForFile(soap, NULL, NULL, "ns1:ExecuteSqlForFile");
	case SOAP_TYPE_PointerTo_ns1__GetFieldInfo:
		return soap_in_PointerTo_ns1__GetFieldInfo(soap, NULL, NULL, "ns1:GetFieldInfo");
	case SOAP_TYPE_PointerTo_ns1__IsOracleTable:
		return soap_in_PointerTo_ns1__IsOracleTable(soap, NULL, NULL, "ns1:IsOracleTable");
	case SOAP_TYPE_PointerTo_ns1__GetTabList:
		return soap_in_PointerTo_ns1__GetTabList(soap, NULL, NULL, "ns1:GetTabList");
	case SOAP_TYPE_PointerTo_ns1__DownCQData:
		return soap_in_PointerTo_ns1__DownCQData(soap, NULL, NULL, "ns1:DownCQData");
	case SOAP_TYPE_PointerTo_ns1__AlterTable:
		return soap_in_PointerTo_ns1__AlterTable(soap, NULL, NULL, "ns1:AlterTable");
	case SOAP_TYPE_PointerTo_ns1__GetFileNew:
		return soap_in_PointerTo_ns1__GetFileNew(soap, NULL, NULL, "ns1:GetFileNew");
	case SOAP_TYPE_PointerTo_ns1__DownMapfile:
		return soap_in_PointerTo_ns1__DownMapfile(soap, NULL, NULL, "ns1:DownMapfile");
	case SOAP_TYPE_PointerTo_ns1__GetDownFileInfo:
		return soap_in_PointerTo_ns1__GetDownFileInfo(soap, NULL, NULL, "ns1:GetDownFileInfo");
	case SOAP_TYPE_PointerTo_ns1__GetGxDeviceData:
		return soap_in_PointerTo_ns1__GetGxDeviceData(soap, NULL, NULL, "ns1:GetGxDeviceData");
	case SOAP_TYPE_PointerTo_ns1__GetMapDeviceType:
		return soap_in_PointerTo_ns1__GetMapDeviceType(soap, NULL, NULL, "ns1:GetMapDeviceType");
	case SOAP_TYPE_PointerTo_ns1__GetXbStationList:
		return soap_in_PointerTo_ns1__GetXbStationList(soap, NULL, NULL, "ns1:GetXbStationList");
	case SOAP_TYPE_PointerTo_ns1__GetXbList:
		return soap_in_PointerTo_ns1__GetXbList(soap, NULL, NULL, "ns1:GetXbList");
	case SOAP_TYPE_PointerTo_ns1__GetFileSize:
		return soap_in_PointerTo_ns1__GetFileSize(soap, NULL, NULL, "ns1:GetFileSize");
	case SOAP_TYPE_PointerTo_ns1__GetUnitPersonInfo:
		return soap_in_PointerTo_ns1__GetUnitPersonInfo(soap, NULL, NULL, "ns1:GetUnitPersonInfo");
	case SOAP_TYPE_PointerTo_ns1__GetUnitStruct:
		return soap_in_PointerTo_ns1__GetUnitStruct(soap, NULL, NULL, "ns1:GetUnitStruct");
	case SOAP_TYPE_PointerTo_ns1__GetUnitStation:
		return soap_in_PointerTo_ns1__GetUnitStation(soap, NULL, NULL, "ns1:GetUnitStation");
	case SOAP_TYPE_PointerTo_ns1__GetDwList:
		return soap_in_PointerTo_ns1__GetDwList(soap, NULL, NULL, "ns1:GetDwList");
	case SOAP_TYPE_PointerTo_ns1__GetOpenFireInfo:
		return soap_in_PointerTo_ns1__GetOpenFireInfo(soap, NULL, NULL, "ns1:GetOpenFireInfo");
	case SOAP_TYPE_PointerTo_ns1__MobDownLoadData:
		return soap_in_PointerTo_ns1__MobDownLoadData(soap, NULL, NULL, "ns1:MobDownLoadData");
	case SOAP_TYPE_PointerTo_ns1__DownLoadMobGPSData:
		return soap_in_PointerTo_ns1__DownLoadMobGPSData(soap, NULL, NULL, "ns1:DownLoadMobGPSData");
	case SOAP_TYPE_PointerTo_ns1__GetDcsData:
		return soap_in_PointerTo_ns1__GetDcsData(soap, NULL, NULL, "ns1:GetDcsData");
	case SOAP_TYPE_PointerTo_ns1__GetBgImg:
		return soap_in_PointerTo_ns1__GetBgImg(soap, NULL, NULL, "ns1:GetBgImg");
	case SOAP_TYPE_PointerTo_ns1__GetDevPic:
		return soap_in_PointerTo_ns1__GetDevPic(soap, NULL, NULL, "ns1:GetDevPic");
	case SOAP_TYPE_PointerTo_ns1__GetJxPic:
		return soap_in_PointerTo_ns1__GetJxPic(soap, NULL, NULL, "ns1:GetJxPic");
	case SOAP_TYPE_PointerTo_ns1__GetStationJxData:
		return soap_in_PointerTo_ns1__GetStationJxData(soap, NULL, NULL, "ns1:GetStationJxData");
	case SOAP_TYPE_PointerTo_ns1__GetJxData:
		return soap_in_PointerTo_ns1__GetJxData(soap, NULL, NULL, "ns1:GetJxData");
	case SOAP_TYPE_PointerTo_ns1__GetDeviceXj:
		return soap_in_PointerTo_ns1__GetDeviceXj(soap, NULL, NULL, "ns1:GetDeviceXj");
	case SOAP_TYPE_PointerTo_ns1__GetDwPic:
		return soap_in_PointerTo_ns1__GetDwPic(soap, NULL, NULL, "ns1:GetDwPic");
	case SOAP_TYPE_PointerTo_ns1__GetDwInfo:
		return soap_in_PointerTo_ns1__GetDwInfo(soap, NULL, NULL, "ns1:GetDwInfo");
	case SOAP_TYPE_PointerTo_ns1__GetPicNames:
		return soap_in_PointerTo_ns1__GetPicNames(soap, NULL, NULL, "ns1:GetPicNames");
	case SOAP_TYPE_PointerTo_ns1__DownloadPic:
		return soap_in_PointerTo_ns1__DownloadPic(soap, NULL, NULL, "ns1:DownloadPic");
	case SOAP_TYPE_PointerTo_ns1__upPic:
		return soap_in_PointerTo_ns1__upPic(soap, NULL, NULL, "ns1:upPic");
	case SOAP_TYPE_PointerTo_ns1__UpLoadFile:
		return soap_in_PointerTo_ns1__UpLoadFile(soap, NULL, NULL, "ns1:UpLoadFile");
	case SOAP_TYPE_PointerTo_ns1__GetAPVupdater:
		return soap_in_PointerTo_ns1__GetAPVupdater(soap, NULL, NULL, "ns1:GetAPVupdater");
	case SOAP_TYPE_PointerTo_ns1__GetXHYDGLXTupdater:
		return soap_in_PointerTo_ns1__GetXHYDGLXTupdater(soap, NULL, NULL, "ns1:GetXHYDGLXTupdater");
	case SOAP_TYPE_PointerTo_ns1__ExecuteSqlForColb:
		return soap_in_PointerTo_ns1__ExecuteSqlForColb(soap, NULL, NULL, "ns1:ExecuteSqlForColb");
	case SOAP_TYPE_PointerTo_ns1__UpLoadData:
		return soap_in_PointerTo_ns1__UpLoadData(soap, NULL, NULL, "ns1:UpLoadData");
	case SOAP_TYPE_PointerTo_ns1__TcdSendup:
		return soap_in_PointerTo_ns1__TcdSendup(soap, NULL, NULL, "ns1:TcdSendup");
	case SOAP_TYPE_PointerTo_ns1__TcdQuery:
		return soap_in_PointerTo_ns1__TcdQuery(soap, NULL, NULL, "ns1:TcdQuery");
	case SOAP_TYPE_PointerTo_ns1__QueryPhotobw:
		return soap_in_PointerTo_ns1__QueryPhotobw(soap, NULL, NULL, "ns1:QueryPhotobw");
	case SOAP_TYPE_PointerTo_ns1__GetOsDateTime:
		return soap_in_PointerTo_ns1__GetOsDateTime(soap, NULL, NULL, "ns1:GetOsDateTime");
	case SOAP_TYPE_PointerTo_ns1__signedUserInfo:
		return soap_in_PointerTo_ns1__signedUserInfo(soap, NULL, NULL, "ns1:signedUserInfo");
	case SOAP_TYPE_PointerTo_ns1__GetGxdataUpTime:
		return soap_in_PointerTo_ns1__GetGxdataUpTime(soap, NULL, NULL, "ns1:GetGxdataUpTime");
	case SOAP_TYPE_PointerTo_ns1__DownAllPic:
		return soap_in_PointerTo_ns1__DownAllPic(soap, NULL, NULL, "ns1:DownAllPic");
	case SOAP_TYPE_PointerTo_ns1__DownPic:
		return soap_in_PointerTo_ns1__DownPic(soap, NULL, NULL, "ns1:DownPic");
	case SOAP_TYPE_PointerTo_ns1__SaveFileData:
		return soap_in_PointerTo_ns1__SaveFileData(soap, NULL, NULL, "ns1:SaveFileData");
	case SOAP_TYPE_PointerTo_ns1__SaveData:
		return soap_in_PointerTo_ns1__SaveData(soap, NULL, NULL, "ns1:SaveData");
	case SOAP_TYPE_PointerTo_ns1__ExecuteSql:
		return soap_in_PointerTo_ns1__ExecuteSql(soap, NULL, NULL, "ns1:ExecuteSql");
	case SOAP_TYPE_PointerTo_ns1__QueryDataCount:
		return soap_in_PointerTo_ns1__QueryDataCount(soap, NULL, NULL, "ns1:QueryDataCount");
	case SOAP_TYPE_PointerTo_ns1__QueryData:
		return soap_in_PointerTo_ns1__QueryData(soap, NULL, NULL, "ns1:QueryData");
	case SOAP_TYPE_PointerTo_ns1__GetDBString:
		return soap_in_PointerTo_ns1__GetDBString(soap, NULL, NULL, "ns1:GetDBString");
	case SOAP_TYPE_PointerTo_ns1__HelloWorld:
		return soap_in_PointerTo_ns1__HelloWorld(soap, NULL, NULL, "ns1:HelloWorld");
	case SOAP_TYPE_PointerTo_ns1__CheckDevCode:
		return soap_in_PointerTo_ns1__CheckDevCode(soap, NULL, NULL, "ns1:CheckDevCode");
	case SOAP_TYPE_PointerTo_ns1__GetDevCode:
		return soap_in_PointerTo_ns1__GetDevCode(soap, NULL, NULL, "ns1:GetDevCode");
	case SOAP_TYPE_PointerTo_ns1__GetRyUnit:
		return soap_in_PointerTo_ns1__GetRyUnit(soap, NULL, NULL, "ns1:GetRyUnit");
	case SOAP_TYPE_PointerTo_ns1__CheckLoginUser:
		return soap_in_PointerTo_ns1__CheckLoginUser(soap, NULL, NULL, "ns1:CheckLoginUser");
	case SOAP_TYPE_PointerTo_ns1__GetPropName:
		return soap_in_PointerTo_ns1__GetPropName(soap, NULL, NULL, "ns1:GetPropName");
	case SOAP_TYPE_PointerTo_ns1__GetPropList:
		return soap_in_PointerTo_ns1__GetPropList(soap, NULL, NULL, "ns1:GetPropList");
	case SOAP_TYPE_PointerTo_ns1__GetYjzhZskDevFlowChartList:
		return soap_in_PointerTo_ns1__GetYjzhZskDevFlowChartList(soap, NULL, NULL, "ns1:GetYjzhZskDevFlowChartList");
	case SOAP_TYPE_PointerTo_ns1__GetYjzhZskOtherFlowChartList:
		return soap_in_PointerTo_ns1__GetYjzhZskOtherFlowChartList(soap, NULL, NULL, "ns1:GetYjzhZskOtherFlowChartList");
	case SOAP_TYPE_PointerTo_ns1__GetYjzhZskGzFlow:
		return soap_in_PointerTo_ns1__GetYjzhZskGzFlow(soap, NULL, NULL, "ns1:GetYjzhZskGzFlow");
	case SOAP_TYPE_PointerTons1__ArrayOfBase64Binary:
		return soap_in_PointerTons1__ArrayOfBase64Binary(soap, NULL, NULL, "ns1:ArrayOfBase64Binary");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_in_PointerToxsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:ArrayOfBase64Binary"))
		{	*type = SOAP_TYPE_ns1__ArrayOfBase64Binary;
			return soap_in_ns1__ArrayOfBase64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:GetYjzhZskAlarmTypesResponse"))
		{	*type = SOAP_TYPE__ns1__GetYjzhZskAlarmTypesResponse;
			return soap_in__ns1__GetYjzhZskAlarmTypesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetYjzhZskAlarmTypes"))
		{	*type = SOAP_TYPE__ns1__GetYjzhZskAlarmTypes;
			return soap_in__ns1__GetYjzhZskAlarmTypes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SelectYjzhDeviceResponse"))
		{	*type = SOAP_TYPE__ns1__SelectYjzhDeviceResponse;
			return soap_in__ns1__SelectYjzhDeviceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SelectYjzhDevice"))
		{	*type = SOAP_TYPE__ns1__SelectYjzhDevice;
			return soap_in__ns1__SelectYjzhDevice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SelectYjzhStationResponse"))
		{	*type = SOAP_TYPE__ns1__SelectYjzhStationResponse;
			return soap_in__ns1__SelectYjzhStationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SelectYjzhStation"))
		{	*type = SOAP_TYPE__ns1__SelectYjzhStation;
			return soap_in__ns1__SelectYjzhStation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SaveMapFileResponse"))
		{	*type = SOAP_TYPE__ns1__SaveMapFileResponse;
			return soap_in__ns1__SaveMapFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SaveMapFile"))
		{	*type = SOAP_TYPE__ns1__SaveMapFile;
			return soap_in__ns1__SaveMapFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GzGetDeviceStructResponse"))
		{	*type = SOAP_TYPE__ns1__GzGetDeviceStructResponse;
			return soap_in__ns1__GzGetDeviceStructResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GzGetDeviceStruct"))
		{	*type = SOAP_TYPE__ns1__GzGetDeviceStruct;
			return soap_in__ns1__GzGetDeviceStruct(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GzGetTypeListResponse"))
		{	*type = SOAP_TYPE__ns1__GzGetTypeListResponse;
			return soap_in__ns1__GzGetTypeListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GzGetTypeList"))
		{	*type = SOAP_TYPE__ns1__GzGetTypeList;
			return soap_in__ns1__GzGetTypeList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SGCDrawEmfResponse"))
		{	*type = SOAP_TYPE__ns1__SGCDrawEmfResponse;
			return soap_in__ns1__SGCDrawEmfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SGCDrawEmf"))
		{	*type = SOAP_TYPE__ns1__SGCDrawEmf;
			return soap_in__ns1__SGCDrawEmf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FlowChartEmfResponse"))
		{	*type = SOAP_TYPE__ns1__FlowChartEmfResponse;
			return soap_in__ns1__FlowChartEmfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FlowChartEmf"))
		{	*type = SOAP_TYPE__ns1__FlowChartEmf;
			return soap_in__ns1__FlowChartEmf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetZhouQiResponse"))
		{	*type = SOAP_TYPE__ns1__GetZhouQiResponse;
			return soap_in__ns1__GetZhouQiResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetZhouQi"))
		{	*type = SOAP_TYPE__ns1__GetZhouQi;
			return soap_in__ns1__GetZhouQi(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:JiChaoQiResponse"))
		{	*type = SOAP_TYPE__ns1__JiChaoQiResponse;
			return soap_in__ns1__JiChaoQiResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:JiChaoQi"))
		{	*type = SOAP_TYPE__ns1__JiChaoQi;
			return soap_in__ns1__JiChaoQi(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChaoQiResponse"))
		{	*type = SOAP_TYPE__ns1__ChaoQiResponse;
			return soap_in__ns1__ChaoQiResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChaoQi"))
		{	*type = SOAP_TYPE__ns1__ChaoQi;
			return soap_in__ns1__ChaoQi(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OpenMapExeResponse"))
		{	*type = SOAP_TYPE__ns1__OpenMapExeResponse;
			return soap_in__ns1__OpenMapExeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OpenMapExe"))
		{	*type = SOAP_TYPE__ns1__OpenMapExe;
			return soap_in__ns1__OpenMapExe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetEmfPngFileResponse"))
		{	*type = SOAP_TYPE__ns1__GetEmfPngFileResponse;
			return soap_in__ns1__GetEmfPngFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetEmfPngFile"))
		{	*type = SOAP_TYPE__ns1__GetEmfPngFile;
			return soap_in__ns1__GetEmfPngFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetEmfPngVerResponse"))
		{	*type = SOAP_TYPE__ns1__GetEmfPngVerResponse;
			return soap_in__ns1__GetEmfPngVerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetEmfPngVer"))
		{	*type = SOAP_TYPE__ns1__GetEmfPngVer;
			return soap_in__ns1__GetEmfPngVer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OpenProcessResponse"))
		{	*type = SOAP_TYPE__ns1__OpenProcessResponse;
			return soap_in__ns1__OpenProcessResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OpenProcess"))
		{	*type = SOAP_TYPE__ns1__OpenProcess;
			return soap_in__ns1__OpenProcess(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMangeMapUpdateResponse"))
		{	*type = SOAP_TYPE__ns1__GetMangeMapUpdateResponse;
			return soap_in__ns1__GetMangeMapUpdateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMangeMapUpdate"))
		{	*type = SOAP_TYPE__ns1__GetMangeMapUpdate;
			return soap_in__ns1__GetMangeMapUpdate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetUnitMapVerResponse"))
		{	*type = SOAP_TYPE__ns1__GetUnitMapVerResponse;
			return soap_in__ns1__GetUnitMapVerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetUnitMapVer"))
		{	*type = SOAP_TYPE__ns1__GetUnitMapVer;
			return soap_in__ns1__GetUnitMapVer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateGzclMapResponse"))
		{	*type = SOAP_TYPE__ns1__UpdateGzclMapResponse;
			return soap_in__ns1__UpdateGzclMapResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateGzclMap"))
		{	*type = SOAP_TYPE__ns1__UpdateGzclMap;
			return soap_in__ns1__UpdateGzclMap(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMapListTimeResponse"))
		{	*type = SOAP_TYPE__ns1__GetMapListTimeResponse;
			return soap_in__ns1__GetMapListTimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMapListTime"))
		{	*type = SOAP_TYPE__ns1__GetMapListTime;
			return soap_in__ns1__GetMapListTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ServerLevelResponse"))
		{	*type = SOAP_TYPE__ns1__ServerLevelResponse;
			return soap_in__ns1__ServerLevelResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ServerLevel"))
		{	*type = SOAP_TYPE__ns1__ServerLevel;
			return soap_in__ns1__ServerLevel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTableDataResponse"))
		{	*type = SOAP_TYPE__ns1__GetTableDataResponse;
			return soap_in__ns1__GetTableDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTableData"))
		{	*type = SOAP_TYPE__ns1__GetTableData;
			return soap_in__ns1__GetTableData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMapResponse"))
		{	*type = SOAP_TYPE__ns1__GetMapResponse;
			return soap_in__ns1__GetMapResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMap"))
		{	*type = SOAP_TYPE__ns1__GetMap;
			return soap_in__ns1__GetMap(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CheckMapVerResponse"))
		{	*type = SOAP_TYPE__ns1__CheckMapVerResponse;
			return soap_in__ns1__CheckMapVerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CheckMapVer"))
		{	*type = SOAP_TYPE__ns1__CheckMapVer;
			return soap_in__ns1__CheckMapVer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMangeXbResponse"))
		{	*type = SOAP_TYPE__ns1__GetMangeXbResponse;
			return soap_in__ns1__GetMangeXbResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMangeXb"))
		{	*type = SOAP_TYPE__ns1__GetMangeXb;
			return soap_in__ns1__GetMangeXb(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMangeUnitResponse"))
		{	*type = SOAP_TYPE__ns1__GetMangeUnitResponse;
			return soap_in__ns1__GetMangeUnitResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMangeUnit"))
		{	*type = SOAP_TYPE__ns1__GetMangeUnit;
			return soap_in__ns1__GetMangeUnit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMaListResponse"))
		{	*type = SOAP_TYPE__ns1__GetMaListResponse;
			return soap_in__ns1__GetMaListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMaList"))
		{	*type = SOAP_TYPE__ns1__GetMaList;
			return soap_in__ns1__GetMaList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMapDeviceDataResponse"))
		{	*type = SOAP_TYPE__ns1__GetMapDeviceDataResponse;
			return soap_in__ns1__GetMapDeviceDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMapDeviceData"))
		{	*type = SOAP_TYPE__ns1__GetMapDeviceData;
			return soap_in__ns1__GetMapDeviceData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMapTabNameResponse"))
		{	*type = SOAP_TYPE__ns1__GetMapTabNameResponse;
			return soap_in__ns1__GetMapTabNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMapTabName"))
		{	*type = SOAP_TYPE__ns1__GetMapTabName;
			return soap_in__ns1__GetMapTabName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMapUpdateTimeResponse"))
		{	*type = SOAP_TYPE__ns1__GetMapUpdateTimeResponse;
			return soap_in__ns1__GetMapUpdateTimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMapUpdateTime"))
		{	*type = SOAP_TYPE__ns1__GetMapUpdateTime;
			return soap_in__ns1__GetMapUpdateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WriteFileResponse"))
		{	*type = SOAP_TYPE__ns1__WriteFileResponse;
			return soap_in__ns1__WriteFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WriteFile"))
		{	*type = SOAP_TYPE__ns1__WriteFile;
			return soap_in__ns1__WriteFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DownLoadFileResponse"))
		{	*type = SOAP_TYPE__ns1__DownLoadFileResponse;
			return soap_in__ns1__DownLoadFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DownLoadFile"))
		{	*type = SOAP_TYPE__ns1__DownLoadFile;
			return soap_in__ns1__DownLoadFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExecuteSqlForFileResponse"))
		{	*type = SOAP_TYPE__ns1__ExecuteSqlForFileResponse;
			return soap_in__ns1__ExecuteSqlForFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExecuteSqlForFile"))
		{	*type = SOAP_TYPE__ns1__ExecuteSqlForFile;
			return soap_in__ns1__ExecuteSqlForFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetFieldInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetFieldInfoResponse;
			return soap_in__ns1__GetFieldInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetFieldInfo"))
		{	*type = SOAP_TYPE__ns1__GetFieldInfo;
			return soap_in__ns1__GetFieldInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:IsOracleTableResponse"))
		{	*type = SOAP_TYPE__ns1__IsOracleTableResponse;
			return soap_in__ns1__IsOracleTableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:IsOracleTable"))
		{	*type = SOAP_TYPE__ns1__IsOracleTable;
			return soap_in__ns1__IsOracleTable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTabListResponse"))
		{	*type = SOAP_TYPE__ns1__GetTabListResponse;
			return soap_in__ns1__GetTabListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTabList"))
		{	*type = SOAP_TYPE__ns1__GetTabList;
			return soap_in__ns1__GetTabList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DownCQDataResponse"))
		{	*type = SOAP_TYPE__ns1__DownCQDataResponse;
			return soap_in__ns1__DownCQDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DownCQData"))
		{	*type = SOAP_TYPE__ns1__DownCQData;
			return soap_in__ns1__DownCQData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AlterTableResponse"))
		{	*type = SOAP_TYPE__ns1__AlterTableResponse;
			return soap_in__ns1__AlterTableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AlterTable"))
		{	*type = SOAP_TYPE__ns1__AlterTable;
			return soap_in__ns1__AlterTable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetFileNewResponse"))
		{	*type = SOAP_TYPE__ns1__GetFileNewResponse;
			return soap_in__ns1__GetFileNewResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetFileNew"))
		{	*type = SOAP_TYPE__ns1__GetFileNew;
			return soap_in__ns1__GetFileNew(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DownMapfileResponse"))
		{	*type = SOAP_TYPE__ns1__DownMapfileResponse;
			return soap_in__ns1__DownMapfileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DownMapfile"))
		{	*type = SOAP_TYPE__ns1__DownMapfile;
			return soap_in__ns1__DownMapfile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDownFileInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetDownFileInfoResponse;
			return soap_in__ns1__GetDownFileInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDownFileInfo"))
		{	*type = SOAP_TYPE__ns1__GetDownFileInfo;
			return soap_in__ns1__GetDownFileInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetGxDeviceDataResponse"))
		{	*type = SOAP_TYPE__ns1__GetGxDeviceDataResponse;
			return soap_in__ns1__GetGxDeviceDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetGxDeviceData"))
		{	*type = SOAP_TYPE__ns1__GetGxDeviceData;
			return soap_in__ns1__GetGxDeviceData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMapDeviceTypeResponse"))
		{	*type = SOAP_TYPE__ns1__GetMapDeviceTypeResponse;
			return soap_in__ns1__GetMapDeviceTypeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetMapDeviceType"))
		{	*type = SOAP_TYPE__ns1__GetMapDeviceType;
			return soap_in__ns1__GetMapDeviceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetXbStationListResponse"))
		{	*type = SOAP_TYPE__ns1__GetXbStationListResponse;
			return soap_in__ns1__GetXbStationListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetXbStationList"))
		{	*type = SOAP_TYPE__ns1__GetXbStationList;
			return soap_in__ns1__GetXbStationList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetXbListResponse"))
		{	*type = SOAP_TYPE__ns1__GetXbListResponse;
			return soap_in__ns1__GetXbListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetXbList"))
		{	*type = SOAP_TYPE__ns1__GetXbList;
			return soap_in__ns1__GetXbList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetFileSizeResponse"))
		{	*type = SOAP_TYPE__ns1__GetFileSizeResponse;
			return soap_in__ns1__GetFileSizeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetFileSize"))
		{	*type = SOAP_TYPE__ns1__GetFileSize;
			return soap_in__ns1__GetFileSize(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetUnitPersonInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetUnitPersonInfoResponse;
			return soap_in__ns1__GetUnitPersonInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetUnitPersonInfo"))
		{	*type = SOAP_TYPE__ns1__GetUnitPersonInfo;
			return soap_in__ns1__GetUnitPersonInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetUnitStructResponse"))
		{	*type = SOAP_TYPE__ns1__GetUnitStructResponse;
			return soap_in__ns1__GetUnitStructResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetUnitStruct"))
		{	*type = SOAP_TYPE__ns1__GetUnitStruct;
			return soap_in__ns1__GetUnitStruct(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetUnitStationResponse"))
		{	*type = SOAP_TYPE__ns1__GetUnitStationResponse;
			return soap_in__ns1__GetUnitStationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetUnitStation"))
		{	*type = SOAP_TYPE__ns1__GetUnitStation;
			return soap_in__ns1__GetUnitStation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDwListResponse"))
		{	*type = SOAP_TYPE__ns1__GetDwListResponse;
			return soap_in__ns1__GetDwListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDwList"))
		{	*type = SOAP_TYPE__ns1__GetDwList;
			return soap_in__ns1__GetDwList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetOpenFireInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetOpenFireInfoResponse;
			return soap_in__ns1__GetOpenFireInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetOpenFireInfo"))
		{	*type = SOAP_TYPE__ns1__GetOpenFireInfo;
			return soap_in__ns1__GetOpenFireInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MobDownLoadDataResponse"))
		{	*type = SOAP_TYPE__ns1__MobDownLoadDataResponse;
			return soap_in__ns1__MobDownLoadDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MobDownLoadData"))
		{	*type = SOAP_TYPE__ns1__MobDownLoadData;
			return soap_in__ns1__MobDownLoadData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DownLoadMobGPSDataResponse"))
		{	*type = SOAP_TYPE__ns1__DownLoadMobGPSDataResponse;
			return soap_in__ns1__DownLoadMobGPSDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DownLoadMobGPSData"))
		{	*type = SOAP_TYPE__ns1__DownLoadMobGPSData;
			return soap_in__ns1__DownLoadMobGPSData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDcsDataResponse"))
		{	*type = SOAP_TYPE__ns1__GetDcsDataResponse;
			return soap_in__ns1__GetDcsDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDcsData"))
		{	*type = SOAP_TYPE__ns1__GetDcsData;
			return soap_in__ns1__GetDcsData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetBgImgResponse"))
		{	*type = SOAP_TYPE__ns1__GetBgImgResponse;
			return soap_in__ns1__GetBgImgResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetBgImg"))
		{	*type = SOAP_TYPE__ns1__GetBgImg;
			return soap_in__ns1__GetBgImg(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDevPicResponse"))
		{	*type = SOAP_TYPE__ns1__GetDevPicResponse;
			return soap_in__ns1__GetDevPicResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDevPic"))
		{	*type = SOAP_TYPE__ns1__GetDevPic;
			return soap_in__ns1__GetDevPic(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetJxPicResponse"))
		{	*type = SOAP_TYPE__ns1__GetJxPicResponse;
			return soap_in__ns1__GetJxPicResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetJxPic"))
		{	*type = SOAP_TYPE__ns1__GetJxPic;
			return soap_in__ns1__GetJxPic(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetStationJxDataResponse"))
		{	*type = SOAP_TYPE__ns1__GetStationJxDataResponse;
			return soap_in__ns1__GetStationJxDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetStationJxData"))
		{	*type = SOAP_TYPE__ns1__GetStationJxData;
			return soap_in__ns1__GetStationJxData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetJxDataResponse"))
		{	*type = SOAP_TYPE__ns1__GetJxDataResponse;
			return soap_in__ns1__GetJxDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetJxData"))
		{	*type = SOAP_TYPE__ns1__GetJxData;
			return soap_in__ns1__GetJxData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDeviceXjResponse"))
		{	*type = SOAP_TYPE__ns1__GetDeviceXjResponse;
			return soap_in__ns1__GetDeviceXjResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDeviceXj"))
		{	*type = SOAP_TYPE__ns1__GetDeviceXj;
			return soap_in__ns1__GetDeviceXj(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDwPicResponse"))
		{	*type = SOAP_TYPE__ns1__GetDwPicResponse;
			return soap_in__ns1__GetDwPicResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDwPic"))
		{	*type = SOAP_TYPE__ns1__GetDwPic;
			return soap_in__ns1__GetDwPic(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDwInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetDwInfoResponse;
			return soap_in__ns1__GetDwInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDwInfo"))
		{	*type = SOAP_TYPE__ns1__GetDwInfo;
			return soap_in__ns1__GetDwInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPicNamesResponse"))
		{	*type = SOAP_TYPE__ns1__GetPicNamesResponse;
			return soap_in__ns1__GetPicNamesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPicNames"))
		{	*type = SOAP_TYPE__ns1__GetPicNames;
			return soap_in__ns1__GetPicNames(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DownloadPicResponse"))
		{	*type = SOAP_TYPE__ns1__DownloadPicResponse;
			return soap_in__ns1__DownloadPicResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DownloadPic"))
		{	*type = SOAP_TYPE__ns1__DownloadPic;
			return soap_in__ns1__DownloadPic(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:upPicResponse"))
		{	*type = SOAP_TYPE__ns1__upPicResponse;
			return soap_in__ns1__upPicResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:upPic"))
		{	*type = SOAP_TYPE__ns1__upPic;
			return soap_in__ns1__upPic(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpLoadFileResponse"))
		{	*type = SOAP_TYPE__ns1__UpLoadFileResponse;
			return soap_in__ns1__UpLoadFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpLoadFile"))
		{	*type = SOAP_TYPE__ns1__UpLoadFile;
			return soap_in__ns1__UpLoadFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAPVupdaterResponse"))
		{	*type = SOAP_TYPE__ns1__GetAPVupdaterResponse;
			return soap_in__ns1__GetAPVupdaterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAPVupdater"))
		{	*type = SOAP_TYPE__ns1__GetAPVupdater;
			return soap_in__ns1__GetAPVupdater(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetXHYDGLXTupdaterResponse"))
		{	*type = SOAP_TYPE__ns1__GetXHYDGLXTupdaterResponse;
			return soap_in__ns1__GetXHYDGLXTupdaterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetXHYDGLXTupdater"))
		{	*type = SOAP_TYPE__ns1__GetXHYDGLXTupdater;
			return soap_in__ns1__GetXHYDGLXTupdater(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExecuteSqlForColbResponse"))
		{	*type = SOAP_TYPE__ns1__ExecuteSqlForColbResponse;
			return soap_in__ns1__ExecuteSqlForColbResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExecuteSqlForColb"))
		{	*type = SOAP_TYPE__ns1__ExecuteSqlForColb;
			return soap_in__ns1__ExecuteSqlForColb(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpLoadDataResponse"))
		{	*type = SOAP_TYPE__ns1__UpLoadDataResponse;
			return soap_in__ns1__UpLoadDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpLoadData"))
		{	*type = SOAP_TYPE__ns1__UpLoadData;
			return soap_in__ns1__UpLoadData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TcdSendupResponse"))
		{	*type = SOAP_TYPE__ns1__TcdSendupResponse;
			return soap_in__ns1__TcdSendupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TcdSendup"))
		{	*type = SOAP_TYPE__ns1__TcdSendup;
			return soap_in__ns1__TcdSendup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TcdQueryResponse"))
		{	*type = SOAP_TYPE__ns1__TcdQueryResponse;
			return soap_in__ns1__TcdQueryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TcdQuery"))
		{	*type = SOAP_TYPE__ns1__TcdQuery;
			return soap_in__ns1__TcdQuery(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QueryPhotobwResponse"))
		{	*type = SOAP_TYPE__ns1__QueryPhotobwResponse;
			return soap_in__ns1__QueryPhotobwResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QueryPhotobw"))
		{	*type = SOAP_TYPE__ns1__QueryPhotobw;
			return soap_in__ns1__QueryPhotobw(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetOsDateTimeResponse"))
		{	*type = SOAP_TYPE__ns1__GetOsDateTimeResponse;
			return soap_in__ns1__GetOsDateTimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetOsDateTime"))
		{	*type = SOAP_TYPE__ns1__GetOsDateTime;
			return soap_in__ns1__GetOsDateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:signedUserInfoResponse"))
		{	*type = SOAP_TYPE__ns1__signedUserInfoResponse;
			return soap_in__ns1__signedUserInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:signedUserInfo"))
		{	*type = SOAP_TYPE__ns1__signedUserInfo;
			return soap_in__ns1__signedUserInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetGxdataUpTimeResponse"))
		{	*type = SOAP_TYPE__ns1__GetGxdataUpTimeResponse;
			return soap_in__ns1__GetGxdataUpTimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetGxdataUpTime"))
		{	*type = SOAP_TYPE__ns1__GetGxdataUpTime;
			return soap_in__ns1__GetGxdataUpTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DownAllPicResponse"))
		{	*type = SOAP_TYPE__ns1__DownAllPicResponse;
			return soap_in__ns1__DownAllPicResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DownAllPic"))
		{	*type = SOAP_TYPE__ns1__DownAllPic;
			return soap_in__ns1__DownAllPic(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DownPicResponse"))
		{	*type = SOAP_TYPE__ns1__DownPicResponse;
			return soap_in__ns1__DownPicResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DownPic"))
		{	*type = SOAP_TYPE__ns1__DownPic;
			return soap_in__ns1__DownPic(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SaveFileDataResponse"))
		{	*type = SOAP_TYPE__ns1__SaveFileDataResponse;
			return soap_in__ns1__SaveFileDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SaveFileData"))
		{	*type = SOAP_TYPE__ns1__SaveFileData;
			return soap_in__ns1__SaveFileData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SaveDataResponse"))
		{	*type = SOAP_TYPE__ns1__SaveDataResponse;
			return soap_in__ns1__SaveDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SaveData"))
		{	*type = SOAP_TYPE__ns1__SaveData;
			return soap_in__ns1__SaveData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExecuteSqlResponse"))
		{	*type = SOAP_TYPE__ns1__ExecuteSqlResponse;
			return soap_in__ns1__ExecuteSqlResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExecuteSql"))
		{	*type = SOAP_TYPE__ns1__ExecuteSql;
			return soap_in__ns1__ExecuteSql(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QueryDataCountResponse"))
		{	*type = SOAP_TYPE__ns1__QueryDataCountResponse;
			return soap_in__ns1__QueryDataCountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QueryDataCount"))
		{	*type = SOAP_TYPE__ns1__QueryDataCount;
			return soap_in__ns1__QueryDataCount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QueryDataResponse"))
		{	*type = SOAP_TYPE__ns1__QueryDataResponse;
			return soap_in__ns1__QueryDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QueryData"))
		{	*type = SOAP_TYPE__ns1__QueryData;
			return soap_in__ns1__QueryData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDBStringResponse"))
		{	*type = SOAP_TYPE__ns1__GetDBStringResponse;
			return soap_in__ns1__GetDBStringResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDBString"))
		{	*type = SOAP_TYPE__ns1__GetDBString;
			return soap_in__ns1__GetDBString(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HelloWorldResponse"))
		{	*type = SOAP_TYPE__ns1__HelloWorldResponse;
			return soap_in__ns1__HelloWorldResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HelloWorld"))
		{	*type = SOAP_TYPE__ns1__HelloWorld;
			return soap_in__ns1__HelloWorld(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CheckDevCodeResponse"))
		{	*type = SOAP_TYPE__ns1__CheckDevCodeResponse;
			return soap_in__ns1__CheckDevCodeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CheckDevCode"))
		{	*type = SOAP_TYPE__ns1__CheckDevCode;
			return soap_in__ns1__CheckDevCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDevCodeResponse"))
		{	*type = SOAP_TYPE__ns1__GetDevCodeResponse;
			return soap_in__ns1__GetDevCodeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDevCode"))
		{	*type = SOAP_TYPE__ns1__GetDevCode;
			return soap_in__ns1__GetDevCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetRyUnitResponse"))
		{	*type = SOAP_TYPE__ns1__GetRyUnitResponse;
			return soap_in__ns1__GetRyUnitResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetRyUnit"))
		{	*type = SOAP_TYPE__ns1__GetRyUnit;
			return soap_in__ns1__GetRyUnit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CheckLoginUserResponse"))
		{	*type = SOAP_TYPE__ns1__CheckLoginUserResponse;
			return soap_in__ns1__CheckLoginUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CheckLoginUser"))
		{	*type = SOAP_TYPE__ns1__CheckLoginUser;
			return soap_in__ns1__CheckLoginUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPropNameResponse"))
		{	*type = SOAP_TYPE__ns1__GetPropNameResponse;
			return soap_in__ns1__GetPropNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPropName"))
		{	*type = SOAP_TYPE__ns1__GetPropName;
			return soap_in__ns1__GetPropName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPropListResponse"))
		{	*type = SOAP_TYPE__ns1__GetPropListResponse;
			return soap_in__ns1__GetPropListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPropList"))
		{	*type = SOAP_TYPE__ns1__GetPropList;
			return soap_in__ns1__GetPropList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetYjzhZskDevFlowChartListResponse"))
		{	*type = SOAP_TYPE__ns1__GetYjzhZskDevFlowChartListResponse;
			return soap_in__ns1__GetYjzhZskDevFlowChartListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetYjzhZskDevFlowChartList"))
		{	*type = SOAP_TYPE__ns1__GetYjzhZskDevFlowChartList;
			return soap_in__ns1__GetYjzhZskDevFlowChartList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetYjzhZskOtherFlowChartListResponse"))
		{	*type = SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartListResponse;
			return soap_in__ns1__GetYjzhZskOtherFlowChartListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetYjzhZskOtherFlowChartList"))
		{	*type = SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartList;
			return soap_in__ns1__GetYjzhZskOtherFlowChartList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetYjzhZskGzFlowResponse"))
		{	*type = SOAP_TYPE__ns1__GetYjzhZskGzFlowResponse;
			return soap_in__ns1__GetYjzhZskGzFlowResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetYjzhZskGzFlow"))
		{	*type = SOAP_TYPE__ns1__GetYjzhZskGzFlow;
			return soap_in__ns1__GetYjzhZskGzFlow(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE__ns1__GetYjzhZskAlarmTypesResponse:
		return ((_ns1__GetYjzhZskAlarmTypesResponse *)ptr)->soap_out(soap, "ns1:GetYjzhZskAlarmTypesResponse", id, "");
	case SOAP_TYPE__ns1__GetYjzhZskAlarmTypes:
		return ((_ns1__GetYjzhZskAlarmTypes *)ptr)->soap_out(soap, "ns1:GetYjzhZskAlarmTypes", id, "");
	case SOAP_TYPE__ns1__SelectYjzhDeviceResponse:
		return ((_ns1__SelectYjzhDeviceResponse *)ptr)->soap_out(soap, "ns1:SelectYjzhDeviceResponse", id, "");
	case SOAP_TYPE__ns1__SelectYjzhDevice:
		return ((_ns1__SelectYjzhDevice *)ptr)->soap_out(soap, "ns1:SelectYjzhDevice", id, "");
	case SOAP_TYPE__ns1__SelectYjzhStationResponse:
		return ((_ns1__SelectYjzhStationResponse *)ptr)->soap_out(soap, "ns1:SelectYjzhStationResponse", id, "");
	case SOAP_TYPE__ns1__SelectYjzhStation:
		return ((_ns1__SelectYjzhStation *)ptr)->soap_out(soap, "ns1:SelectYjzhStation", id, "");
	case SOAP_TYPE__ns1__SaveMapFileResponse:
		return ((_ns1__SaveMapFileResponse *)ptr)->soap_out(soap, "ns1:SaveMapFileResponse", id, "");
	case SOAP_TYPE__ns1__SaveMapFile:
		return ((_ns1__SaveMapFile *)ptr)->soap_out(soap, "ns1:SaveMapFile", id, "");
	case SOAP_TYPE__ns1__GzGetDeviceStructResponse:
		return ((_ns1__GzGetDeviceStructResponse *)ptr)->soap_out(soap, "ns1:GzGetDeviceStructResponse", id, "");
	case SOAP_TYPE__ns1__GzGetDeviceStruct:
		return ((_ns1__GzGetDeviceStruct *)ptr)->soap_out(soap, "ns1:GzGetDeviceStruct", id, "");
	case SOAP_TYPE__ns1__GzGetTypeListResponse:
		return ((_ns1__GzGetTypeListResponse *)ptr)->soap_out(soap, "ns1:GzGetTypeListResponse", id, "");
	case SOAP_TYPE__ns1__GzGetTypeList:
		return ((_ns1__GzGetTypeList *)ptr)->soap_out(soap, "ns1:GzGetTypeList", id, "");
	case SOAP_TYPE__ns1__SGCDrawEmfResponse:
		return ((_ns1__SGCDrawEmfResponse *)ptr)->soap_out(soap, "ns1:SGCDrawEmfResponse", id, "");
	case SOAP_TYPE__ns1__SGCDrawEmf:
		return ((_ns1__SGCDrawEmf *)ptr)->soap_out(soap, "ns1:SGCDrawEmf", id, "");
	case SOAP_TYPE__ns1__FlowChartEmfResponse:
		return ((_ns1__FlowChartEmfResponse *)ptr)->soap_out(soap, "ns1:FlowChartEmfResponse", id, "");
	case SOAP_TYPE__ns1__FlowChartEmf:
		return ((_ns1__FlowChartEmf *)ptr)->soap_out(soap, "ns1:FlowChartEmf", id, "");
	case SOAP_TYPE__ns1__GetZhouQiResponse:
		return ((_ns1__GetZhouQiResponse *)ptr)->soap_out(soap, "ns1:GetZhouQiResponse", id, "");
	case SOAP_TYPE__ns1__GetZhouQi:
		return ((_ns1__GetZhouQi *)ptr)->soap_out(soap, "ns1:GetZhouQi", id, "");
	case SOAP_TYPE__ns1__JiChaoQiResponse:
		return ((_ns1__JiChaoQiResponse *)ptr)->soap_out(soap, "ns1:JiChaoQiResponse", id, "");
	case SOAP_TYPE__ns1__JiChaoQi:
		return ((_ns1__JiChaoQi *)ptr)->soap_out(soap, "ns1:JiChaoQi", id, "");
	case SOAP_TYPE__ns1__ChaoQiResponse:
		return ((_ns1__ChaoQiResponse *)ptr)->soap_out(soap, "ns1:ChaoQiResponse", id, "");
	case SOAP_TYPE__ns1__ChaoQi:
		return ((_ns1__ChaoQi *)ptr)->soap_out(soap, "ns1:ChaoQi", id, "");
	case SOAP_TYPE__ns1__OpenMapExeResponse:
		return ((_ns1__OpenMapExeResponse *)ptr)->soap_out(soap, "ns1:OpenMapExeResponse", id, "");
	case SOAP_TYPE__ns1__OpenMapExe:
		return ((_ns1__OpenMapExe *)ptr)->soap_out(soap, "ns1:OpenMapExe", id, "");
	case SOAP_TYPE__ns1__GetEmfPngFileResponse:
		return ((_ns1__GetEmfPngFileResponse *)ptr)->soap_out(soap, "ns1:GetEmfPngFileResponse", id, "");
	case SOAP_TYPE__ns1__GetEmfPngFile:
		return ((_ns1__GetEmfPngFile *)ptr)->soap_out(soap, "ns1:GetEmfPngFile", id, "");
	case SOAP_TYPE__ns1__GetEmfPngVerResponse:
		return ((_ns1__GetEmfPngVerResponse *)ptr)->soap_out(soap, "ns1:GetEmfPngVerResponse", id, "");
	case SOAP_TYPE__ns1__GetEmfPngVer:
		return ((_ns1__GetEmfPngVer *)ptr)->soap_out(soap, "ns1:GetEmfPngVer", id, "");
	case SOAP_TYPE__ns1__OpenProcessResponse:
		return ((_ns1__OpenProcessResponse *)ptr)->soap_out(soap, "ns1:OpenProcessResponse", id, "");
	case SOAP_TYPE__ns1__OpenProcess:
		return ((_ns1__OpenProcess *)ptr)->soap_out(soap, "ns1:OpenProcess", id, "");
	case SOAP_TYPE__ns1__GetMangeMapUpdateResponse:
		return ((_ns1__GetMangeMapUpdateResponse *)ptr)->soap_out(soap, "ns1:GetMangeMapUpdateResponse", id, "");
	case SOAP_TYPE__ns1__GetMangeMapUpdate:
		return ((_ns1__GetMangeMapUpdate *)ptr)->soap_out(soap, "ns1:GetMangeMapUpdate", id, "");
	case SOAP_TYPE__ns1__GetUnitMapVerResponse:
		return ((_ns1__GetUnitMapVerResponse *)ptr)->soap_out(soap, "ns1:GetUnitMapVerResponse", id, "");
	case SOAP_TYPE__ns1__GetUnitMapVer:
		return ((_ns1__GetUnitMapVer *)ptr)->soap_out(soap, "ns1:GetUnitMapVer", id, "");
	case SOAP_TYPE__ns1__UpdateGzclMapResponse:
		return ((_ns1__UpdateGzclMapResponse *)ptr)->soap_out(soap, "ns1:UpdateGzclMapResponse", id, "");
	case SOAP_TYPE__ns1__UpdateGzclMap:
		return ((_ns1__UpdateGzclMap *)ptr)->soap_out(soap, "ns1:UpdateGzclMap", id, "");
	case SOAP_TYPE__ns1__GetMapListTimeResponse:
		return ((_ns1__GetMapListTimeResponse *)ptr)->soap_out(soap, "ns1:GetMapListTimeResponse", id, "");
	case SOAP_TYPE__ns1__GetMapListTime:
		return ((_ns1__GetMapListTime *)ptr)->soap_out(soap, "ns1:GetMapListTime", id, "");
	case SOAP_TYPE__ns1__ServerLevelResponse:
		return ((_ns1__ServerLevelResponse *)ptr)->soap_out(soap, "ns1:ServerLevelResponse", id, "");
	case SOAP_TYPE__ns1__ServerLevel:
		return ((_ns1__ServerLevel *)ptr)->soap_out(soap, "ns1:ServerLevel", id, "");
	case SOAP_TYPE__ns1__GetTableDataResponse:
		return ((_ns1__GetTableDataResponse *)ptr)->soap_out(soap, "ns1:GetTableDataResponse", id, "");
	case SOAP_TYPE__ns1__GetTableData:
		return ((_ns1__GetTableData *)ptr)->soap_out(soap, "ns1:GetTableData", id, "");
	case SOAP_TYPE__ns1__GetMapResponse:
		return ((_ns1__GetMapResponse *)ptr)->soap_out(soap, "ns1:GetMapResponse", id, "");
	case SOAP_TYPE__ns1__GetMap:
		return ((_ns1__GetMap *)ptr)->soap_out(soap, "ns1:GetMap", id, "");
	case SOAP_TYPE__ns1__CheckMapVerResponse:
		return ((_ns1__CheckMapVerResponse *)ptr)->soap_out(soap, "ns1:CheckMapVerResponse", id, "");
	case SOAP_TYPE__ns1__CheckMapVer:
		return ((_ns1__CheckMapVer *)ptr)->soap_out(soap, "ns1:CheckMapVer", id, "");
	case SOAP_TYPE__ns1__GetMangeXbResponse:
		return ((_ns1__GetMangeXbResponse *)ptr)->soap_out(soap, "ns1:GetMangeXbResponse", id, "");
	case SOAP_TYPE__ns1__GetMangeXb:
		return ((_ns1__GetMangeXb *)ptr)->soap_out(soap, "ns1:GetMangeXb", id, "");
	case SOAP_TYPE__ns1__GetMangeUnitResponse:
		return ((_ns1__GetMangeUnitResponse *)ptr)->soap_out(soap, "ns1:GetMangeUnitResponse", id, "");
	case SOAP_TYPE__ns1__GetMangeUnit:
		return ((_ns1__GetMangeUnit *)ptr)->soap_out(soap, "ns1:GetMangeUnit", id, "");
	case SOAP_TYPE__ns1__GetMaListResponse:
		return ((_ns1__GetMaListResponse *)ptr)->soap_out(soap, "ns1:GetMaListResponse", id, "");
	case SOAP_TYPE__ns1__GetMaList:
		return ((_ns1__GetMaList *)ptr)->soap_out(soap, "ns1:GetMaList", id, "");
	case SOAP_TYPE__ns1__GetMapDeviceDataResponse:
		return ((_ns1__GetMapDeviceDataResponse *)ptr)->soap_out(soap, "ns1:GetMapDeviceDataResponse", id, "");
	case SOAP_TYPE__ns1__GetMapDeviceData:
		return ((_ns1__GetMapDeviceData *)ptr)->soap_out(soap, "ns1:GetMapDeviceData", id, "");
	case SOAP_TYPE__ns1__GetMapTabNameResponse:
		return ((_ns1__GetMapTabNameResponse *)ptr)->soap_out(soap, "ns1:GetMapTabNameResponse", id, "");
	case SOAP_TYPE__ns1__GetMapTabName:
		return ((_ns1__GetMapTabName *)ptr)->soap_out(soap, "ns1:GetMapTabName", id, "");
	case SOAP_TYPE__ns1__GetMapUpdateTimeResponse:
		return ((_ns1__GetMapUpdateTimeResponse *)ptr)->soap_out(soap, "ns1:GetMapUpdateTimeResponse", id, "");
	case SOAP_TYPE__ns1__GetMapUpdateTime:
		return ((_ns1__GetMapUpdateTime *)ptr)->soap_out(soap, "ns1:GetMapUpdateTime", id, "");
	case SOAP_TYPE__ns1__WriteFileResponse:
		return ((_ns1__WriteFileResponse *)ptr)->soap_out(soap, "ns1:WriteFileResponse", id, "");
	case SOAP_TYPE__ns1__WriteFile:
		return ((_ns1__WriteFile *)ptr)->soap_out(soap, "ns1:WriteFile", id, "");
	case SOAP_TYPE__ns1__DownLoadFileResponse:
		return ((_ns1__DownLoadFileResponse *)ptr)->soap_out(soap, "ns1:DownLoadFileResponse", id, "");
	case SOAP_TYPE__ns1__DownLoadFile:
		return ((_ns1__DownLoadFile *)ptr)->soap_out(soap, "ns1:DownLoadFile", id, "");
	case SOAP_TYPE__ns1__ExecuteSqlForFileResponse:
		return ((_ns1__ExecuteSqlForFileResponse *)ptr)->soap_out(soap, "ns1:ExecuteSqlForFileResponse", id, "");
	case SOAP_TYPE__ns1__ExecuteSqlForFile:
		return ((_ns1__ExecuteSqlForFile *)ptr)->soap_out(soap, "ns1:ExecuteSqlForFile", id, "");
	case SOAP_TYPE__ns1__GetFieldInfoResponse:
		return ((_ns1__GetFieldInfoResponse *)ptr)->soap_out(soap, "ns1:GetFieldInfoResponse", id, "");
	case SOAP_TYPE__ns1__GetFieldInfo:
		return ((_ns1__GetFieldInfo *)ptr)->soap_out(soap, "ns1:GetFieldInfo", id, "");
	case SOAP_TYPE__ns1__IsOracleTableResponse:
		return ((_ns1__IsOracleTableResponse *)ptr)->soap_out(soap, "ns1:IsOracleTableResponse", id, "");
	case SOAP_TYPE__ns1__IsOracleTable:
		return ((_ns1__IsOracleTable *)ptr)->soap_out(soap, "ns1:IsOracleTable", id, "");
	case SOAP_TYPE__ns1__GetTabListResponse:
		return ((_ns1__GetTabListResponse *)ptr)->soap_out(soap, "ns1:GetTabListResponse", id, "");
	case SOAP_TYPE__ns1__GetTabList:
		return ((_ns1__GetTabList *)ptr)->soap_out(soap, "ns1:GetTabList", id, "");
	case SOAP_TYPE__ns1__DownCQDataResponse:
		return ((_ns1__DownCQDataResponse *)ptr)->soap_out(soap, "ns1:DownCQDataResponse", id, "");
	case SOAP_TYPE__ns1__DownCQData:
		return ((_ns1__DownCQData *)ptr)->soap_out(soap, "ns1:DownCQData", id, "");
	case SOAP_TYPE__ns1__AlterTableResponse:
		return ((_ns1__AlterTableResponse *)ptr)->soap_out(soap, "ns1:AlterTableResponse", id, "");
	case SOAP_TYPE__ns1__AlterTable:
		return ((_ns1__AlterTable *)ptr)->soap_out(soap, "ns1:AlterTable", id, "");
	case SOAP_TYPE__ns1__GetFileNewResponse:
		return ((_ns1__GetFileNewResponse *)ptr)->soap_out(soap, "ns1:GetFileNewResponse", id, "");
	case SOAP_TYPE__ns1__GetFileNew:
		return ((_ns1__GetFileNew *)ptr)->soap_out(soap, "ns1:GetFileNew", id, "");
	case SOAP_TYPE__ns1__DownMapfileResponse:
		return ((_ns1__DownMapfileResponse *)ptr)->soap_out(soap, "ns1:DownMapfileResponse", id, "");
	case SOAP_TYPE__ns1__DownMapfile:
		return ((_ns1__DownMapfile *)ptr)->soap_out(soap, "ns1:DownMapfile", id, "");
	case SOAP_TYPE__ns1__GetDownFileInfoResponse:
		return ((_ns1__GetDownFileInfoResponse *)ptr)->soap_out(soap, "ns1:GetDownFileInfoResponse", id, "");
	case SOAP_TYPE__ns1__GetDownFileInfo:
		return ((_ns1__GetDownFileInfo *)ptr)->soap_out(soap, "ns1:GetDownFileInfo", id, "");
	case SOAP_TYPE__ns1__GetGxDeviceDataResponse:
		return ((_ns1__GetGxDeviceDataResponse *)ptr)->soap_out(soap, "ns1:GetGxDeviceDataResponse", id, "");
	case SOAP_TYPE__ns1__GetGxDeviceData:
		return ((_ns1__GetGxDeviceData *)ptr)->soap_out(soap, "ns1:GetGxDeviceData", id, "");
	case SOAP_TYPE__ns1__GetMapDeviceTypeResponse:
		return ((_ns1__GetMapDeviceTypeResponse *)ptr)->soap_out(soap, "ns1:GetMapDeviceTypeResponse", id, "");
	case SOAP_TYPE__ns1__GetMapDeviceType:
		return ((_ns1__GetMapDeviceType *)ptr)->soap_out(soap, "ns1:GetMapDeviceType", id, "");
	case SOAP_TYPE__ns1__GetXbStationListResponse:
		return ((_ns1__GetXbStationListResponse *)ptr)->soap_out(soap, "ns1:GetXbStationListResponse", id, "");
	case SOAP_TYPE__ns1__GetXbStationList:
		return ((_ns1__GetXbStationList *)ptr)->soap_out(soap, "ns1:GetXbStationList", id, "");
	case SOAP_TYPE__ns1__GetXbListResponse:
		return ((_ns1__GetXbListResponse *)ptr)->soap_out(soap, "ns1:GetXbListResponse", id, "");
	case SOAP_TYPE__ns1__GetXbList:
		return ((_ns1__GetXbList *)ptr)->soap_out(soap, "ns1:GetXbList", id, "");
	case SOAP_TYPE__ns1__GetFileSizeResponse:
		return ((_ns1__GetFileSizeResponse *)ptr)->soap_out(soap, "ns1:GetFileSizeResponse", id, "");
	case SOAP_TYPE__ns1__GetFileSize:
		return ((_ns1__GetFileSize *)ptr)->soap_out(soap, "ns1:GetFileSize", id, "");
	case SOAP_TYPE__ns1__GetUnitPersonInfoResponse:
		return ((_ns1__GetUnitPersonInfoResponse *)ptr)->soap_out(soap, "ns1:GetUnitPersonInfoResponse", id, "");
	case SOAP_TYPE__ns1__GetUnitPersonInfo:
		return ((_ns1__GetUnitPersonInfo *)ptr)->soap_out(soap, "ns1:GetUnitPersonInfo", id, "");
	case SOAP_TYPE__ns1__GetUnitStructResponse:
		return ((_ns1__GetUnitStructResponse *)ptr)->soap_out(soap, "ns1:GetUnitStructResponse", id, "");
	case SOAP_TYPE__ns1__GetUnitStruct:
		return ((_ns1__GetUnitStruct *)ptr)->soap_out(soap, "ns1:GetUnitStruct", id, "");
	case SOAP_TYPE__ns1__GetUnitStationResponse:
		return ((_ns1__GetUnitStationResponse *)ptr)->soap_out(soap, "ns1:GetUnitStationResponse", id, "");
	case SOAP_TYPE__ns1__GetUnitStation:
		return ((_ns1__GetUnitStation *)ptr)->soap_out(soap, "ns1:GetUnitStation", id, "");
	case SOAP_TYPE__ns1__GetDwListResponse:
		return ((_ns1__GetDwListResponse *)ptr)->soap_out(soap, "ns1:GetDwListResponse", id, "");
	case SOAP_TYPE__ns1__GetDwList:
		return ((_ns1__GetDwList *)ptr)->soap_out(soap, "ns1:GetDwList", id, "");
	case SOAP_TYPE__ns1__GetOpenFireInfoResponse:
		return ((_ns1__GetOpenFireInfoResponse *)ptr)->soap_out(soap, "ns1:GetOpenFireInfoResponse", id, "");
	case SOAP_TYPE__ns1__GetOpenFireInfo:
		return ((_ns1__GetOpenFireInfo *)ptr)->soap_out(soap, "ns1:GetOpenFireInfo", id, "");
	case SOAP_TYPE__ns1__MobDownLoadDataResponse:
		return ((_ns1__MobDownLoadDataResponse *)ptr)->soap_out(soap, "ns1:MobDownLoadDataResponse", id, "");
	case SOAP_TYPE__ns1__MobDownLoadData:
		return ((_ns1__MobDownLoadData *)ptr)->soap_out(soap, "ns1:MobDownLoadData", id, "");
	case SOAP_TYPE__ns1__DownLoadMobGPSDataResponse:
		return ((_ns1__DownLoadMobGPSDataResponse *)ptr)->soap_out(soap, "ns1:DownLoadMobGPSDataResponse", id, "");
	case SOAP_TYPE__ns1__DownLoadMobGPSData:
		return ((_ns1__DownLoadMobGPSData *)ptr)->soap_out(soap, "ns1:DownLoadMobGPSData", id, "");
	case SOAP_TYPE__ns1__GetDcsDataResponse:
		return ((_ns1__GetDcsDataResponse *)ptr)->soap_out(soap, "ns1:GetDcsDataResponse", id, "");
	case SOAP_TYPE__ns1__GetDcsData:
		return ((_ns1__GetDcsData *)ptr)->soap_out(soap, "ns1:GetDcsData", id, "");
	case SOAP_TYPE__ns1__GetBgImgResponse:
		return ((_ns1__GetBgImgResponse *)ptr)->soap_out(soap, "ns1:GetBgImgResponse", id, "");
	case SOAP_TYPE__ns1__GetBgImg:
		return ((_ns1__GetBgImg *)ptr)->soap_out(soap, "ns1:GetBgImg", id, "");
	case SOAP_TYPE__ns1__GetDevPicResponse:
		return ((_ns1__GetDevPicResponse *)ptr)->soap_out(soap, "ns1:GetDevPicResponse", id, "");
	case SOAP_TYPE__ns1__GetDevPic:
		return ((_ns1__GetDevPic *)ptr)->soap_out(soap, "ns1:GetDevPic", id, "");
	case SOAP_TYPE__ns1__GetJxPicResponse:
		return ((_ns1__GetJxPicResponse *)ptr)->soap_out(soap, "ns1:GetJxPicResponse", id, "");
	case SOAP_TYPE__ns1__GetJxPic:
		return ((_ns1__GetJxPic *)ptr)->soap_out(soap, "ns1:GetJxPic", id, "");
	case SOAP_TYPE__ns1__GetStationJxDataResponse:
		return ((_ns1__GetStationJxDataResponse *)ptr)->soap_out(soap, "ns1:GetStationJxDataResponse", id, "");
	case SOAP_TYPE__ns1__GetStationJxData:
		return ((_ns1__GetStationJxData *)ptr)->soap_out(soap, "ns1:GetStationJxData", id, "");
	case SOAP_TYPE__ns1__GetJxDataResponse:
		return ((_ns1__GetJxDataResponse *)ptr)->soap_out(soap, "ns1:GetJxDataResponse", id, "");
	case SOAP_TYPE__ns1__GetJxData:
		return ((_ns1__GetJxData *)ptr)->soap_out(soap, "ns1:GetJxData", id, "");
	case SOAP_TYPE__ns1__GetDeviceXjResponse:
		return ((_ns1__GetDeviceXjResponse *)ptr)->soap_out(soap, "ns1:GetDeviceXjResponse", id, "");
	case SOAP_TYPE__ns1__GetDeviceXj:
		return ((_ns1__GetDeviceXj *)ptr)->soap_out(soap, "ns1:GetDeviceXj", id, "");
	case SOAP_TYPE__ns1__GetDwPicResponse:
		return ((_ns1__GetDwPicResponse *)ptr)->soap_out(soap, "ns1:GetDwPicResponse", id, "");
	case SOAP_TYPE__ns1__GetDwPic:
		return ((_ns1__GetDwPic *)ptr)->soap_out(soap, "ns1:GetDwPic", id, "");
	case SOAP_TYPE__ns1__GetDwInfoResponse:
		return ((_ns1__GetDwInfoResponse *)ptr)->soap_out(soap, "ns1:GetDwInfoResponse", id, "");
	case SOAP_TYPE__ns1__GetDwInfo:
		return ((_ns1__GetDwInfo *)ptr)->soap_out(soap, "ns1:GetDwInfo", id, "");
	case SOAP_TYPE__ns1__GetPicNamesResponse:
		return ((_ns1__GetPicNamesResponse *)ptr)->soap_out(soap, "ns1:GetPicNamesResponse", id, "");
	case SOAP_TYPE__ns1__GetPicNames:
		return ((_ns1__GetPicNames *)ptr)->soap_out(soap, "ns1:GetPicNames", id, "");
	case SOAP_TYPE__ns1__DownloadPicResponse:
		return ((_ns1__DownloadPicResponse *)ptr)->soap_out(soap, "ns1:DownloadPicResponse", id, "");
	case SOAP_TYPE__ns1__DownloadPic:
		return ((_ns1__DownloadPic *)ptr)->soap_out(soap, "ns1:DownloadPic", id, "");
	case SOAP_TYPE__ns1__upPicResponse:
		return ((_ns1__upPicResponse *)ptr)->soap_out(soap, "ns1:upPicResponse", id, "");
	case SOAP_TYPE__ns1__upPic:
		return ((_ns1__upPic *)ptr)->soap_out(soap, "ns1:upPic", id, "");
	case SOAP_TYPE__ns1__UpLoadFileResponse:
		return ((_ns1__UpLoadFileResponse *)ptr)->soap_out(soap, "ns1:UpLoadFileResponse", id, "");
	case SOAP_TYPE__ns1__UpLoadFile:
		return ((_ns1__UpLoadFile *)ptr)->soap_out(soap, "ns1:UpLoadFile", id, "");
	case SOAP_TYPE__ns1__GetAPVupdaterResponse:
		return ((_ns1__GetAPVupdaterResponse *)ptr)->soap_out(soap, "ns1:GetAPVupdaterResponse", id, "");
	case SOAP_TYPE__ns1__GetAPVupdater:
		return ((_ns1__GetAPVupdater *)ptr)->soap_out(soap, "ns1:GetAPVupdater", id, "");
	case SOAP_TYPE__ns1__GetXHYDGLXTupdaterResponse:
		return ((_ns1__GetXHYDGLXTupdaterResponse *)ptr)->soap_out(soap, "ns1:GetXHYDGLXTupdaterResponse", id, "");
	case SOAP_TYPE__ns1__GetXHYDGLXTupdater:
		return ((_ns1__GetXHYDGLXTupdater *)ptr)->soap_out(soap, "ns1:GetXHYDGLXTupdater", id, "");
	case SOAP_TYPE__ns1__ExecuteSqlForColbResponse:
		return ((_ns1__ExecuteSqlForColbResponse *)ptr)->soap_out(soap, "ns1:ExecuteSqlForColbResponse", id, "");
	case SOAP_TYPE__ns1__ExecuteSqlForColb:
		return ((_ns1__ExecuteSqlForColb *)ptr)->soap_out(soap, "ns1:ExecuteSqlForColb", id, "");
	case SOAP_TYPE__ns1__UpLoadDataResponse:
		return ((_ns1__UpLoadDataResponse *)ptr)->soap_out(soap, "ns1:UpLoadDataResponse", id, "");
	case SOAP_TYPE__ns1__UpLoadData:
		return ((_ns1__UpLoadData *)ptr)->soap_out(soap, "ns1:UpLoadData", id, "");
	case SOAP_TYPE__ns1__TcdSendupResponse:
		return ((_ns1__TcdSendupResponse *)ptr)->soap_out(soap, "ns1:TcdSendupResponse", id, "");
	case SOAP_TYPE__ns1__TcdSendup:
		return ((_ns1__TcdSendup *)ptr)->soap_out(soap, "ns1:TcdSendup", id, "");
	case SOAP_TYPE__ns1__TcdQueryResponse:
		return ((_ns1__TcdQueryResponse *)ptr)->soap_out(soap, "ns1:TcdQueryResponse", id, "");
	case SOAP_TYPE__ns1__TcdQuery:
		return ((_ns1__TcdQuery *)ptr)->soap_out(soap, "ns1:TcdQuery", id, "");
	case SOAP_TYPE__ns1__QueryPhotobwResponse:
		return ((_ns1__QueryPhotobwResponse *)ptr)->soap_out(soap, "ns1:QueryPhotobwResponse", id, "");
	case SOAP_TYPE__ns1__QueryPhotobw:
		return ((_ns1__QueryPhotobw *)ptr)->soap_out(soap, "ns1:QueryPhotobw", id, "");
	case SOAP_TYPE__ns1__GetOsDateTimeResponse:
		return ((_ns1__GetOsDateTimeResponse *)ptr)->soap_out(soap, "ns1:GetOsDateTimeResponse", id, "");
	case SOAP_TYPE__ns1__GetOsDateTime:
		return ((_ns1__GetOsDateTime *)ptr)->soap_out(soap, "ns1:GetOsDateTime", id, "");
	case SOAP_TYPE__ns1__signedUserInfoResponse:
		return ((_ns1__signedUserInfoResponse *)ptr)->soap_out(soap, "ns1:signedUserInfoResponse", id, "");
	case SOAP_TYPE__ns1__signedUserInfo:
		return ((_ns1__signedUserInfo *)ptr)->soap_out(soap, "ns1:signedUserInfo", id, "");
	case SOAP_TYPE__ns1__GetGxdataUpTimeResponse:
		return ((_ns1__GetGxdataUpTimeResponse *)ptr)->soap_out(soap, "ns1:GetGxdataUpTimeResponse", id, "");
	case SOAP_TYPE__ns1__GetGxdataUpTime:
		return ((_ns1__GetGxdataUpTime *)ptr)->soap_out(soap, "ns1:GetGxdataUpTime", id, "");
	case SOAP_TYPE__ns1__DownAllPicResponse:
		return ((_ns1__DownAllPicResponse *)ptr)->soap_out(soap, "ns1:DownAllPicResponse", id, "");
	case SOAP_TYPE__ns1__DownAllPic:
		return ((_ns1__DownAllPic *)ptr)->soap_out(soap, "ns1:DownAllPic", id, "");
	case SOAP_TYPE__ns1__DownPicResponse:
		return ((_ns1__DownPicResponse *)ptr)->soap_out(soap, "ns1:DownPicResponse", id, "");
	case SOAP_TYPE__ns1__DownPic:
		return ((_ns1__DownPic *)ptr)->soap_out(soap, "ns1:DownPic", id, "");
	case SOAP_TYPE__ns1__SaveFileDataResponse:
		return ((_ns1__SaveFileDataResponse *)ptr)->soap_out(soap, "ns1:SaveFileDataResponse", id, "");
	case SOAP_TYPE__ns1__SaveFileData:
		return ((_ns1__SaveFileData *)ptr)->soap_out(soap, "ns1:SaveFileData", id, "");
	case SOAP_TYPE__ns1__SaveDataResponse:
		return ((_ns1__SaveDataResponse *)ptr)->soap_out(soap, "ns1:SaveDataResponse", id, "");
	case SOAP_TYPE__ns1__SaveData:
		return ((_ns1__SaveData *)ptr)->soap_out(soap, "ns1:SaveData", id, "");
	case SOAP_TYPE__ns1__ExecuteSqlResponse:
		return ((_ns1__ExecuteSqlResponse *)ptr)->soap_out(soap, "ns1:ExecuteSqlResponse", id, "");
	case SOAP_TYPE__ns1__ExecuteSql:
		return ((_ns1__ExecuteSql *)ptr)->soap_out(soap, "ns1:ExecuteSql", id, "");
	case SOAP_TYPE__ns1__QueryDataCountResponse:
		return ((_ns1__QueryDataCountResponse *)ptr)->soap_out(soap, "ns1:QueryDataCountResponse", id, "");
	case SOAP_TYPE__ns1__QueryDataCount:
		return ((_ns1__QueryDataCount *)ptr)->soap_out(soap, "ns1:QueryDataCount", id, "");
	case SOAP_TYPE__ns1__QueryDataResponse:
		return ((_ns1__QueryDataResponse *)ptr)->soap_out(soap, "ns1:QueryDataResponse", id, "");
	case SOAP_TYPE__ns1__QueryData:
		return ((_ns1__QueryData *)ptr)->soap_out(soap, "ns1:QueryData", id, "");
	case SOAP_TYPE__ns1__GetDBStringResponse:
		return ((_ns1__GetDBStringResponse *)ptr)->soap_out(soap, "ns1:GetDBStringResponse", id, "");
	case SOAP_TYPE__ns1__GetDBString:
		return ((_ns1__GetDBString *)ptr)->soap_out(soap, "ns1:GetDBString", id, "");
	case SOAP_TYPE__ns1__HelloWorldResponse:
		return ((_ns1__HelloWorldResponse *)ptr)->soap_out(soap, "ns1:HelloWorldResponse", id, "");
	case SOAP_TYPE__ns1__HelloWorld:
		return ((_ns1__HelloWorld *)ptr)->soap_out(soap, "ns1:HelloWorld", id, "");
	case SOAP_TYPE__ns1__CheckDevCodeResponse:
		return ((_ns1__CheckDevCodeResponse *)ptr)->soap_out(soap, "ns1:CheckDevCodeResponse", id, "");
	case SOAP_TYPE__ns1__CheckDevCode:
		return ((_ns1__CheckDevCode *)ptr)->soap_out(soap, "ns1:CheckDevCode", id, "");
	case SOAP_TYPE__ns1__GetDevCodeResponse:
		return ((_ns1__GetDevCodeResponse *)ptr)->soap_out(soap, "ns1:GetDevCodeResponse", id, "");
	case SOAP_TYPE__ns1__GetDevCode:
		return ((_ns1__GetDevCode *)ptr)->soap_out(soap, "ns1:GetDevCode", id, "");
	case SOAP_TYPE__ns1__GetRyUnitResponse:
		return ((_ns1__GetRyUnitResponse *)ptr)->soap_out(soap, "ns1:GetRyUnitResponse", id, "");
	case SOAP_TYPE__ns1__GetRyUnit:
		return ((_ns1__GetRyUnit *)ptr)->soap_out(soap, "ns1:GetRyUnit", id, "");
	case SOAP_TYPE__ns1__CheckLoginUserResponse:
		return ((_ns1__CheckLoginUserResponse *)ptr)->soap_out(soap, "ns1:CheckLoginUserResponse", id, "");
	case SOAP_TYPE__ns1__CheckLoginUser:
		return ((_ns1__CheckLoginUser *)ptr)->soap_out(soap, "ns1:CheckLoginUser", id, "");
	case SOAP_TYPE__ns1__GetPropNameResponse:
		return ((_ns1__GetPropNameResponse *)ptr)->soap_out(soap, "ns1:GetPropNameResponse", id, "");
	case SOAP_TYPE__ns1__GetPropName:
		return ((_ns1__GetPropName *)ptr)->soap_out(soap, "ns1:GetPropName", id, "");
	case SOAP_TYPE__ns1__GetPropListResponse:
		return ((_ns1__GetPropListResponse *)ptr)->soap_out(soap, "ns1:GetPropListResponse", id, "");
	case SOAP_TYPE__ns1__GetPropList:
		return ((_ns1__GetPropList *)ptr)->soap_out(soap, "ns1:GetPropList", id, "");
	case SOAP_TYPE__ns1__GetYjzhZskDevFlowChartListResponse:
		return ((_ns1__GetYjzhZskDevFlowChartListResponse *)ptr)->soap_out(soap, "ns1:GetYjzhZskDevFlowChartListResponse", id, "");
	case SOAP_TYPE__ns1__GetYjzhZskDevFlowChartList:
		return ((_ns1__GetYjzhZskDevFlowChartList *)ptr)->soap_out(soap, "ns1:GetYjzhZskDevFlowChartList", id, "");
	case SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartListResponse:
		return ((_ns1__GetYjzhZskOtherFlowChartListResponse *)ptr)->soap_out(soap, "ns1:GetYjzhZskOtherFlowChartListResponse", id, "");
	case SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartList:
		return ((_ns1__GetYjzhZskOtherFlowChartList *)ptr)->soap_out(soap, "ns1:GetYjzhZskOtherFlowChartList", id, "");
	case SOAP_TYPE__ns1__GetYjzhZskGzFlowResponse:
		return ((_ns1__GetYjzhZskGzFlowResponse *)ptr)->soap_out(soap, "ns1:GetYjzhZskGzFlowResponse", id, "");
	case SOAP_TYPE__ns1__GetYjzhZskGzFlow:
		return ((_ns1__GetYjzhZskGzFlow *)ptr)->soap_out(soap, "ns1:GetYjzhZskGzFlow", id, "");
	case SOAP_TYPE_ns1__ArrayOfBase64Binary:
		return ((ns1__ArrayOfBase64Binary *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfBase64Binary");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_PointerTo_ns1__GetYjzhZskAlarmTypes:
		return soap_out_PointerTo_ns1__GetYjzhZskAlarmTypes(soap, tag, id, (_ns1__GetYjzhZskAlarmTypes *const*)ptr, "ns1:GetYjzhZskAlarmTypes");
	case SOAP_TYPE_PointerTo_ns1__SelectYjzhDevice:
		return soap_out_PointerTo_ns1__SelectYjzhDevice(soap, tag, id, (_ns1__SelectYjzhDevice *const*)ptr, "ns1:SelectYjzhDevice");
	case SOAP_TYPE_PointerTo_ns1__SelectYjzhStation:
		return soap_out_PointerTo_ns1__SelectYjzhStation(soap, tag, id, (_ns1__SelectYjzhStation *const*)ptr, "ns1:SelectYjzhStation");
	case SOAP_TYPE_PointerTo_ns1__SaveMapFile:
		return soap_out_PointerTo_ns1__SaveMapFile(soap, tag, id, (_ns1__SaveMapFile *const*)ptr, "ns1:SaveMapFile");
	case SOAP_TYPE_PointerTo_ns1__GzGetDeviceStruct:
		return soap_out_PointerTo_ns1__GzGetDeviceStruct(soap, tag, id, (_ns1__GzGetDeviceStruct *const*)ptr, "ns1:GzGetDeviceStruct");
	case SOAP_TYPE_PointerTo_ns1__GzGetTypeList:
		return soap_out_PointerTo_ns1__GzGetTypeList(soap, tag, id, (_ns1__GzGetTypeList *const*)ptr, "ns1:GzGetTypeList");
	case SOAP_TYPE_PointerTo_ns1__SGCDrawEmf:
		return soap_out_PointerTo_ns1__SGCDrawEmf(soap, tag, id, (_ns1__SGCDrawEmf *const*)ptr, "ns1:SGCDrawEmf");
	case SOAP_TYPE_PointerTo_ns1__FlowChartEmf:
		return soap_out_PointerTo_ns1__FlowChartEmf(soap, tag, id, (_ns1__FlowChartEmf *const*)ptr, "ns1:FlowChartEmf");
	case SOAP_TYPE_PointerTo_ns1__GetZhouQi:
		return soap_out_PointerTo_ns1__GetZhouQi(soap, tag, id, (_ns1__GetZhouQi *const*)ptr, "ns1:GetZhouQi");
	case SOAP_TYPE_PointerTo_ns1__JiChaoQi:
		return soap_out_PointerTo_ns1__JiChaoQi(soap, tag, id, (_ns1__JiChaoQi *const*)ptr, "ns1:JiChaoQi");
	case SOAP_TYPE_PointerTo_ns1__ChaoQi:
		return soap_out_PointerTo_ns1__ChaoQi(soap, tag, id, (_ns1__ChaoQi *const*)ptr, "ns1:ChaoQi");
	case SOAP_TYPE_PointerTo_ns1__OpenMapExe:
		return soap_out_PointerTo_ns1__OpenMapExe(soap, tag, id, (_ns1__OpenMapExe *const*)ptr, "ns1:OpenMapExe");
	case SOAP_TYPE_PointerTo_ns1__GetEmfPngFile:
		return soap_out_PointerTo_ns1__GetEmfPngFile(soap, tag, id, (_ns1__GetEmfPngFile *const*)ptr, "ns1:GetEmfPngFile");
	case SOAP_TYPE_PointerTo_ns1__GetEmfPngVer:
		return soap_out_PointerTo_ns1__GetEmfPngVer(soap, tag, id, (_ns1__GetEmfPngVer *const*)ptr, "ns1:GetEmfPngVer");
	case SOAP_TYPE_PointerTo_ns1__OpenProcess:
		return soap_out_PointerTo_ns1__OpenProcess(soap, tag, id, (_ns1__OpenProcess *const*)ptr, "ns1:OpenProcess");
	case SOAP_TYPE_PointerTo_ns1__GetMangeMapUpdate:
		return soap_out_PointerTo_ns1__GetMangeMapUpdate(soap, tag, id, (_ns1__GetMangeMapUpdate *const*)ptr, "ns1:GetMangeMapUpdate");
	case SOAP_TYPE_PointerTo_ns1__GetUnitMapVer:
		return soap_out_PointerTo_ns1__GetUnitMapVer(soap, tag, id, (_ns1__GetUnitMapVer *const*)ptr, "ns1:GetUnitMapVer");
	case SOAP_TYPE_PointerTo_ns1__UpdateGzclMap:
		return soap_out_PointerTo_ns1__UpdateGzclMap(soap, tag, id, (_ns1__UpdateGzclMap *const*)ptr, "ns1:UpdateGzclMap");
	case SOAP_TYPE_PointerTo_ns1__GetMapListTime:
		return soap_out_PointerTo_ns1__GetMapListTime(soap, tag, id, (_ns1__GetMapListTime *const*)ptr, "ns1:GetMapListTime");
	case SOAP_TYPE_PointerTo_ns1__ServerLevel:
		return soap_out_PointerTo_ns1__ServerLevel(soap, tag, id, (_ns1__ServerLevel *const*)ptr, "ns1:ServerLevel");
	case SOAP_TYPE_PointerTo_ns1__GetTableData:
		return soap_out_PointerTo_ns1__GetTableData(soap, tag, id, (_ns1__GetTableData *const*)ptr, "ns1:GetTableData");
	case SOAP_TYPE_PointerTo_ns1__GetMap:
		return soap_out_PointerTo_ns1__GetMap(soap, tag, id, (_ns1__GetMap *const*)ptr, "ns1:GetMap");
	case SOAP_TYPE_PointerTo_ns1__CheckMapVer:
		return soap_out_PointerTo_ns1__CheckMapVer(soap, tag, id, (_ns1__CheckMapVer *const*)ptr, "ns1:CheckMapVer");
	case SOAP_TYPE_PointerTo_ns1__GetMangeXb:
		return soap_out_PointerTo_ns1__GetMangeXb(soap, tag, id, (_ns1__GetMangeXb *const*)ptr, "ns1:GetMangeXb");
	case SOAP_TYPE_PointerTo_ns1__GetMangeUnit:
		return soap_out_PointerTo_ns1__GetMangeUnit(soap, tag, id, (_ns1__GetMangeUnit *const*)ptr, "ns1:GetMangeUnit");
	case SOAP_TYPE_PointerTo_ns1__GetMaList:
		return soap_out_PointerTo_ns1__GetMaList(soap, tag, id, (_ns1__GetMaList *const*)ptr, "ns1:GetMaList");
	case SOAP_TYPE_PointerTo_ns1__GetMapDeviceData:
		return soap_out_PointerTo_ns1__GetMapDeviceData(soap, tag, id, (_ns1__GetMapDeviceData *const*)ptr, "ns1:GetMapDeviceData");
	case SOAP_TYPE_PointerTo_ns1__GetMapTabName:
		return soap_out_PointerTo_ns1__GetMapTabName(soap, tag, id, (_ns1__GetMapTabName *const*)ptr, "ns1:GetMapTabName");
	case SOAP_TYPE_PointerTo_ns1__GetMapUpdateTime:
		return soap_out_PointerTo_ns1__GetMapUpdateTime(soap, tag, id, (_ns1__GetMapUpdateTime *const*)ptr, "ns1:GetMapUpdateTime");
	case SOAP_TYPE_PointerTo_ns1__WriteFile:
		return soap_out_PointerTo_ns1__WriteFile(soap, tag, id, (_ns1__WriteFile *const*)ptr, "ns1:WriteFile");
	case SOAP_TYPE_PointerTo_ns1__DownLoadFile:
		return soap_out_PointerTo_ns1__DownLoadFile(soap, tag, id, (_ns1__DownLoadFile *const*)ptr, "ns1:DownLoadFile");
	case SOAP_TYPE_PointerTo_ns1__ExecuteSqlForFile:
		return soap_out_PointerTo_ns1__ExecuteSqlForFile(soap, tag, id, (_ns1__ExecuteSqlForFile *const*)ptr, "ns1:ExecuteSqlForFile");
	case SOAP_TYPE_PointerTo_ns1__GetFieldInfo:
		return soap_out_PointerTo_ns1__GetFieldInfo(soap, tag, id, (_ns1__GetFieldInfo *const*)ptr, "ns1:GetFieldInfo");
	case SOAP_TYPE_PointerTo_ns1__IsOracleTable:
		return soap_out_PointerTo_ns1__IsOracleTable(soap, tag, id, (_ns1__IsOracleTable *const*)ptr, "ns1:IsOracleTable");
	case SOAP_TYPE_PointerTo_ns1__GetTabList:
		return soap_out_PointerTo_ns1__GetTabList(soap, tag, id, (_ns1__GetTabList *const*)ptr, "ns1:GetTabList");
	case SOAP_TYPE_PointerTo_ns1__DownCQData:
		return soap_out_PointerTo_ns1__DownCQData(soap, tag, id, (_ns1__DownCQData *const*)ptr, "ns1:DownCQData");
	case SOAP_TYPE_PointerTo_ns1__AlterTable:
		return soap_out_PointerTo_ns1__AlterTable(soap, tag, id, (_ns1__AlterTable *const*)ptr, "ns1:AlterTable");
	case SOAP_TYPE_PointerTo_ns1__GetFileNew:
		return soap_out_PointerTo_ns1__GetFileNew(soap, tag, id, (_ns1__GetFileNew *const*)ptr, "ns1:GetFileNew");
	case SOAP_TYPE_PointerTo_ns1__DownMapfile:
		return soap_out_PointerTo_ns1__DownMapfile(soap, tag, id, (_ns1__DownMapfile *const*)ptr, "ns1:DownMapfile");
	case SOAP_TYPE_PointerTo_ns1__GetDownFileInfo:
		return soap_out_PointerTo_ns1__GetDownFileInfo(soap, tag, id, (_ns1__GetDownFileInfo *const*)ptr, "ns1:GetDownFileInfo");
	case SOAP_TYPE_PointerTo_ns1__GetGxDeviceData:
		return soap_out_PointerTo_ns1__GetGxDeviceData(soap, tag, id, (_ns1__GetGxDeviceData *const*)ptr, "ns1:GetGxDeviceData");
	case SOAP_TYPE_PointerTo_ns1__GetMapDeviceType:
		return soap_out_PointerTo_ns1__GetMapDeviceType(soap, tag, id, (_ns1__GetMapDeviceType *const*)ptr, "ns1:GetMapDeviceType");
	case SOAP_TYPE_PointerTo_ns1__GetXbStationList:
		return soap_out_PointerTo_ns1__GetXbStationList(soap, tag, id, (_ns1__GetXbStationList *const*)ptr, "ns1:GetXbStationList");
	case SOAP_TYPE_PointerTo_ns1__GetXbList:
		return soap_out_PointerTo_ns1__GetXbList(soap, tag, id, (_ns1__GetXbList *const*)ptr, "ns1:GetXbList");
	case SOAP_TYPE_PointerTo_ns1__GetFileSize:
		return soap_out_PointerTo_ns1__GetFileSize(soap, tag, id, (_ns1__GetFileSize *const*)ptr, "ns1:GetFileSize");
	case SOAP_TYPE_PointerTo_ns1__GetUnitPersonInfo:
		return soap_out_PointerTo_ns1__GetUnitPersonInfo(soap, tag, id, (_ns1__GetUnitPersonInfo *const*)ptr, "ns1:GetUnitPersonInfo");
	case SOAP_TYPE_PointerTo_ns1__GetUnitStruct:
		return soap_out_PointerTo_ns1__GetUnitStruct(soap, tag, id, (_ns1__GetUnitStruct *const*)ptr, "ns1:GetUnitStruct");
	case SOAP_TYPE_PointerTo_ns1__GetUnitStation:
		return soap_out_PointerTo_ns1__GetUnitStation(soap, tag, id, (_ns1__GetUnitStation *const*)ptr, "ns1:GetUnitStation");
	case SOAP_TYPE_PointerTo_ns1__GetDwList:
		return soap_out_PointerTo_ns1__GetDwList(soap, tag, id, (_ns1__GetDwList *const*)ptr, "ns1:GetDwList");
	case SOAP_TYPE_PointerTo_ns1__GetOpenFireInfo:
		return soap_out_PointerTo_ns1__GetOpenFireInfo(soap, tag, id, (_ns1__GetOpenFireInfo *const*)ptr, "ns1:GetOpenFireInfo");
	case SOAP_TYPE_PointerTo_ns1__MobDownLoadData:
		return soap_out_PointerTo_ns1__MobDownLoadData(soap, tag, id, (_ns1__MobDownLoadData *const*)ptr, "ns1:MobDownLoadData");
	case SOAP_TYPE_PointerTo_ns1__DownLoadMobGPSData:
		return soap_out_PointerTo_ns1__DownLoadMobGPSData(soap, tag, id, (_ns1__DownLoadMobGPSData *const*)ptr, "ns1:DownLoadMobGPSData");
	case SOAP_TYPE_PointerTo_ns1__GetDcsData:
		return soap_out_PointerTo_ns1__GetDcsData(soap, tag, id, (_ns1__GetDcsData *const*)ptr, "ns1:GetDcsData");
	case SOAP_TYPE_PointerTo_ns1__GetBgImg:
		return soap_out_PointerTo_ns1__GetBgImg(soap, tag, id, (_ns1__GetBgImg *const*)ptr, "ns1:GetBgImg");
	case SOAP_TYPE_PointerTo_ns1__GetDevPic:
		return soap_out_PointerTo_ns1__GetDevPic(soap, tag, id, (_ns1__GetDevPic *const*)ptr, "ns1:GetDevPic");
	case SOAP_TYPE_PointerTo_ns1__GetJxPic:
		return soap_out_PointerTo_ns1__GetJxPic(soap, tag, id, (_ns1__GetJxPic *const*)ptr, "ns1:GetJxPic");
	case SOAP_TYPE_PointerTo_ns1__GetStationJxData:
		return soap_out_PointerTo_ns1__GetStationJxData(soap, tag, id, (_ns1__GetStationJxData *const*)ptr, "ns1:GetStationJxData");
	case SOAP_TYPE_PointerTo_ns1__GetJxData:
		return soap_out_PointerTo_ns1__GetJxData(soap, tag, id, (_ns1__GetJxData *const*)ptr, "ns1:GetJxData");
	case SOAP_TYPE_PointerTo_ns1__GetDeviceXj:
		return soap_out_PointerTo_ns1__GetDeviceXj(soap, tag, id, (_ns1__GetDeviceXj *const*)ptr, "ns1:GetDeviceXj");
	case SOAP_TYPE_PointerTo_ns1__GetDwPic:
		return soap_out_PointerTo_ns1__GetDwPic(soap, tag, id, (_ns1__GetDwPic *const*)ptr, "ns1:GetDwPic");
	case SOAP_TYPE_PointerTo_ns1__GetDwInfo:
		return soap_out_PointerTo_ns1__GetDwInfo(soap, tag, id, (_ns1__GetDwInfo *const*)ptr, "ns1:GetDwInfo");
	case SOAP_TYPE_PointerTo_ns1__GetPicNames:
		return soap_out_PointerTo_ns1__GetPicNames(soap, tag, id, (_ns1__GetPicNames *const*)ptr, "ns1:GetPicNames");
	case SOAP_TYPE_PointerTo_ns1__DownloadPic:
		return soap_out_PointerTo_ns1__DownloadPic(soap, tag, id, (_ns1__DownloadPic *const*)ptr, "ns1:DownloadPic");
	case SOAP_TYPE_PointerTo_ns1__upPic:
		return soap_out_PointerTo_ns1__upPic(soap, tag, id, (_ns1__upPic *const*)ptr, "ns1:upPic");
	case SOAP_TYPE_PointerTo_ns1__UpLoadFile:
		return soap_out_PointerTo_ns1__UpLoadFile(soap, tag, id, (_ns1__UpLoadFile *const*)ptr, "ns1:UpLoadFile");
	case SOAP_TYPE_PointerTo_ns1__GetAPVupdater:
		return soap_out_PointerTo_ns1__GetAPVupdater(soap, tag, id, (_ns1__GetAPVupdater *const*)ptr, "ns1:GetAPVupdater");
	case SOAP_TYPE_PointerTo_ns1__GetXHYDGLXTupdater:
		return soap_out_PointerTo_ns1__GetXHYDGLXTupdater(soap, tag, id, (_ns1__GetXHYDGLXTupdater *const*)ptr, "ns1:GetXHYDGLXTupdater");
	case SOAP_TYPE_PointerTo_ns1__ExecuteSqlForColb:
		return soap_out_PointerTo_ns1__ExecuteSqlForColb(soap, tag, id, (_ns1__ExecuteSqlForColb *const*)ptr, "ns1:ExecuteSqlForColb");
	case SOAP_TYPE_PointerTo_ns1__UpLoadData:
		return soap_out_PointerTo_ns1__UpLoadData(soap, tag, id, (_ns1__UpLoadData *const*)ptr, "ns1:UpLoadData");
	case SOAP_TYPE_PointerTo_ns1__TcdSendup:
		return soap_out_PointerTo_ns1__TcdSendup(soap, tag, id, (_ns1__TcdSendup *const*)ptr, "ns1:TcdSendup");
	case SOAP_TYPE_PointerTo_ns1__TcdQuery:
		return soap_out_PointerTo_ns1__TcdQuery(soap, tag, id, (_ns1__TcdQuery *const*)ptr, "ns1:TcdQuery");
	case SOAP_TYPE_PointerTo_ns1__QueryPhotobw:
		return soap_out_PointerTo_ns1__QueryPhotobw(soap, tag, id, (_ns1__QueryPhotobw *const*)ptr, "ns1:QueryPhotobw");
	case SOAP_TYPE_PointerTo_ns1__GetOsDateTime:
		return soap_out_PointerTo_ns1__GetOsDateTime(soap, tag, id, (_ns1__GetOsDateTime *const*)ptr, "ns1:GetOsDateTime");
	case SOAP_TYPE_PointerTo_ns1__signedUserInfo:
		return soap_out_PointerTo_ns1__signedUserInfo(soap, tag, id, (_ns1__signedUserInfo *const*)ptr, "ns1:signedUserInfo");
	case SOAP_TYPE_PointerTo_ns1__GetGxdataUpTime:
		return soap_out_PointerTo_ns1__GetGxdataUpTime(soap, tag, id, (_ns1__GetGxdataUpTime *const*)ptr, "ns1:GetGxdataUpTime");
	case SOAP_TYPE_PointerTo_ns1__DownAllPic:
		return soap_out_PointerTo_ns1__DownAllPic(soap, tag, id, (_ns1__DownAllPic *const*)ptr, "ns1:DownAllPic");
	case SOAP_TYPE_PointerTo_ns1__DownPic:
		return soap_out_PointerTo_ns1__DownPic(soap, tag, id, (_ns1__DownPic *const*)ptr, "ns1:DownPic");
	case SOAP_TYPE_PointerTo_ns1__SaveFileData:
		return soap_out_PointerTo_ns1__SaveFileData(soap, tag, id, (_ns1__SaveFileData *const*)ptr, "ns1:SaveFileData");
	case SOAP_TYPE_PointerTo_ns1__SaveData:
		return soap_out_PointerTo_ns1__SaveData(soap, tag, id, (_ns1__SaveData *const*)ptr, "ns1:SaveData");
	case SOAP_TYPE_PointerTo_ns1__ExecuteSql:
		return soap_out_PointerTo_ns1__ExecuteSql(soap, tag, id, (_ns1__ExecuteSql *const*)ptr, "ns1:ExecuteSql");
	case SOAP_TYPE_PointerTo_ns1__QueryDataCount:
		return soap_out_PointerTo_ns1__QueryDataCount(soap, tag, id, (_ns1__QueryDataCount *const*)ptr, "ns1:QueryDataCount");
	case SOAP_TYPE_PointerTo_ns1__QueryData:
		return soap_out_PointerTo_ns1__QueryData(soap, tag, id, (_ns1__QueryData *const*)ptr, "ns1:QueryData");
	case SOAP_TYPE_PointerTo_ns1__GetDBString:
		return soap_out_PointerTo_ns1__GetDBString(soap, tag, id, (_ns1__GetDBString *const*)ptr, "ns1:GetDBString");
	case SOAP_TYPE_PointerTo_ns1__HelloWorld:
		return soap_out_PointerTo_ns1__HelloWorld(soap, tag, id, (_ns1__HelloWorld *const*)ptr, "ns1:HelloWorld");
	case SOAP_TYPE_PointerTo_ns1__CheckDevCode:
		return soap_out_PointerTo_ns1__CheckDevCode(soap, tag, id, (_ns1__CheckDevCode *const*)ptr, "ns1:CheckDevCode");
	case SOAP_TYPE_PointerTo_ns1__GetDevCode:
		return soap_out_PointerTo_ns1__GetDevCode(soap, tag, id, (_ns1__GetDevCode *const*)ptr, "ns1:GetDevCode");
	case SOAP_TYPE_PointerTo_ns1__GetRyUnit:
		return soap_out_PointerTo_ns1__GetRyUnit(soap, tag, id, (_ns1__GetRyUnit *const*)ptr, "ns1:GetRyUnit");
	case SOAP_TYPE_PointerTo_ns1__CheckLoginUser:
		return soap_out_PointerTo_ns1__CheckLoginUser(soap, tag, id, (_ns1__CheckLoginUser *const*)ptr, "ns1:CheckLoginUser");
	case SOAP_TYPE_PointerTo_ns1__GetPropName:
		return soap_out_PointerTo_ns1__GetPropName(soap, tag, id, (_ns1__GetPropName *const*)ptr, "ns1:GetPropName");
	case SOAP_TYPE_PointerTo_ns1__GetPropList:
		return soap_out_PointerTo_ns1__GetPropList(soap, tag, id, (_ns1__GetPropList *const*)ptr, "ns1:GetPropList");
	case SOAP_TYPE_PointerTo_ns1__GetYjzhZskDevFlowChartList:
		return soap_out_PointerTo_ns1__GetYjzhZskDevFlowChartList(soap, tag, id, (_ns1__GetYjzhZskDevFlowChartList *const*)ptr, "ns1:GetYjzhZskDevFlowChartList");
	case SOAP_TYPE_PointerTo_ns1__GetYjzhZskOtherFlowChartList:
		return soap_out_PointerTo_ns1__GetYjzhZskOtherFlowChartList(soap, tag, id, (_ns1__GetYjzhZskOtherFlowChartList *const*)ptr, "ns1:GetYjzhZskOtherFlowChartList");
	case SOAP_TYPE_PointerTo_ns1__GetYjzhZskGzFlow:
		return soap_out_PointerTo_ns1__GetYjzhZskGzFlow(soap, tag, id, (_ns1__GetYjzhZskGzFlow *const*)ptr, "ns1:GetYjzhZskGzFlow");
	case SOAP_TYPE_PointerTons1__ArrayOfBase64Binary:
		return soap_out_PointerTons1__ArrayOfBase64Binary(soap, tag, id, (ns1__ArrayOfBase64Binary *const*)ptr, "ns1:ArrayOfBase64Binary");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_out_PointerToxsd__base64Binary(soap, tag, id, (xsd__base64Binary *const*)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag); /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns1__GetYjzhZskAlarmTypesResponse:
		((_ns1__GetYjzhZskAlarmTypesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetYjzhZskAlarmTypes:
		((_ns1__GetYjzhZskAlarmTypes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SelectYjzhDeviceResponse:
		((_ns1__SelectYjzhDeviceResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SelectYjzhDevice:
		((_ns1__SelectYjzhDevice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SelectYjzhStationResponse:
		((_ns1__SelectYjzhStationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SelectYjzhStation:
		((_ns1__SelectYjzhStation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SaveMapFileResponse:
		((_ns1__SaveMapFileResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SaveMapFile:
		((_ns1__SaveMapFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GzGetDeviceStructResponse:
		((_ns1__GzGetDeviceStructResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GzGetDeviceStruct:
		((_ns1__GzGetDeviceStruct *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GzGetTypeListResponse:
		((_ns1__GzGetTypeListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GzGetTypeList:
		((_ns1__GzGetTypeList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SGCDrawEmfResponse:
		((_ns1__SGCDrawEmfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SGCDrawEmf:
		((_ns1__SGCDrawEmf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__FlowChartEmfResponse:
		((_ns1__FlowChartEmfResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__FlowChartEmf:
		((_ns1__FlowChartEmf *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetZhouQiResponse:
		((_ns1__GetZhouQiResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetZhouQi:
		((_ns1__GetZhouQi *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__JiChaoQiResponse:
		((_ns1__JiChaoQiResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__JiChaoQi:
		((_ns1__JiChaoQi *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ChaoQiResponse:
		((_ns1__ChaoQiResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ChaoQi:
		((_ns1__ChaoQi *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OpenMapExeResponse:
		((_ns1__OpenMapExeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OpenMapExe:
		((_ns1__OpenMapExe *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetEmfPngFileResponse:
		((_ns1__GetEmfPngFileResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetEmfPngFile:
		((_ns1__GetEmfPngFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetEmfPngVerResponse:
		((_ns1__GetEmfPngVerResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetEmfPngVer:
		((_ns1__GetEmfPngVer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OpenProcessResponse:
		((_ns1__OpenProcessResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OpenProcess:
		((_ns1__OpenProcess *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMangeMapUpdateResponse:
		((_ns1__GetMangeMapUpdateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMangeMapUpdate:
		((_ns1__GetMangeMapUpdate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetUnitMapVerResponse:
		((_ns1__GetUnitMapVerResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetUnitMapVer:
		((_ns1__GetUnitMapVer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdateGzclMapResponse:
		((_ns1__UpdateGzclMapResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdateGzclMap:
		((_ns1__UpdateGzclMap *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMapListTimeResponse:
		((_ns1__GetMapListTimeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMapListTime:
		((_ns1__GetMapListTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ServerLevelResponse:
		((_ns1__ServerLevelResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ServerLevel:
		((_ns1__ServerLevel *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetTableDataResponse:
		((_ns1__GetTableDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetTableData:
		((_ns1__GetTableData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMapResponse:
		((_ns1__GetMapResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMap:
		((_ns1__GetMap *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CheckMapVerResponse:
		((_ns1__CheckMapVerResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CheckMapVer:
		((_ns1__CheckMapVer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMangeXbResponse:
		((_ns1__GetMangeXbResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMangeXb:
		((_ns1__GetMangeXb *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMangeUnitResponse:
		((_ns1__GetMangeUnitResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMangeUnit:
		((_ns1__GetMangeUnit *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMaListResponse:
		((_ns1__GetMaListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMaList:
		((_ns1__GetMaList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMapDeviceDataResponse:
		((_ns1__GetMapDeviceDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMapDeviceData:
		((_ns1__GetMapDeviceData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMapTabNameResponse:
		((_ns1__GetMapTabNameResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMapTabName:
		((_ns1__GetMapTabName *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMapUpdateTimeResponse:
		((_ns1__GetMapUpdateTimeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMapUpdateTime:
		((_ns1__GetMapUpdateTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__WriteFileResponse:
		((_ns1__WriteFileResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__WriteFile:
		((_ns1__WriteFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DownLoadFileResponse:
		((_ns1__DownLoadFileResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DownLoadFile:
		((_ns1__DownLoadFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ExecuteSqlForFileResponse:
		((_ns1__ExecuteSqlForFileResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ExecuteSqlForFile:
		((_ns1__ExecuteSqlForFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetFieldInfoResponse:
		((_ns1__GetFieldInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetFieldInfo:
		((_ns1__GetFieldInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__IsOracleTableResponse:
		((_ns1__IsOracleTableResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__IsOracleTable:
		((_ns1__IsOracleTable *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetTabListResponse:
		((_ns1__GetTabListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetTabList:
		((_ns1__GetTabList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DownCQDataResponse:
		((_ns1__DownCQDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DownCQData:
		((_ns1__DownCQData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AlterTableResponse:
		((_ns1__AlterTableResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AlterTable:
		((_ns1__AlterTable *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetFileNewResponse:
		((_ns1__GetFileNewResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetFileNew:
		((_ns1__GetFileNew *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DownMapfileResponse:
		((_ns1__DownMapfileResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DownMapfile:
		((_ns1__DownMapfile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDownFileInfoResponse:
		((_ns1__GetDownFileInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDownFileInfo:
		((_ns1__GetDownFileInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetGxDeviceDataResponse:
		((_ns1__GetGxDeviceDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetGxDeviceData:
		((_ns1__GetGxDeviceData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMapDeviceTypeResponse:
		((_ns1__GetMapDeviceTypeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetMapDeviceType:
		((_ns1__GetMapDeviceType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetXbStationListResponse:
		((_ns1__GetXbStationListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetXbStationList:
		((_ns1__GetXbStationList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetXbListResponse:
		((_ns1__GetXbListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetXbList:
		((_ns1__GetXbList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetFileSizeResponse:
		((_ns1__GetFileSizeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetFileSize:
		((_ns1__GetFileSize *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetUnitPersonInfoResponse:
		((_ns1__GetUnitPersonInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetUnitPersonInfo:
		((_ns1__GetUnitPersonInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetUnitStructResponse:
		((_ns1__GetUnitStructResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetUnitStruct:
		((_ns1__GetUnitStruct *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetUnitStationResponse:
		((_ns1__GetUnitStationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetUnitStation:
		((_ns1__GetUnitStation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDwListResponse:
		((_ns1__GetDwListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDwList:
		((_ns1__GetDwList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetOpenFireInfoResponse:
		((_ns1__GetOpenFireInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetOpenFireInfo:
		((_ns1__GetOpenFireInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__MobDownLoadDataResponse:
		((_ns1__MobDownLoadDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__MobDownLoadData:
		((_ns1__MobDownLoadData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DownLoadMobGPSDataResponse:
		((_ns1__DownLoadMobGPSDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DownLoadMobGPSData:
		((_ns1__DownLoadMobGPSData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDcsDataResponse:
		((_ns1__GetDcsDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDcsData:
		((_ns1__GetDcsData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetBgImgResponse:
		((_ns1__GetBgImgResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetBgImg:
		((_ns1__GetBgImg *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDevPicResponse:
		((_ns1__GetDevPicResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDevPic:
		((_ns1__GetDevPic *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetJxPicResponse:
		((_ns1__GetJxPicResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetJxPic:
		((_ns1__GetJxPic *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetStationJxDataResponse:
		((_ns1__GetStationJxDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetStationJxData:
		((_ns1__GetStationJxData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetJxDataResponse:
		((_ns1__GetJxDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetJxData:
		((_ns1__GetJxData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDeviceXjResponse:
		((_ns1__GetDeviceXjResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDeviceXj:
		((_ns1__GetDeviceXj *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDwPicResponse:
		((_ns1__GetDwPicResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDwPic:
		((_ns1__GetDwPic *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDwInfoResponse:
		((_ns1__GetDwInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDwInfo:
		((_ns1__GetDwInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPicNamesResponse:
		((_ns1__GetPicNamesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPicNames:
		((_ns1__GetPicNames *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DownloadPicResponse:
		((_ns1__DownloadPicResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DownloadPic:
		((_ns1__DownloadPic *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__upPicResponse:
		((_ns1__upPicResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__upPic:
		((_ns1__upPic *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpLoadFileResponse:
		((_ns1__UpLoadFileResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpLoadFile:
		((_ns1__UpLoadFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAPVupdaterResponse:
		((_ns1__GetAPVupdaterResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAPVupdater:
		((_ns1__GetAPVupdater *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetXHYDGLXTupdaterResponse:
		((_ns1__GetXHYDGLXTupdaterResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetXHYDGLXTupdater:
		((_ns1__GetXHYDGLXTupdater *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ExecuteSqlForColbResponse:
		((_ns1__ExecuteSqlForColbResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ExecuteSqlForColb:
		((_ns1__ExecuteSqlForColb *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpLoadDataResponse:
		((_ns1__UpLoadDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpLoadData:
		((_ns1__UpLoadData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__TcdSendupResponse:
		((_ns1__TcdSendupResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__TcdSendup:
		((_ns1__TcdSendup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__TcdQueryResponse:
		((_ns1__TcdQueryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__TcdQuery:
		((_ns1__TcdQuery *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__QueryPhotobwResponse:
		((_ns1__QueryPhotobwResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__QueryPhotobw:
		((_ns1__QueryPhotobw *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetOsDateTimeResponse:
		((_ns1__GetOsDateTimeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetOsDateTime:
		((_ns1__GetOsDateTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__signedUserInfoResponse:
		((_ns1__signedUserInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__signedUserInfo:
		((_ns1__signedUserInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetGxdataUpTimeResponse:
		((_ns1__GetGxdataUpTimeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetGxdataUpTime:
		((_ns1__GetGxdataUpTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DownAllPicResponse:
		((_ns1__DownAllPicResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DownAllPic:
		((_ns1__DownAllPic *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DownPicResponse:
		((_ns1__DownPicResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DownPic:
		((_ns1__DownPic *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SaveFileDataResponse:
		((_ns1__SaveFileDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SaveFileData:
		((_ns1__SaveFileData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SaveDataResponse:
		((_ns1__SaveDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SaveData:
		((_ns1__SaveData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ExecuteSqlResponse:
		((_ns1__ExecuteSqlResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ExecuteSql:
		((_ns1__ExecuteSql *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__QueryDataCountResponse:
		((_ns1__QueryDataCountResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__QueryDataCount:
		((_ns1__QueryDataCount *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__QueryDataResponse:
		((_ns1__QueryDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__QueryData:
		((_ns1__QueryData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDBStringResponse:
		((_ns1__GetDBStringResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDBString:
		((_ns1__GetDBString *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__HelloWorldResponse:
		((_ns1__HelloWorldResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__HelloWorld:
		((_ns1__HelloWorld *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CheckDevCodeResponse:
		((_ns1__CheckDevCodeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CheckDevCode:
		((_ns1__CheckDevCode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDevCodeResponse:
		((_ns1__GetDevCodeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDevCode:
		((_ns1__GetDevCode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetRyUnitResponse:
		((_ns1__GetRyUnitResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetRyUnit:
		((_ns1__GetRyUnit *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CheckLoginUserResponse:
		((_ns1__CheckLoginUserResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CheckLoginUser:
		((_ns1__CheckLoginUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPropNameResponse:
		((_ns1__GetPropNameResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPropName:
		((_ns1__GetPropName *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPropListResponse:
		((_ns1__GetPropListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPropList:
		((_ns1__GetPropList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetYjzhZskDevFlowChartListResponse:
		((_ns1__GetYjzhZskDevFlowChartListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetYjzhZskDevFlowChartList:
		((_ns1__GetYjzhZskDevFlowChartList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartListResponse:
		((_ns1__GetYjzhZskOtherFlowChartListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartList:
		((_ns1__GetYjzhZskOtherFlowChartList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetYjzhZskGzFlowResponse:
		((_ns1__GetYjzhZskGzFlowResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetYjzhZskGzFlow:
		((_ns1__GetYjzhZskGzFlow *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfBase64Binary:
		((ns1__ArrayOfBase64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__GetYjzhZskAlarmTypes_:
		soap_serialize___ns1__GetYjzhZskAlarmTypes_(soap, (const struct __ns1__GetYjzhZskAlarmTypes_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SelectYjzhDevice_:
		soap_serialize___ns1__SelectYjzhDevice_(soap, (const struct __ns1__SelectYjzhDevice_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SelectYjzhStation_:
		soap_serialize___ns1__SelectYjzhStation_(soap, (const struct __ns1__SelectYjzhStation_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SaveMapFile_:
		soap_serialize___ns1__SaveMapFile_(soap, (const struct __ns1__SaveMapFile_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GzGetDeviceStruct_:
		soap_serialize___ns1__GzGetDeviceStruct_(soap, (const struct __ns1__GzGetDeviceStruct_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GzGetTypeList_:
		soap_serialize___ns1__GzGetTypeList_(soap, (const struct __ns1__GzGetTypeList_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SGCDrawEmf_:
		soap_serialize___ns1__SGCDrawEmf_(soap, (const struct __ns1__SGCDrawEmf_ *)ptr);
		break;
	case SOAP_TYPE___ns1__FlowChartEmf_:
		soap_serialize___ns1__FlowChartEmf_(soap, (const struct __ns1__FlowChartEmf_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetZhouQi_:
		soap_serialize___ns1__GetZhouQi_(soap, (const struct __ns1__GetZhouQi_ *)ptr);
		break;
	case SOAP_TYPE___ns1__JiChaoQi_:
		soap_serialize___ns1__JiChaoQi_(soap, (const struct __ns1__JiChaoQi_ *)ptr);
		break;
	case SOAP_TYPE___ns1__ChaoQi_:
		soap_serialize___ns1__ChaoQi_(soap, (const struct __ns1__ChaoQi_ *)ptr);
		break;
	case SOAP_TYPE___ns1__OpenMapExe_:
		soap_serialize___ns1__OpenMapExe_(soap, (const struct __ns1__OpenMapExe_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetEmfPngFile_:
		soap_serialize___ns1__GetEmfPngFile_(soap, (const struct __ns1__GetEmfPngFile_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetEmfPngVer_:
		soap_serialize___ns1__GetEmfPngVer_(soap, (const struct __ns1__GetEmfPngVer_ *)ptr);
		break;
	case SOAP_TYPE___ns1__OpenProcess_:
		soap_serialize___ns1__OpenProcess_(soap, (const struct __ns1__OpenProcess_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMangeMapUpdate_:
		soap_serialize___ns1__GetMangeMapUpdate_(soap, (const struct __ns1__GetMangeMapUpdate_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetUnitMapVer_:
		soap_serialize___ns1__GetUnitMapVer_(soap, (const struct __ns1__GetUnitMapVer_ *)ptr);
		break;
	case SOAP_TYPE___ns1__UpdateGzclMap_:
		soap_serialize___ns1__UpdateGzclMap_(soap, (const struct __ns1__UpdateGzclMap_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMapListTime_:
		soap_serialize___ns1__GetMapListTime_(soap, (const struct __ns1__GetMapListTime_ *)ptr);
		break;
	case SOAP_TYPE___ns1__ServerLevel_:
		soap_serialize___ns1__ServerLevel_(soap, (const struct __ns1__ServerLevel_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetTableData_:
		soap_serialize___ns1__GetTableData_(soap, (const struct __ns1__GetTableData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMap_:
		soap_serialize___ns1__GetMap_(soap, (const struct __ns1__GetMap_ *)ptr);
		break;
	case SOAP_TYPE___ns1__CheckMapVer_:
		soap_serialize___ns1__CheckMapVer_(soap, (const struct __ns1__CheckMapVer_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMangeXb_:
		soap_serialize___ns1__GetMangeXb_(soap, (const struct __ns1__GetMangeXb_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMangeUnit_:
		soap_serialize___ns1__GetMangeUnit_(soap, (const struct __ns1__GetMangeUnit_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMaList_:
		soap_serialize___ns1__GetMaList_(soap, (const struct __ns1__GetMaList_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMapDeviceData_:
		soap_serialize___ns1__GetMapDeviceData_(soap, (const struct __ns1__GetMapDeviceData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMapTabName_:
		soap_serialize___ns1__GetMapTabName_(soap, (const struct __ns1__GetMapTabName_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMapUpdateTime_:
		soap_serialize___ns1__GetMapUpdateTime_(soap, (const struct __ns1__GetMapUpdateTime_ *)ptr);
		break;
	case SOAP_TYPE___ns1__WriteFile_:
		soap_serialize___ns1__WriteFile_(soap, (const struct __ns1__WriteFile_ *)ptr);
		break;
	case SOAP_TYPE___ns1__DownLoadFile_:
		soap_serialize___ns1__DownLoadFile_(soap, (const struct __ns1__DownLoadFile_ *)ptr);
		break;
	case SOAP_TYPE___ns1__ExecuteSqlForFile_:
		soap_serialize___ns1__ExecuteSqlForFile_(soap, (const struct __ns1__ExecuteSqlForFile_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetFieldInfo_:
		soap_serialize___ns1__GetFieldInfo_(soap, (const struct __ns1__GetFieldInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__IsOracleTable_:
		soap_serialize___ns1__IsOracleTable_(soap, (const struct __ns1__IsOracleTable_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetTabList_:
		soap_serialize___ns1__GetTabList_(soap, (const struct __ns1__GetTabList_ *)ptr);
		break;
	case SOAP_TYPE___ns1__DownCQData_:
		soap_serialize___ns1__DownCQData_(soap, (const struct __ns1__DownCQData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__AlterTable_:
		soap_serialize___ns1__AlterTable_(soap, (const struct __ns1__AlterTable_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetFileNew_:
		soap_serialize___ns1__GetFileNew_(soap, (const struct __ns1__GetFileNew_ *)ptr);
		break;
	case SOAP_TYPE___ns1__DownMapfile_:
		soap_serialize___ns1__DownMapfile_(soap, (const struct __ns1__DownMapfile_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDownFileInfo_:
		soap_serialize___ns1__GetDownFileInfo_(soap, (const struct __ns1__GetDownFileInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetGxDeviceData_:
		soap_serialize___ns1__GetGxDeviceData_(soap, (const struct __ns1__GetGxDeviceData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMapDeviceType_:
		soap_serialize___ns1__GetMapDeviceType_(soap, (const struct __ns1__GetMapDeviceType_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetXbStationList_:
		soap_serialize___ns1__GetXbStationList_(soap, (const struct __ns1__GetXbStationList_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetXbList_:
		soap_serialize___ns1__GetXbList_(soap, (const struct __ns1__GetXbList_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetFileSize_:
		soap_serialize___ns1__GetFileSize_(soap, (const struct __ns1__GetFileSize_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetUnitPersonInfo_:
		soap_serialize___ns1__GetUnitPersonInfo_(soap, (const struct __ns1__GetUnitPersonInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetUnitStruct_:
		soap_serialize___ns1__GetUnitStruct_(soap, (const struct __ns1__GetUnitStruct_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetUnitStation_:
		soap_serialize___ns1__GetUnitStation_(soap, (const struct __ns1__GetUnitStation_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDwList_:
		soap_serialize___ns1__GetDwList_(soap, (const struct __ns1__GetDwList_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetOpenFireInfo_:
		soap_serialize___ns1__GetOpenFireInfo_(soap, (const struct __ns1__GetOpenFireInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__MobDownLoadData_:
		soap_serialize___ns1__MobDownLoadData_(soap, (const struct __ns1__MobDownLoadData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__DownLoadMobGPSData_:
		soap_serialize___ns1__DownLoadMobGPSData_(soap, (const struct __ns1__DownLoadMobGPSData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDcsData_:
		soap_serialize___ns1__GetDcsData_(soap, (const struct __ns1__GetDcsData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetBgImg_:
		soap_serialize___ns1__GetBgImg_(soap, (const struct __ns1__GetBgImg_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDevPic_:
		soap_serialize___ns1__GetDevPic_(soap, (const struct __ns1__GetDevPic_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetJxPic_:
		soap_serialize___ns1__GetJxPic_(soap, (const struct __ns1__GetJxPic_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetStationJxData_:
		soap_serialize___ns1__GetStationJxData_(soap, (const struct __ns1__GetStationJxData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetJxData_:
		soap_serialize___ns1__GetJxData_(soap, (const struct __ns1__GetJxData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDeviceXj_:
		soap_serialize___ns1__GetDeviceXj_(soap, (const struct __ns1__GetDeviceXj_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDwPic_:
		soap_serialize___ns1__GetDwPic_(soap, (const struct __ns1__GetDwPic_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDwInfo_:
		soap_serialize___ns1__GetDwInfo_(soap, (const struct __ns1__GetDwInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetPicNames_:
		soap_serialize___ns1__GetPicNames_(soap, (const struct __ns1__GetPicNames_ *)ptr);
		break;
	case SOAP_TYPE___ns1__DownloadPic_:
		soap_serialize___ns1__DownloadPic_(soap, (const struct __ns1__DownloadPic_ *)ptr);
		break;
	case SOAP_TYPE___ns1__upPic_:
		soap_serialize___ns1__upPic_(soap, (const struct __ns1__upPic_ *)ptr);
		break;
	case SOAP_TYPE___ns1__UpLoadFile_:
		soap_serialize___ns1__UpLoadFile_(soap, (const struct __ns1__UpLoadFile_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAPVupdater_:
		soap_serialize___ns1__GetAPVupdater_(soap, (const struct __ns1__GetAPVupdater_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetXHYDGLXTupdater_:
		soap_serialize___ns1__GetXHYDGLXTupdater_(soap, (const struct __ns1__GetXHYDGLXTupdater_ *)ptr);
		break;
	case SOAP_TYPE___ns1__ExecuteSqlForColb_:
		soap_serialize___ns1__ExecuteSqlForColb_(soap, (const struct __ns1__ExecuteSqlForColb_ *)ptr);
		break;
	case SOAP_TYPE___ns1__UpLoadData_:
		soap_serialize___ns1__UpLoadData_(soap, (const struct __ns1__UpLoadData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__TcdSendup_:
		soap_serialize___ns1__TcdSendup_(soap, (const struct __ns1__TcdSendup_ *)ptr);
		break;
	case SOAP_TYPE___ns1__TcdQuery_:
		soap_serialize___ns1__TcdQuery_(soap, (const struct __ns1__TcdQuery_ *)ptr);
		break;
	case SOAP_TYPE___ns1__QueryPhotobw_:
		soap_serialize___ns1__QueryPhotobw_(soap, (const struct __ns1__QueryPhotobw_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetOsDateTime_:
		soap_serialize___ns1__GetOsDateTime_(soap, (const struct __ns1__GetOsDateTime_ *)ptr);
		break;
	case SOAP_TYPE___ns1__signedUserInfo_:
		soap_serialize___ns1__signedUserInfo_(soap, (const struct __ns1__signedUserInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetGxdataUpTime_:
		soap_serialize___ns1__GetGxdataUpTime_(soap, (const struct __ns1__GetGxdataUpTime_ *)ptr);
		break;
	case SOAP_TYPE___ns1__DownAllPic_:
		soap_serialize___ns1__DownAllPic_(soap, (const struct __ns1__DownAllPic_ *)ptr);
		break;
	case SOAP_TYPE___ns1__DownPic_:
		soap_serialize___ns1__DownPic_(soap, (const struct __ns1__DownPic_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SaveFileData_:
		soap_serialize___ns1__SaveFileData_(soap, (const struct __ns1__SaveFileData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SaveData_:
		soap_serialize___ns1__SaveData_(soap, (const struct __ns1__SaveData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__ExecuteSql_:
		soap_serialize___ns1__ExecuteSql_(soap, (const struct __ns1__ExecuteSql_ *)ptr);
		break;
	case SOAP_TYPE___ns1__QueryDataCount_:
		soap_serialize___ns1__QueryDataCount_(soap, (const struct __ns1__QueryDataCount_ *)ptr);
		break;
	case SOAP_TYPE___ns1__QueryData_:
		soap_serialize___ns1__QueryData_(soap, (const struct __ns1__QueryData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDBString_:
		soap_serialize___ns1__GetDBString_(soap, (const struct __ns1__GetDBString_ *)ptr);
		break;
	case SOAP_TYPE___ns1__HelloWorld_:
		soap_serialize___ns1__HelloWorld_(soap, (const struct __ns1__HelloWorld_ *)ptr);
		break;
	case SOAP_TYPE___ns1__CheckDevCode_:
		soap_serialize___ns1__CheckDevCode_(soap, (const struct __ns1__CheckDevCode_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDevCode_:
		soap_serialize___ns1__GetDevCode_(soap, (const struct __ns1__GetDevCode_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetRyUnit_:
		soap_serialize___ns1__GetRyUnit_(soap, (const struct __ns1__GetRyUnit_ *)ptr);
		break;
	case SOAP_TYPE___ns1__CheckLoginUser_:
		soap_serialize___ns1__CheckLoginUser_(soap, (const struct __ns1__CheckLoginUser_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetPropName_:
		soap_serialize___ns1__GetPropName_(soap, (const struct __ns1__GetPropName_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetPropList_:
		soap_serialize___ns1__GetPropList_(soap, (const struct __ns1__GetPropList_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetYjzhZskDevFlowChartList_:
		soap_serialize___ns1__GetYjzhZskDevFlowChartList_(soap, (const struct __ns1__GetYjzhZskDevFlowChartList_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetYjzhZskOtherFlowChartList_:
		soap_serialize___ns1__GetYjzhZskOtherFlowChartList_(soap, (const struct __ns1__GetYjzhZskOtherFlowChartList_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetYjzhZskGzFlow_:
		soap_serialize___ns1__GetYjzhZskGzFlow_(soap, (const struct __ns1__GetYjzhZskGzFlow_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetYjzhZskAlarmTypes:
		soap_serialize___ns1__GetYjzhZskAlarmTypes(soap, (const struct __ns1__GetYjzhZskAlarmTypes *)ptr);
		break;
	case SOAP_TYPE___ns1__SelectYjzhDevice:
		soap_serialize___ns1__SelectYjzhDevice(soap, (const struct __ns1__SelectYjzhDevice *)ptr);
		break;
	case SOAP_TYPE___ns1__SelectYjzhStation:
		soap_serialize___ns1__SelectYjzhStation(soap, (const struct __ns1__SelectYjzhStation *)ptr);
		break;
	case SOAP_TYPE___ns1__SaveMapFile:
		soap_serialize___ns1__SaveMapFile(soap, (const struct __ns1__SaveMapFile *)ptr);
		break;
	case SOAP_TYPE___ns1__GzGetDeviceStruct:
		soap_serialize___ns1__GzGetDeviceStruct(soap, (const struct __ns1__GzGetDeviceStruct *)ptr);
		break;
	case SOAP_TYPE___ns1__GzGetTypeList:
		soap_serialize___ns1__GzGetTypeList(soap, (const struct __ns1__GzGetTypeList *)ptr);
		break;
	case SOAP_TYPE___ns1__SGCDrawEmf:
		soap_serialize___ns1__SGCDrawEmf(soap, (const struct __ns1__SGCDrawEmf *)ptr);
		break;
	case SOAP_TYPE___ns1__FlowChartEmf:
		soap_serialize___ns1__FlowChartEmf(soap, (const struct __ns1__FlowChartEmf *)ptr);
		break;
	case SOAP_TYPE___ns1__GetZhouQi:
		soap_serialize___ns1__GetZhouQi(soap, (const struct __ns1__GetZhouQi *)ptr);
		break;
	case SOAP_TYPE___ns1__JiChaoQi:
		soap_serialize___ns1__JiChaoQi(soap, (const struct __ns1__JiChaoQi *)ptr);
		break;
	case SOAP_TYPE___ns1__ChaoQi:
		soap_serialize___ns1__ChaoQi(soap, (const struct __ns1__ChaoQi *)ptr);
		break;
	case SOAP_TYPE___ns1__OpenMapExe:
		soap_serialize___ns1__OpenMapExe(soap, (const struct __ns1__OpenMapExe *)ptr);
		break;
	case SOAP_TYPE___ns1__GetEmfPngFile:
		soap_serialize___ns1__GetEmfPngFile(soap, (const struct __ns1__GetEmfPngFile *)ptr);
		break;
	case SOAP_TYPE___ns1__GetEmfPngVer:
		soap_serialize___ns1__GetEmfPngVer(soap, (const struct __ns1__GetEmfPngVer *)ptr);
		break;
	case SOAP_TYPE___ns1__OpenProcess:
		soap_serialize___ns1__OpenProcess(soap, (const struct __ns1__OpenProcess *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMangeMapUpdate:
		soap_serialize___ns1__GetMangeMapUpdate(soap, (const struct __ns1__GetMangeMapUpdate *)ptr);
		break;
	case SOAP_TYPE___ns1__GetUnitMapVer:
		soap_serialize___ns1__GetUnitMapVer(soap, (const struct __ns1__GetUnitMapVer *)ptr);
		break;
	case SOAP_TYPE___ns1__UpdateGzclMap:
		soap_serialize___ns1__UpdateGzclMap(soap, (const struct __ns1__UpdateGzclMap *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMapListTime:
		soap_serialize___ns1__GetMapListTime(soap, (const struct __ns1__GetMapListTime *)ptr);
		break;
	case SOAP_TYPE___ns1__ServerLevel:
		soap_serialize___ns1__ServerLevel(soap, (const struct __ns1__ServerLevel *)ptr);
		break;
	case SOAP_TYPE___ns1__GetTableData:
		soap_serialize___ns1__GetTableData(soap, (const struct __ns1__GetTableData *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMap:
		soap_serialize___ns1__GetMap(soap, (const struct __ns1__GetMap *)ptr);
		break;
	case SOAP_TYPE___ns1__CheckMapVer:
		soap_serialize___ns1__CheckMapVer(soap, (const struct __ns1__CheckMapVer *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMangeXb:
		soap_serialize___ns1__GetMangeXb(soap, (const struct __ns1__GetMangeXb *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMangeUnit:
		soap_serialize___ns1__GetMangeUnit(soap, (const struct __ns1__GetMangeUnit *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMaList:
		soap_serialize___ns1__GetMaList(soap, (const struct __ns1__GetMaList *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMapDeviceData:
		soap_serialize___ns1__GetMapDeviceData(soap, (const struct __ns1__GetMapDeviceData *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMapTabName:
		soap_serialize___ns1__GetMapTabName(soap, (const struct __ns1__GetMapTabName *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMapUpdateTime:
		soap_serialize___ns1__GetMapUpdateTime(soap, (const struct __ns1__GetMapUpdateTime *)ptr);
		break;
	case SOAP_TYPE___ns1__WriteFile:
		soap_serialize___ns1__WriteFile(soap, (const struct __ns1__WriteFile *)ptr);
		break;
	case SOAP_TYPE___ns1__DownLoadFile:
		soap_serialize___ns1__DownLoadFile(soap, (const struct __ns1__DownLoadFile *)ptr);
		break;
	case SOAP_TYPE___ns1__ExecuteSqlForFile:
		soap_serialize___ns1__ExecuteSqlForFile(soap, (const struct __ns1__ExecuteSqlForFile *)ptr);
		break;
	case SOAP_TYPE___ns1__GetFieldInfo:
		soap_serialize___ns1__GetFieldInfo(soap, (const struct __ns1__GetFieldInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__IsOracleTable:
		soap_serialize___ns1__IsOracleTable(soap, (const struct __ns1__IsOracleTable *)ptr);
		break;
	case SOAP_TYPE___ns1__GetTabList:
		soap_serialize___ns1__GetTabList(soap, (const struct __ns1__GetTabList *)ptr);
		break;
	case SOAP_TYPE___ns1__DownCQData:
		soap_serialize___ns1__DownCQData(soap, (const struct __ns1__DownCQData *)ptr);
		break;
	case SOAP_TYPE___ns1__AlterTable:
		soap_serialize___ns1__AlterTable(soap, (const struct __ns1__AlterTable *)ptr);
		break;
	case SOAP_TYPE___ns1__GetFileNew:
		soap_serialize___ns1__GetFileNew(soap, (const struct __ns1__GetFileNew *)ptr);
		break;
	case SOAP_TYPE___ns1__DownMapfile:
		soap_serialize___ns1__DownMapfile(soap, (const struct __ns1__DownMapfile *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDownFileInfo:
		soap_serialize___ns1__GetDownFileInfo(soap, (const struct __ns1__GetDownFileInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GetGxDeviceData:
		soap_serialize___ns1__GetGxDeviceData(soap, (const struct __ns1__GetGxDeviceData *)ptr);
		break;
	case SOAP_TYPE___ns1__GetMapDeviceType:
		soap_serialize___ns1__GetMapDeviceType(soap, (const struct __ns1__GetMapDeviceType *)ptr);
		break;
	case SOAP_TYPE___ns1__GetXbStationList:
		soap_serialize___ns1__GetXbStationList(soap, (const struct __ns1__GetXbStationList *)ptr);
		break;
	case SOAP_TYPE___ns1__GetXbList:
		soap_serialize___ns1__GetXbList(soap, (const struct __ns1__GetXbList *)ptr);
		break;
	case SOAP_TYPE___ns1__GetFileSize:
		soap_serialize___ns1__GetFileSize(soap, (const struct __ns1__GetFileSize *)ptr);
		break;
	case SOAP_TYPE___ns1__GetUnitPersonInfo:
		soap_serialize___ns1__GetUnitPersonInfo(soap, (const struct __ns1__GetUnitPersonInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GetUnitStruct:
		soap_serialize___ns1__GetUnitStruct(soap, (const struct __ns1__GetUnitStruct *)ptr);
		break;
	case SOAP_TYPE___ns1__GetUnitStation:
		soap_serialize___ns1__GetUnitStation(soap, (const struct __ns1__GetUnitStation *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDwList:
		soap_serialize___ns1__GetDwList(soap, (const struct __ns1__GetDwList *)ptr);
		break;
	case SOAP_TYPE___ns1__GetOpenFireInfo:
		soap_serialize___ns1__GetOpenFireInfo(soap, (const struct __ns1__GetOpenFireInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__MobDownLoadData:
		soap_serialize___ns1__MobDownLoadData(soap, (const struct __ns1__MobDownLoadData *)ptr);
		break;
	case SOAP_TYPE___ns1__DownLoadMobGPSData:
		soap_serialize___ns1__DownLoadMobGPSData(soap, (const struct __ns1__DownLoadMobGPSData *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDcsData:
		soap_serialize___ns1__GetDcsData(soap, (const struct __ns1__GetDcsData *)ptr);
		break;
	case SOAP_TYPE___ns1__GetBgImg:
		soap_serialize___ns1__GetBgImg(soap, (const struct __ns1__GetBgImg *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDevPic:
		soap_serialize___ns1__GetDevPic(soap, (const struct __ns1__GetDevPic *)ptr);
		break;
	case SOAP_TYPE___ns1__GetJxPic:
		soap_serialize___ns1__GetJxPic(soap, (const struct __ns1__GetJxPic *)ptr);
		break;
	case SOAP_TYPE___ns1__GetStationJxData:
		soap_serialize___ns1__GetStationJxData(soap, (const struct __ns1__GetStationJxData *)ptr);
		break;
	case SOAP_TYPE___ns1__GetJxData:
		soap_serialize___ns1__GetJxData(soap, (const struct __ns1__GetJxData *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDeviceXj:
		soap_serialize___ns1__GetDeviceXj(soap, (const struct __ns1__GetDeviceXj *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDwPic:
		soap_serialize___ns1__GetDwPic(soap, (const struct __ns1__GetDwPic *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDwInfo:
		soap_serialize___ns1__GetDwInfo(soap, (const struct __ns1__GetDwInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GetPicNames:
		soap_serialize___ns1__GetPicNames(soap, (const struct __ns1__GetPicNames *)ptr);
		break;
	case SOAP_TYPE___ns1__DownloadPic:
		soap_serialize___ns1__DownloadPic(soap, (const struct __ns1__DownloadPic *)ptr);
		break;
	case SOAP_TYPE___ns1__upPic:
		soap_serialize___ns1__upPic(soap, (const struct __ns1__upPic *)ptr);
		break;
	case SOAP_TYPE___ns1__UpLoadFile:
		soap_serialize___ns1__UpLoadFile(soap, (const struct __ns1__UpLoadFile *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAPVupdater:
		soap_serialize___ns1__GetAPVupdater(soap, (const struct __ns1__GetAPVupdater *)ptr);
		break;
	case SOAP_TYPE___ns1__GetXHYDGLXTupdater:
		soap_serialize___ns1__GetXHYDGLXTupdater(soap, (const struct __ns1__GetXHYDGLXTupdater *)ptr);
		break;
	case SOAP_TYPE___ns1__ExecuteSqlForColb:
		soap_serialize___ns1__ExecuteSqlForColb(soap, (const struct __ns1__ExecuteSqlForColb *)ptr);
		break;
	case SOAP_TYPE___ns1__UpLoadData:
		soap_serialize___ns1__UpLoadData(soap, (const struct __ns1__UpLoadData *)ptr);
		break;
	case SOAP_TYPE___ns1__TcdSendup:
		soap_serialize___ns1__TcdSendup(soap, (const struct __ns1__TcdSendup *)ptr);
		break;
	case SOAP_TYPE___ns1__TcdQuery:
		soap_serialize___ns1__TcdQuery(soap, (const struct __ns1__TcdQuery *)ptr);
		break;
	case SOAP_TYPE___ns1__QueryPhotobw:
		soap_serialize___ns1__QueryPhotobw(soap, (const struct __ns1__QueryPhotobw *)ptr);
		break;
	case SOAP_TYPE___ns1__GetOsDateTime:
		soap_serialize___ns1__GetOsDateTime(soap, (const struct __ns1__GetOsDateTime *)ptr);
		break;
	case SOAP_TYPE___ns1__signedUserInfo:
		soap_serialize___ns1__signedUserInfo(soap, (const struct __ns1__signedUserInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GetGxdataUpTime:
		soap_serialize___ns1__GetGxdataUpTime(soap, (const struct __ns1__GetGxdataUpTime *)ptr);
		break;
	case SOAP_TYPE___ns1__DownAllPic:
		soap_serialize___ns1__DownAllPic(soap, (const struct __ns1__DownAllPic *)ptr);
		break;
	case SOAP_TYPE___ns1__DownPic:
		soap_serialize___ns1__DownPic(soap, (const struct __ns1__DownPic *)ptr);
		break;
	case SOAP_TYPE___ns1__SaveFileData:
		soap_serialize___ns1__SaveFileData(soap, (const struct __ns1__SaveFileData *)ptr);
		break;
	case SOAP_TYPE___ns1__SaveData:
		soap_serialize___ns1__SaveData(soap, (const struct __ns1__SaveData *)ptr);
		break;
	case SOAP_TYPE___ns1__ExecuteSql:
		soap_serialize___ns1__ExecuteSql(soap, (const struct __ns1__ExecuteSql *)ptr);
		break;
	case SOAP_TYPE___ns1__QueryDataCount:
		soap_serialize___ns1__QueryDataCount(soap, (const struct __ns1__QueryDataCount *)ptr);
		break;
	case SOAP_TYPE___ns1__QueryData:
		soap_serialize___ns1__QueryData(soap, (const struct __ns1__QueryData *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDBString:
		soap_serialize___ns1__GetDBString(soap, (const struct __ns1__GetDBString *)ptr);
		break;
	case SOAP_TYPE___ns1__HelloWorld:
		soap_serialize___ns1__HelloWorld(soap, (const struct __ns1__HelloWorld *)ptr);
		break;
	case SOAP_TYPE___ns1__CheckDevCode:
		soap_serialize___ns1__CheckDevCode(soap, (const struct __ns1__CheckDevCode *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDevCode:
		soap_serialize___ns1__GetDevCode(soap, (const struct __ns1__GetDevCode *)ptr);
		break;
	case SOAP_TYPE___ns1__GetRyUnit:
		soap_serialize___ns1__GetRyUnit(soap, (const struct __ns1__GetRyUnit *)ptr);
		break;
	case SOAP_TYPE___ns1__CheckLoginUser:
		soap_serialize___ns1__CheckLoginUser(soap, (const struct __ns1__CheckLoginUser *)ptr);
		break;
	case SOAP_TYPE___ns1__GetPropName:
		soap_serialize___ns1__GetPropName(soap, (const struct __ns1__GetPropName *)ptr);
		break;
	case SOAP_TYPE___ns1__GetPropList:
		soap_serialize___ns1__GetPropList(soap, (const struct __ns1__GetPropList *)ptr);
		break;
	case SOAP_TYPE___ns1__GetYjzhZskDevFlowChartList:
		soap_serialize___ns1__GetYjzhZskDevFlowChartList(soap, (const struct __ns1__GetYjzhZskDevFlowChartList *)ptr);
		break;
	case SOAP_TYPE___ns1__GetYjzhZskOtherFlowChartList:
		soap_serialize___ns1__GetYjzhZskOtherFlowChartList(soap, (const struct __ns1__GetYjzhZskOtherFlowChartList *)ptr);
		break;
	case SOAP_TYPE___ns1__GetYjzhZskGzFlow:
		soap_serialize___ns1__GetYjzhZskGzFlow(soap, (const struct __ns1__GetYjzhZskGzFlow *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetYjzhZskAlarmTypes:
		soap_serialize_PointerTo_ns1__GetYjzhZskAlarmTypes(soap, (_ns1__GetYjzhZskAlarmTypes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SelectYjzhDevice:
		soap_serialize_PointerTo_ns1__SelectYjzhDevice(soap, (_ns1__SelectYjzhDevice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SelectYjzhStation:
		soap_serialize_PointerTo_ns1__SelectYjzhStation(soap, (_ns1__SelectYjzhStation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SaveMapFile:
		soap_serialize_PointerTo_ns1__SaveMapFile(soap, (_ns1__SaveMapFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GzGetDeviceStruct:
		soap_serialize_PointerTo_ns1__GzGetDeviceStruct(soap, (_ns1__GzGetDeviceStruct *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GzGetTypeList:
		soap_serialize_PointerTo_ns1__GzGetTypeList(soap, (_ns1__GzGetTypeList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SGCDrawEmf:
		soap_serialize_PointerTo_ns1__SGCDrawEmf(soap, (_ns1__SGCDrawEmf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__FlowChartEmf:
		soap_serialize_PointerTo_ns1__FlowChartEmf(soap, (_ns1__FlowChartEmf *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetZhouQi:
		soap_serialize_PointerTo_ns1__GetZhouQi(soap, (_ns1__GetZhouQi *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__JiChaoQi:
		soap_serialize_PointerTo_ns1__JiChaoQi(soap, (_ns1__JiChaoQi *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ChaoQi:
		soap_serialize_PointerTo_ns1__ChaoQi(soap, (_ns1__ChaoQi *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__OpenMapExe:
		soap_serialize_PointerTo_ns1__OpenMapExe(soap, (_ns1__OpenMapExe *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetEmfPngFile:
		soap_serialize_PointerTo_ns1__GetEmfPngFile(soap, (_ns1__GetEmfPngFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetEmfPngVer:
		soap_serialize_PointerTo_ns1__GetEmfPngVer(soap, (_ns1__GetEmfPngVer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__OpenProcess:
		soap_serialize_PointerTo_ns1__OpenProcess(soap, (_ns1__OpenProcess *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetMangeMapUpdate:
		soap_serialize_PointerTo_ns1__GetMangeMapUpdate(soap, (_ns1__GetMangeMapUpdate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetUnitMapVer:
		soap_serialize_PointerTo_ns1__GetUnitMapVer(soap, (_ns1__GetUnitMapVer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdateGzclMap:
		soap_serialize_PointerTo_ns1__UpdateGzclMap(soap, (_ns1__UpdateGzclMap *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetMapListTime:
		soap_serialize_PointerTo_ns1__GetMapListTime(soap, (_ns1__GetMapListTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ServerLevel:
		soap_serialize_PointerTo_ns1__ServerLevel(soap, (_ns1__ServerLevel *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetTableData:
		soap_serialize_PointerTo_ns1__GetTableData(soap, (_ns1__GetTableData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetMap:
		soap_serialize_PointerTo_ns1__GetMap(soap, (_ns1__GetMap *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CheckMapVer:
		soap_serialize_PointerTo_ns1__CheckMapVer(soap, (_ns1__CheckMapVer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetMangeXb:
		soap_serialize_PointerTo_ns1__GetMangeXb(soap, (_ns1__GetMangeXb *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetMangeUnit:
		soap_serialize_PointerTo_ns1__GetMangeUnit(soap, (_ns1__GetMangeUnit *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetMaList:
		soap_serialize_PointerTo_ns1__GetMaList(soap, (_ns1__GetMaList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetMapDeviceData:
		soap_serialize_PointerTo_ns1__GetMapDeviceData(soap, (_ns1__GetMapDeviceData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetMapTabName:
		soap_serialize_PointerTo_ns1__GetMapTabName(soap, (_ns1__GetMapTabName *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetMapUpdateTime:
		soap_serialize_PointerTo_ns1__GetMapUpdateTime(soap, (_ns1__GetMapUpdateTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__WriteFile:
		soap_serialize_PointerTo_ns1__WriteFile(soap, (_ns1__WriteFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DownLoadFile:
		soap_serialize_PointerTo_ns1__DownLoadFile(soap, (_ns1__DownLoadFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ExecuteSqlForFile:
		soap_serialize_PointerTo_ns1__ExecuteSqlForFile(soap, (_ns1__ExecuteSqlForFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetFieldInfo:
		soap_serialize_PointerTo_ns1__GetFieldInfo(soap, (_ns1__GetFieldInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__IsOracleTable:
		soap_serialize_PointerTo_ns1__IsOracleTable(soap, (_ns1__IsOracleTable *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetTabList:
		soap_serialize_PointerTo_ns1__GetTabList(soap, (_ns1__GetTabList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DownCQData:
		soap_serialize_PointerTo_ns1__DownCQData(soap, (_ns1__DownCQData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AlterTable:
		soap_serialize_PointerTo_ns1__AlterTable(soap, (_ns1__AlterTable *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetFileNew:
		soap_serialize_PointerTo_ns1__GetFileNew(soap, (_ns1__GetFileNew *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DownMapfile:
		soap_serialize_PointerTo_ns1__DownMapfile(soap, (_ns1__DownMapfile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetDownFileInfo:
		soap_serialize_PointerTo_ns1__GetDownFileInfo(soap, (_ns1__GetDownFileInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetGxDeviceData:
		soap_serialize_PointerTo_ns1__GetGxDeviceData(soap, (_ns1__GetGxDeviceData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetMapDeviceType:
		soap_serialize_PointerTo_ns1__GetMapDeviceType(soap, (_ns1__GetMapDeviceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetXbStationList:
		soap_serialize_PointerTo_ns1__GetXbStationList(soap, (_ns1__GetXbStationList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetXbList:
		soap_serialize_PointerTo_ns1__GetXbList(soap, (_ns1__GetXbList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetFileSize:
		soap_serialize_PointerTo_ns1__GetFileSize(soap, (_ns1__GetFileSize *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetUnitPersonInfo:
		soap_serialize_PointerTo_ns1__GetUnitPersonInfo(soap, (_ns1__GetUnitPersonInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetUnitStruct:
		soap_serialize_PointerTo_ns1__GetUnitStruct(soap, (_ns1__GetUnitStruct *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetUnitStation:
		soap_serialize_PointerTo_ns1__GetUnitStation(soap, (_ns1__GetUnitStation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetDwList:
		soap_serialize_PointerTo_ns1__GetDwList(soap, (_ns1__GetDwList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetOpenFireInfo:
		soap_serialize_PointerTo_ns1__GetOpenFireInfo(soap, (_ns1__GetOpenFireInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__MobDownLoadData:
		soap_serialize_PointerTo_ns1__MobDownLoadData(soap, (_ns1__MobDownLoadData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DownLoadMobGPSData:
		soap_serialize_PointerTo_ns1__DownLoadMobGPSData(soap, (_ns1__DownLoadMobGPSData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetDcsData:
		soap_serialize_PointerTo_ns1__GetDcsData(soap, (_ns1__GetDcsData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetBgImg:
		soap_serialize_PointerTo_ns1__GetBgImg(soap, (_ns1__GetBgImg *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetDevPic:
		soap_serialize_PointerTo_ns1__GetDevPic(soap, (_ns1__GetDevPic *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetJxPic:
		soap_serialize_PointerTo_ns1__GetJxPic(soap, (_ns1__GetJxPic *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetStationJxData:
		soap_serialize_PointerTo_ns1__GetStationJxData(soap, (_ns1__GetStationJxData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetJxData:
		soap_serialize_PointerTo_ns1__GetJxData(soap, (_ns1__GetJxData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetDeviceXj:
		soap_serialize_PointerTo_ns1__GetDeviceXj(soap, (_ns1__GetDeviceXj *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetDwPic:
		soap_serialize_PointerTo_ns1__GetDwPic(soap, (_ns1__GetDwPic *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetDwInfo:
		soap_serialize_PointerTo_ns1__GetDwInfo(soap, (_ns1__GetDwInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPicNames:
		soap_serialize_PointerTo_ns1__GetPicNames(soap, (_ns1__GetPicNames *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DownloadPic:
		soap_serialize_PointerTo_ns1__DownloadPic(soap, (_ns1__DownloadPic *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__upPic:
		soap_serialize_PointerTo_ns1__upPic(soap, (_ns1__upPic *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpLoadFile:
		soap_serialize_PointerTo_ns1__UpLoadFile(soap, (_ns1__UpLoadFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAPVupdater:
		soap_serialize_PointerTo_ns1__GetAPVupdater(soap, (_ns1__GetAPVupdater *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetXHYDGLXTupdater:
		soap_serialize_PointerTo_ns1__GetXHYDGLXTupdater(soap, (_ns1__GetXHYDGLXTupdater *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ExecuteSqlForColb:
		soap_serialize_PointerTo_ns1__ExecuteSqlForColb(soap, (_ns1__ExecuteSqlForColb *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpLoadData:
		soap_serialize_PointerTo_ns1__UpLoadData(soap, (_ns1__UpLoadData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__TcdSendup:
		soap_serialize_PointerTo_ns1__TcdSendup(soap, (_ns1__TcdSendup *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__TcdQuery:
		soap_serialize_PointerTo_ns1__TcdQuery(soap, (_ns1__TcdQuery *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__QueryPhotobw:
		soap_serialize_PointerTo_ns1__QueryPhotobw(soap, (_ns1__QueryPhotobw *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetOsDateTime:
		soap_serialize_PointerTo_ns1__GetOsDateTime(soap, (_ns1__GetOsDateTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__signedUserInfo:
		soap_serialize_PointerTo_ns1__signedUserInfo(soap, (_ns1__signedUserInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetGxdataUpTime:
		soap_serialize_PointerTo_ns1__GetGxdataUpTime(soap, (_ns1__GetGxdataUpTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DownAllPic:
		soap_serialize_PointerTo_ns1__DownAllPic(soap, (_ns1__DownAllPic *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DownPic:
		soap_serialize_PointerTo_ns1__DownPic(soap, (_ns1__DownPic *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SaveFileData:
		soap_serialize_PointerTo_ns1__SaveFileData(soap, (_ns1__SaveFileData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SaveData:
		soap_serialize_PointerTo_ns1__SaveData(soap, (_ns1__SaveData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ExecuteSql:
		soap_serialize_PointerTo_ns1__ExecuteSql(soap, (_ns1__ExecuteSql *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__QueryDataCount:
		soap_serialize_PointerTo_ns1__QueryDataCount(soap, (_ns1__QueryDataCount *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__QueryData:
		soap_serialize_PointerTo_ns1__QueryData(soap, (_ns1__QueryData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetDBString:
		soap_serialize_PointerTo_ns1__GetDBString(soap, (_ns1__GetDBString *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__HelloWorld:
		soap_serialize_PointerTo_ns1__HelloWorld(soap, (_ns1__HelloWorld *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CheckDevCode:
		soap_serialize_PointerTo_ns1__CheckDevCode(soap, (_ns1__CheckDevCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetDevCode:
		soap_serialize_PointerTo_ns1__GetDevCode(soap, (_ns1__GetDevCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetRyUnit:
		soap_serialize_PointerTo_ns1__GetRyUnit(soap, (_ns1__GetRyUnit *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CheckLoginUser:
		soap_serialize_PointerTo_ns1__CheckLoginUser(soap, (_ns1__CheckLoginUser *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPropName:
		soap_serialize_PointerTo_ns1__GetPropName(soap, (_ns1__GetPropName *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPropList:
		soap_serialize_PointerTo_ns1__GetPropList(soap, (_ns1__GetPropList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetYjzhZskDevFlowChartList:
		soap_serialize_PointerTo_ns1__GetYjzhZskDevFlowChartList(soap, (_ns1__GetYjzhZskDevFlowChartList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetYjzhZskOtherFlowChartList:
		soap_serialize_PointerTo_ns1__GetYjzhZskOtherFlowChartList(soap, (_ns1__GetYjzhZskOtherFlowChartList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetYjzhZskGzFlow:
		soap_serialize_PointerTo_ns1__GetYjzhZskGzFlow(soap, (_ns1__GetYjzhZskGzFlow *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfBase64Binary:
		soap_serialize_PointerTons1__ArrayOfBase64Binary(soap, (ns1__ArrayOfBase64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__base64Binary:
		soap_serialize_PointerToxsd__base64Binary(soap, (xsd__base64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfBase64Binary:
		return (void*)soap_instantiate_ns1__ArrayOfBase64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetYjzhZskGzFlow:
		return (void*)soap_instantiate__ns1__GetYjzhZskGzFlow(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetYjzhZskGzFlowResponse:
		return (void*)soap_instantiate__ns1__GetYjzhZskGzFlowResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartList:
		return (void*)soap_instantiate__ns1__GetYjzhZskOtherFlowChartList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartListResponse:
		return (void*)soap_instantiate__ns1__GetYjzhZskOtherFlowChartListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetYjzhZskDevFlowChartList:
		return (void*)soap_instantiate__ns1__GetYjzhZskDevFlowChartList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetYjzhZskDevFlowChartListResponse:
		return (void*)soap_instantiate__ns1__GetYjzhZskDevFlowChartListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPropList:
		return (void*)soap_instantiate__ns1__GetPropList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPropListResponse:
		return (void*)soap_instantiate__ns1__GetPropListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPropName:
		return (void*)soap_instantiate__ns1__GetPropName(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPropNameResponse:
		return (void*)soap_instantiate__ns1__GetPropNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CheckLoginUser:
		return (void*)soap_instantiate__ns1__CheckLoginUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CheckLoginUserResponse:
		return (void*)soap_instantiate__ns1__CheckLoginUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetRyUnit:
		return (void*)soap_instantiate__ns1__GetRyUnit(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetRyUnitResponse:
		return (void*)soap_instantiate__ns1__GetRyUnitResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDevCode:
		return (void*)soap_instantiate__ns1__GetDevCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDevCodeResponse:
		return (void*)soap_instantiate__ns1__GetDevCodeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CheckDevCode:
		return (void*)soap_instantiate__ns1__CheckDevCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CheckDevCodeResponse:
		return (void*)soap_instantiate__ns1__CheckDevCodeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__HelloWorld:
		return (void*)soap_instantiate__ns1__HelloWorld(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__HelloWorldResponse:
		return (void*)soap_instantiate__ns1__HelloWorldResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDBString:
		return (void*)soap_instantiate__ns1__GetDBString(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDBStringResponse:
		return (void*)soap_instantiate__ns1__GetDBStringResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__QueryData:
		return (void*)soap_instantiate__ns1__QueryData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__QueryDataResponse:
		return (void*)soap_instantiate__ns1__QueryDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__QueryDataCount:
		return (void*)soap_instantiate__ns1__QueryDataCount(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__QueryDataCountResponse:
		return (void*)soap_instantiate__ns1__QueryDataCountResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ExecuteSql:
		return (void*)soap_instantiate__ns1__ExecuteSql(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ExecuteSqlResponse:
		return (void*)soap_instantiate__ns1__ExecuteSqlResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SaveData:
		return (void*)soap_instantiate__ns1__SaveData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SaveDataResponse:
		return (void*)soap_instantiate__ns1__SaveDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SaveFileData:
		return (void*)soap_instantiate__ns1__SaveFileData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SaveFileDataResponse:
		return (void*)soap_instantiate__ns1__SaveFileDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DownPic:
		return (void*)soap_instantiate__ns1__DownPic(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DownPicResponse:
		return (void*)soap_instantiate__ns1__DownPicResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DownAllPic:
		return (void*)soap_instantiate__ns1__DownAllPic(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DownAllPicResponse:
		return (void*)soap_instantiate__ns1__DownAllPicResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetGxdataUpTime:
		return (void*)soap_instantiate__ns1__GetGxdataUpTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetGxdataUpTimeResponse:
		return (void*)soap_instantiate__ns1__GetGxdataUpTimeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__signedUserInfo:
		return (void*)soap_instantiate__ns1__signedUserInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__signedUserInfoResponse:
		return (void*)soap_instantiate__ns1__signedUserInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetOsDateTime:
		return (void*)soap_instantiate__ns1__GetOsDateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetOsDateTimeResponse:
		return (void*)soap_instantiate__ns1__GetOsDateTimeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__QueryPhotobw:
		return (void*)soap_instantiate__ns1__QueryPhotobw(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__QueryPhotobwResponse:
		return (void*)soap_instantiate__ns1__QueryPhotobwResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__TcdQuery:
		return (void*)soap_instantiate__ns1__TcdQuery(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__TcdQueryResponse:
		return (void*)soap_instantiate__ns1__TcdQueryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__TcdSendup:
		return (void*)soap_instantiate__ns1__TcdSendup(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__TcdSendupResponse:
		return (void*)soap_instantiate__ns1__TcdSendupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpLoadData:
		return (void*)soap_instantiate__ns1__UpLoadData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpLoadDataResponse:
		return (void*)soap_instantiate__ns1__UpLoadDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ExecuteSqlForColb:
		return (void*)soap_instantiate__ns1__ExecuteSqlForColb(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ExecuteSqlForColbResponse:
		return (void*)soap_instantiate__ns1__ExecuteSqlForColbResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetXHYDGLXTupdater:
		return (void*)soap_instantiate__ns1__GetXHYDGLXTupdater(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetXHYDGLXTupdaterResponse:
		return (void*)soap_instantiate__ns1__GetXHYDGLXTupdaterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAPVupdater:
		return (void*)soap_instantiate__ns1__GetAPVupdater(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAPVupdaterResponse:
		return (void*)soap_instantiate__ns1__GetAPVupdaterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpLoadFile:
		return (void*)soap_instantiate__ns1__UpLoadFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpLoadFileResponse:
		return (void*)soap_instantiate__ns1__UpLoadFileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__upPic:
		return (void*)soap_instantiate__ns1__upPic(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__upPicResponse:
		return (void*)soap_instantiate__ns1__upPicResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DownloadPic:
		return (void*)soap_instantiate__ns1__DownloadPic(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DownloadPicResponse:
		return (void*)soap_instantiate__ns1__DownloadPicResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPicNames:
		return (void*)soap_instantiate__ns1__GetPicNames(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPicNamesResponse:
		return (void*)soap_instantiate__ns1__GetPicNamesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDwInfo:
		return (void*)soap_instantiate__ns1__GetDwInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDwInfoResponse:
		return (void*)soap_instantiate__ns1__GetDwInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDwPic:
		return (void*)soap_instantiate__ns1__GetDwPic(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDwPicResponse:
		return (void*)soap_instantiate__ns1__GetDwPicResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDeviceXj:
		return (void*)soap_instantiate__ns1__GetDeviceXj(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDeviceXjResponse:
		return (void*)soap_instantiate__ns1__GetDeviceXjResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetJxData:
		return (void*)soap_instantiate__ns1__GetJxData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetJxDataResponse:
		return (void*)soap_instantiate__ns1__GetJxDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetStationJxData:
		return (void*)soap_instantiate__ns1__GetStationJxData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetStationJxDataResponse:
		return (void*)soap_instantiate__ns1__GetStationJxDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetJxPic:
		return (void*)soap_instantiate__ns1__GetJxPic(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetJxPicResponse:
		return (void*)soap_instantiate__ns1__GetJxPicResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDevPic:
		return (void*)soap_instantiate__ns1__GetDevPic(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDevPicResponse:
		return (void*)soap_instantiate__ns1__GetDevPicResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetBgImg:
		return (void*)soap_instantiate__ns1__GetBgImg(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetBgImgResponse:
		return (void*)soap_instantiate__ns1__GetBgImgResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDcsData:
		return (void*)soap_instantiate__ns1__GetDcsData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDcsDataResponse:
		return (void*)soap_instantiate__ns1__GetDcsDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DownLoadMobGPSData:
		return (void*)soap_instantiate__ns1__DownLoadMobGPSData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DownLoadMobGPSDataResponse:
		return (void*)soap_instantiate__ns1__DownLoadMobGPSDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__MobDownLoadData:
		return (void*)soap_instantiate__ns1__MobDownLoadData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__MobDownLoadDataResponse:
		return (void*)soap_instantiate__ns1__MobDownLoadDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetOpenFireInfo:
		return (void*)soap_instantiate__ns1__GetOpenFireInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetOpenFireInfoResponse:
		return (void*)soap_instantiate__ns1__GetOpenFireInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDwList:
		return (void*)soap_instantiate__ns1__GetDwList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDwListResponse:
		return (void*)soap_instantiate__ns1__GetDwListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetUnitStation:
		return (void*)soap_instantiate__ns1__GetUnitStation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetUnitStationResponse:
		return (void*)soap_instantiate__ns1__GetUnitStationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetUnitStruct:
		return (void*)soap_instantiate__ns1__GetUnitStruct(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetUnitStructResponse:
		return (void*)soap_instantiate__ns1__GetUnitStructResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetUnitPersonInfo:
		return (void*)soap_instantiate__ns1__GetUnitPersonInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetUnitPersonInfoResponse:
		return (void*)soap_instantiate__ns1__GetUnitPersonInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetFileSize:
		return (void*)soap_instantiate__ns1__GetFileSize(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetFileSizeResponse:
		return (void*)soap_instantiate__ns1__GetFileSizeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetXbList:
		return (void*)soap_instantiate__ns1__GetXbList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetXbListResponse:
		return (void*)soap_instantiate__ns1__GetXbListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetXbStationList:
		return (void*)soap_instantiate__ns1__GetXbStationList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetXbStationListResponse:
		return (void*)soap_instantiate__ns1__GetXbStationListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMapDeviceType:
		return (void*)soap_instantiate__ns1__GetMapDeviceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMapDeviceTypeResponse:
		return (void*)soap_instantiate__ns1__GetMapDeviceTypeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetGxDeviceData:
		return (void*)soap_instantiate__ns1__GetGxDeviceData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetGxDeviceDataResponse:
		return (void*)soap_instantiate__ns1__GetGxDeviceDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDownFileInfo:
		return (void*)soap_instantiate__ns1__GetDownFileInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDownFileInfoResponse:
		return (void*)soap_instantiate__ns1__GetDownFileInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DownMapfile:
		return (void*)soap_instantiate__ns1__DownMapfile(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DownMapfileResponse:
		return (void*)soap_instantiate__ns1__DownMapfileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetFileNew:
		return (void*)soap_instantiate__ns1__GetFileNew(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetFileNewResponse:
		return (void*)soap_instantiate__ns1__GetFileNewResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AlterTable:
		return (void*)soap_instantiate__ns1__AlterTable(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AlterTableResponse:
		return (void*)soap_instantiate__ns1__AlterTableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DownCQData:
		return (void*)soap_instantiate__ns1__DownCQData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DownCQDataResponse:
		return (void*)soap_instantiate__ns1__DownCQDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetTabList:
		return (void*)soap_instantiate__ns1__GetTabList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetTabListResponse:
		return (void*)soap_instantiate__ns1__GetTabListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__IsOracleTable:
		return (void*)soap_instantiate__ns1__IsOracleTable(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__IsOracleTableResponse:
		return (void*)soap_instantiate__ns1__IsOracleTableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetFieldInfo:
		return (void*)soap_instantiate__ns1__GetFieldInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetFieldInfoResponse:
		return (void*)soap_instantiate__ns1__GetFieldInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ExecuteSqlForFile:
		return (void*)soap_instantiate__ns1__ExecuteSqlForFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ExecuteSqlForFileResponse:
		return (void*)soap_instantiate__ns1__ExecuteSqlForFileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DownLoadFile:
		return (void*)soap_instantiate__ns1__DownLoadFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DownLoadFileResponse:
		return (void*)soap_instantiate__ns1__DownLoadFileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__WriteFile:
		return (void*)soap_instantiate__ns1__WriteFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__WriteFileResponse:
		return (void*)soap_instantiate__ns1__WriteFileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMapUpdateTime:
		return (void*)soap_instantiate__ns1__GetMapUpdateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMapUpdateTimeResponse:
		return (void*)soap_instantiate__ns1__GetMapUpdateTimeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMapTabName:
		return (void*)soap_instantiate__ns1__GetMapTabName(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMapTabNameResponse:
		return (void*)soap_instantiate__ns1__GetMapTabNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMapDeviceData:
		return (void*)soap_instantiate__ns1__GetMapDeviceData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMapDeviceDataResponse:
		return (void*)soap_instantiate__ns1__GetMapDeviceDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMaList:
		return (void*)soap_instantiate__ns1__GetMaList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMaListResponse:
		return (void*)soap_instantiate__ns1__GetMaListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMangeUnit:
		return (void*)soap_instantiate__ns1__GetMangeUnit(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMangeUnitResponse:
		return (void*)soap_instantiate__ns1__GetMangeUnitResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMangeXb:
		return (void*)soap_instantiate__ns1__GetMangeXb(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMangeXbResponse:
		return (void*)soap_instantiate__ns1__GetMangeXbResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CheckMapVer:
		return (void*)soap_instantiate__ns1__CheckMapVer(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CheckMapVerResponse:
		return (void*)soap_instantiate__ns1__CheckMapVerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMap:
		return (void*)soap_instantiate__ns1__GetMap(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMapResponse:
		return (void*)soap_instantiate__ns1__GetMapResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetTableData:
		return (void*)soap_instantiate__ns1__GetTableData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetTableDataResponse:
		return (void*)soap_instantiate__ns1__GetTableDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ServerLevel:
		return (void*)soap_instantiate__ns1__ServerLevel(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ServerLevelResponse:
		return (void*)soap_instantiate__ns1__ServerLevelResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMapListTime:
		return (void*)soap_instantiate__ns1__GetMapListTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMapListTimeResponse:
		return (void*)soap_instantiate__ns1__GetMapListTimeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdateGzclMap:
		return (void*)soap_instantiate__ns1__UpdateGzclMap(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdateGzclMapResponse:
		return (void*)soap_instantiate__ns1__UpdateGzclMapResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetUnitMapVer:
		return (void*)soap_instantiate__ns1__GetUnitMapVer(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetUnitMapVerResponse:
		return (void*)soap_instantiate__ns1__GetUnitMapVerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMangeMapUpdate:
		return (void*)soap_instantiate__ns1__GetMangeMapUpdate(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetMangeMapUpdateResponse:
		return (void*)soap_instantiate__ns1__GetMangeMapUpdateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OpenProcess:
		return (void*)soap_instantiate__ns1__OpenProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OpenProcessResponse:
		return (void*)soap_instantiate__ns1__OpenProcessResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetEmfPngVer:
		return (void*)soap_instantiate__ns1__GetEmfPngVer(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetEmfPngVerResponse:
		return (void*)soap_instantiate__ns1__GetEmfPngVerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetEmfPngFile:
		return (void*)soap_instantiate__ns1__GetEmfPngFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetEmfPngFileResponse:
		return (void*)soap_instantiate__ns1__GetEmfPngFileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OpenMapExe:
		return (void*)soap_instantiate__ns1__OpenMapExe(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OpenMapExeResponse:
		return (void*)soap_instantiate__ns1__OpenMapExeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ChaoQi:
		return (void*)soap_instantiate__ns1__ChaoQi(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ChaoQiResponse:
		return (void*)soap_instantiate__ns1__ChaoQiResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__JiChaoQi:
		return (void*)soap_instantiate__ns1__JiChaoQi(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__JiChaoQiResponse:
		return (void*)soap_instantiate__ns1__JiChaoQiResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetZhouQi:
		return (void*)soap_instantiate__ns1__GetZhouQi(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetZhouQiResponse:
		return (void*)soap_instantiate__ns1__GetZhouQiResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__FlowChartEmf:
		return (void*)soap_instantiate__ns1__FlowChartEmf(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__FlowChartEmfResponse:
		return (void*)soap_instantiate__ns1__FlowChartEmfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SGCDrawEmf:
		return (void*)soap_instantiate__ns1__SGCDrawEmf(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SGCDrawEmfResponse:
		return (void*)soap_instantiate__ns1__SGCDrawEmfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GzGetTypeList:
		return (void*)soap_instantiate__ns1__GzGetTypeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GzGetTypeListResponse:
		return (void*)soap_instantiate__ns1__GzGetTypeListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GzGetDeviceStruct:
		return (void*)soap_instantiate__ns1__GzGetDeviceStruct(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GzGetDeviceStructResponse:
		return (void*)soap_instantiate__ns1__GzGetDeviceStructResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SaveMapFile:
		return (void*)soap_instantiate__ns1__SaveMapFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SaveMapFileResponse:
		return (void*)soap_instantiate__ns1__SaveMapFileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SelectYjzhStation:
		return (void*)soap_instantiate__ns1__SelectYjzhStation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SelectYjzhStationResponse:
		return (void*)soap_instantiate__ns1__SelectYjzhStationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SelectYjzhDevice:
		return (void*)soap_instantiate__ns1__SelectYjzhDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SelectYjzhDeviceResponse:
		return (void*)soap_instantiate__ns1__SelectYjzhDeviceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetYjzhZskAlarmTypes:
		return (void*)soap_instantiate__ns1__GetYjzhZskAlarmTypes(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetYjzhZskAlarmTypesResponse:
		return (void*)soap_instantiate__ns1__GetYjzhZskAlarmTypesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetYjzhZskGzFlow:
		return (void*)soap_instantiate___ns1__GetYjzhZskGzFlow(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetYjzhZskOtherFlowChartList:
		return (void*)soap_instantiate___ns1__GetYjzhZskOtherFlowChartList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetYjzhZskDevFlowChartList:
		return (void*)soap_instantiate___ns1__GetYjzhZskDevFlowChartList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetPropList:
		return (void*)soap_instantiate___ns1__GetPropList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetPropName:
		return (void*)soap_instantiate___ns1__GetPropName(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CheckLoginUser:
		return (void*)soap_instantiate___ns1__CheckLoginUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetRyUnit:
		return (void*)soap_instantiate___ns1__GetRyUnit(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetDevCode:
		return (void*)soap_instantiate___ns1__GetDevCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CheckDevCode:
		return (void*)soap_instantiate___ns1__CheckDevCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__HelloWorld:
		return (void*)soap_instantiate___ns1__HelloWorld(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetDBString:
		return (void*)soap_instantiate___ns1__GetDBString(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__QueryData:
		return (void*)soap_instantiate___ns1__QueryData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__QueryDataCount:
		return (void*)soap_instantiate___ns1__QueryDataCount(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ExecuteSql:
		return (void*)soap_instantiate___ns1__ExecuteSql(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SaveData:
		return (void*)soap_instantiate___ns1__SaveData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SaveFileData:
		return (void*)soap_instantiate___ns1__SaveFileData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DownPic:
		return (void*)soap_instantiate___ns1__DownPic(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DownAllPic:
		return (void*)soap_instantiate___ns1__DownAllPic(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetGxdataUpTime:
		return (void*)soap_instantiate___ns1__GetGxdataUpTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__signedUserInfo:
		return (void*)soap_instantiate___ns1__signedUserInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetOsDateTime:
		return (void*)soap_instantiate___ns1__GetOsDateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__QueryPhotobw:
		return (void*)soap_instantiate___ns1__QueryPhotobw(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__TcdQuery:
		return (void*)soap_instantiate___ns1__TcdQuery(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__TcdSendup:
		return (void*)soap_instantiate___ns1__TcdSendup(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpLoadData:
		return (void*)soap_instantiate___ns1__UpLoadData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ExecuteSqlForColb:
		return (void*)soap_instantiate___ns1__ExecuteSqlForColb(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetXHYDGLXTupdater:
		return (void*)soap_instantiate___ns1__GetXHYDGLXTupdater(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAPVupdater:
		return (void*)soap_instantiate___ns1__GetAPVupdater(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpLoadFile:
		return (void*)soap_instantiate___ns1__UpLoadFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__upPic:
		return (void*)soap_instantiate___ns1__upPic(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DownloadPic:
		return (void*)soap_instantiate___ns1__DownloadPic(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetPicNames:
		return (void*)soap_instantiate___ns1__GetPicNames(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetDwInfo:
		return (void*)soap_instantiate___ns1__GetDwInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetDwPic:
		return (void*)soap_instantiate___ns1__GetDwPic(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetDeviceXj:
		return (void*)soap_instantiate___ns1__GetDeviceXj(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetJxData:
		return (void*)soap_instantiate___ns1__GetJxData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetStationJxData:
		return (void*)soap_instantiate___ns1__GetStationJxData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetJxPic:
		return (void*)soap_instantiate___ns1__GetJxPic(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetDevPic:
		return (void*)soap_instantiate___ns1__GetDevPic(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetBgImg:
		return (void*)soap_instantiate___ns1__GetBgImg(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetDcsData:
		return (void*)soap_instantiate___ns1__GetDcsData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DownLoadMobGPSData:
		return (void*)soap_instantiate___ns1__DownLoadMobGPSData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__MobDownLoadData:
		return (void*)soap_instantiate___ns1__MobDownLoadData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetOpenFireInfo:
		return (void*)soap_instantiate___ns1__GetOpenFireInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetDwList:
		return (void*)soap_instantiate___ns1__GetDwList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetUnitStation:
		return (void*)soap_instantiate___ns1__GetUnitStation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetUnitStruct:
		return (void*)soap_instantiate___ns1__GetUnitStruct(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetUnitPersonInfo:
		return (void*)soap_instantiate___ns1__GetUnitPersonInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetFileSize:
		return (void*)soap_instantiate___ns1__GetFileSize(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetXbList:
		return (void*)soap_instantiate___ns1__GetXbList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetXbStationList:
		return (void*)soap_instantiate___ns1__GetXbStationList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMapDeviceType:
		return (void*)soap_instantiate___ns1__GetMapDeviceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetGxDeviceData:
		return (void*)soap_instantiate___ns1__GetGxDeviceData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetDownFileInfo:
		return (void*)soap_instantiate___ns1__GetDownFileInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DownMapfile:
		return (void*)soap_instantiate___ns1__DownMapfile(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetFileNew:
		return (void*)soap_instantiate___ns1__GetFileNew(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__AlterTable:
		return (void*)soap_instantiate___ns1__AlterTable(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DownCQData:
		return (void*)soap_instantiate___ns1__DownCQData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetTabList:
		return (void*)soap_instantiate___ns1__GetTabList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__IsOracleTable:
		return (void*)soap_instantiate___ns1__IsOracleTable(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetFieldInfo:
		return (void*)soap_instantiate___ns1__GetFieldInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ExecuteSqlForFile:
		return (void*)soap_instantiate___ns1__ExecuteSqlForFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DownLoadFile:
		return (void*)soap_instantiate___ns1__DownLoadFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__WriteFile:
		return (void*)soap_instantiate___ns1__WriteFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMapUpdateTime:
		return (void*)soap_instantiate___ns1__GetMapUpdateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMapTabName:
		return (void*)soap_instantiate___ns1__GetMapTabName(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMapDeviceData:
		return (void*)soap_instantiate___ns1__GetMapDeviceData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMaList:
		return (void*)soap_instantiate___ns1__GetMaList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMangeUnit:
		return (void*)soap_instantiate___ns1__GetMangeUnit(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMangeXb:
		return (void*)soap_instantiate___ns1__GetMangeXb(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CheckMapVer:
		return (void*)soap_instantiate___ns1__CheckMapVer(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMap:
		return (void*)soap_instantiate___ns1__GetMap(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetTableData:
		return (void*)soap_instantiate___ns1__GetTableData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ServerLevel:
		return (void*)soap_instantiate___ns1__ServerLevel(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMapListTime:
		return (void*)soap_instantiate___ns1__GetMapListTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpdateGzclMap:
		return (void*)soap_instantiate___ns1__UpdateGzclMap(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetUnitMapVer:
		return (void*)soap_instantiate___ns1__GetUnitMapVer(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMangeMapUpdate:
		return (void*)soap_instantiate___ns1__GetMangeMapUpdate(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__OpenProcess:
		return (void*)soap_instantiate___ns1__OpenProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetEmfPngVer:
		return (void*)soap_instantiate___ns1__GetEmfPngVer(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetEmfPngFile:
		return (void*)soap_instantiate___ns1__GetEmfPngFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__OpenMapExe:
		return (void*)soap_instantiate___ns1__OpenMapExe(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ChaoQi:
		return (void*)soap_instantiate___ns1__ChaoQi(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__JiChaoQi:
		return (void*)soap_instantiate___ns1__JiChaoQi(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetZhouQi:
		return (void*)soap_instantiate___ns1__GetZhouQi(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__FlowChartEmf:
		return (void*)soap_instantiate___ns1__FlowChartEmf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SGCDrawEmf:
		return (void*)soap_instantiate___ns1__SGCDrawEmf(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GzGetTypeList:
		return (void*)soap_instantiate___ns1__GzGetTypeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GzGetDeviceStruct:
		return (void*)soap_instantiate___ns1__GzGetDeviceStruct(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SaveMapFile:
		return (void*)soap_instantiate___ns1__SaveMapFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SelectYjzhStation:
		return (void*)soap_instantiate___ns1__SelectYjzhStation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SelectYjzhDevice:
		return (void*)soap_instantiate___ns1__SelectYjzhDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetYjzhZskAlarmTypes:
		return (void*)soap_instantiate___ns1__GetYjzhZskAlarmTypes(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetYjzhZskGzFlow_:
		return (void*)soap_instantiate___ns1__GetYjzhZskGzFlow_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetYjzhZskOtherFlowChartList_:
		return (void*)soap_instantiate___ns1__GetYjzhZskOtherFlowChartList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetYjzhZskDevFlowChartList_:
		return (void*)soap_instantiate___ns1__GetYjzhZskDevFlowChartList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetPropList_:
		return (void*)soap_instantiate___ns1__GetPropList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetPropName_:
		return (void*)soap_instantiate___ns1__GetPropName_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CheckLoginUser_:
		return (void*)soap_instantiate___ns1__CheckLoginUser_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetRyUnit_:
		return (void*)soap_instantiate___ns1__GetRyUnit_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetDevCode_:
		return (void*)soap_instantiate___ns1__GetDevCode_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CheckDevCode_:
		return (void*)soap_instantiate___ns1__CheckDevCode_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__HelloWorld_:
		return (void*)soap_instantiate___ns1__HelloWorld_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetDBString_:
		return (void*)soap_instantiate___ns1__GetDBString_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__QueryData_:
		return (void*)soap_instantiate___ns1__QueryData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__QueryDataCount_:
		return (void*)soap_instantiate___ns1__QueryDataCount_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ExecuteSql_:
		return (void*)soap_instantiate___ns1__ExecuteSql_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SaveData_:
		return (void*)soap_instantiate___ns1__SaveData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SaveFileData_:
		return (void*)soap_instantiate___ns1__SaveFileData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DownPic_:
		return (void*)soap_instantiate___ns1__DownPic_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DownAllPic_:
		return (void*)soap_instantiate___ns1__DownAllPic_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetGxdataUpTime_:
		return (void*)soap_instantiate___ns1__GetGxdataUpTime_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__signedUserInfo_:
		return (void*)soap_instantiate___ns1__signedUserInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetOsDateTime_:
		return (void*)soap_instantiate___ns1__GetOsDateTime_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__QueryPhotobw_:
		return (void*)soap_instantiate___ns1__QueryPhotobw_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__TcdQuery_:
		return (void*)soap_instantiate___ns1__TcdQuery_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__TcdSendup_:
		return (void*)soap_instantiate___ns1__TcdSendup_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpLoadData_:
		return (void*)soap_instantiate___ns1__UpLoadData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ExecuteSqlForColb_:
		return (void*)soap_instantiate___ns1__ExecuteSqlForColb_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetXHYDGLXTupdater_:
		return (void*)soap_instantiate___ns1__GetXHYDGLXTupdater_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAPVupdater_:
		return (void*)soap_instantiate___ns1__GetAPVupdater_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpLoadFile_:
		return (void*)soap_instantiate___ns1__UpLoadFile_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__upPic_:
		return (void*)soap_instantiate___ns1__upPic_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DownloadPic_:
		return (void*)soap_instantiate___ns1__DownloadPic_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetPicNames_:
		return (void*)soap_instantiate___ns1__GetPicNames_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetDwInfo_:
		return (void*)soap_instantiate___ns1__GetDwInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetDwPic_:
		return (void*)soap_instantiate___ns1__GetDwPic_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetDeviceXj_:
		return (void*)soap_instantiate___ns1__GetDeviceXj_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetJxData_:
		return (void*)soap_instantiate___ns1__GetJxData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetStationJxData_:
		return (void*)soap_instantiate___ns1__GetStationJxData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetJxPic_:
		return (void*)soap_instantiate___ns1__GetJxPic_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetDevPic_:
		return (void*)soap_instantiate___ns1__GetDevPic_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetBgImg_:
		return (void*)soap_instantiate___ns1__GetBgImg_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetDcsData_:
		return (void*)soap_instantiate___ns1__GetDcsData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DownLoadMobGPSData_:
		return (void*)soap_instantiate___ns1__DownLoadMobGPSData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__MobDownLoadData_:
		return (void*)soap_instantiate___ns1__MobDownLoadData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetOpenFireInfo_:
		return (void*)soap_instantiate___ns1__GetOpenFireInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetDwList_:
		return (void*)soap_instantiate___ns1__GetDwList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetUnitStation_:
		return (void*)soap_instantiate___ns1__GetUnitStation_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetUnitStruct_:
		return (void*)soap_instantiate___ns1__GetUnitStruct_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetUnitPersonInfo_:
		return (void*)soap_instantiate___ns1__GetUnitPersonInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetFileSize_:
		return (void*)soap_instantiate___ns1__GetFileSize_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetXbList_:
		return (void*)soap_instantiate___ns1__GetXbList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetXbStationList_:
		return (void*)soap_instantiate___ns1__GetXbStationList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMapDeviceType_:
		return (void*)soap_instantiate___ns1__GetMapDeviceType_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetGxDeviceData_:
		return (void*)soap_instantiate___ns1__GetGxDeviceData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetDownFileInfo_:
		return (void*)soap_instantiate___ns1__GetDownFileInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DownMapfile_:
		return (void*)soap_instantiate___ns1__DownMapfile_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetFileNew_:
		return (void*)soap_instantiate___ns1__GetFileNew_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__AlterTable_:
		return (void*)soap_instantiate___ns1__AlterTable_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DownCQData_:
		return (void*)soap_instantiate___ns1__DownCQData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetTabList_:
		return (void*)soap_instantiate___ns1__GetTabList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__IsOracleTable_:
		return (void*)soap_instantiate___ns1__IsOracleTable_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetFieldInfo_:
		return (void*)soap_instantiate___ns1__GetFieldInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ExecuteSqlForFile_:
		return (void*)soap_instantiate___ns1__ExecuteSqlForFile_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DownLoadFile_:
		return (void*)soap_instantiate___ns1__DownLoadFile_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__WriteFile_:
		return (void*)soap_instantiate___ns1__WriteFile_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMapUpdateTime_:
		return (void*)soap_instantiate___ns1__GetMapUpdateTime_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMapTabName_:
		return (void*)soap_instantiate___ns1__GetMapTabName_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMapDeviceData_:
		return (void*)soap_instantiate___ns1__GetMapDeviceData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMaList_:
		return (void*)soap_instantiate___ns1__GetMaList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMangeUnit_:
		return (void*)soap_instantiate___ns1__GetMangeUnit_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMangeXb_:
		return (void*)soap_instantiate___ns1__GetMangeXb_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CheckMapVer_:
		return (void*)soap_instantiate___ns1__CheckMapVer_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMap_:
		return (void*)soap_instantiate___ns1__GetMap_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetTableData_:
		return (void*)soap_instantiate___ns1__GetTableData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ServerLevel_:
		return (void*)soap_instantiate___ns1__ServerLevel_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMapListTime_:
		return (void*)soap_instantiate___ns1__GetMapListTime_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpdateGzclMap_:
		return (void*)soap_instantiate___ns1__UpdateGzclMap_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetUnitMapVer_:
		return (void*)soap_instantiate___ns1__GetUnitMapVer_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetMangeMapUpdate_:
		return (void*)soap_instantiate___ns1__GetMangeMapUpdate_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__OpenProcess_:
		return (void*)soap_instantiate___ns1__OpenProcess_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetEmfPngVer_:
		return (void*)soap_instantiate___ns1__GetEmfPngVer_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetEmfPngFile_:
		return (void*)soap_instantiate___ns1__GetEmfPngFile_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__OpenMapExe_:
		return (void*)soap_instantiate___ns1__OpenMapExe_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ChaoQi_:
		return (void*)soap_instantiate___ns1__ChaoQi_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__JiChaoQi_:
		return (void*)soap_instantiate___ns1__JiChaoQi_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetZhouQi_:
		return (void*)soap_instantiate___ns1__GetZhouQi_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__FlowChartEmf_:
		return (void*)soap_instantiate___ns1__FlowChartEmf_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SGCDrawEmf_:
		return (void*)soap_instantiate___ns1__SGCDrawEmf_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GzGetTypeList_:
		return (void*)soap_instantiate___ns1__GzGetTypeList_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GzGetDeviceStruct_:
		return (void*)soap_instantiate___ns1__GzGetDeviceStruct_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SaveMapFile_:
		return (void*)soap_instantiate___ns1__SaveMapFile_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SelectYjzhStation_:
		return (void*)soap_instantiate___ns1__SelectYjzhStation_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SelectYjzhDevice_:
		return (void*)soap_instantiate___ns1__SelectYjzhDevice_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetYjzhZskAlarmTypes_:
		return (void*)soap_instantiate___ns1__GetYjzhZskAlarmTypes_(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap *soap, struct soap_clist *p)
{	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__base64Binary*>(p->ptr), xsd__base64Binary);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__base64Binary*>(p->ptr), xsd__base64Binary);
		break;
	case SOAP_TYPE_ns1__ArrayOfBase64Binary:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ArrayOfBase64Binary*>(p->ptr), ns1__ArrayOfBase64Binary);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ArrayOfBase64Binary*>(p->ptr), ns1__ArrayOfBase64Binary);
		break;
	case SOAP_TYPE__ns1__GetYjzhZskGzFlow:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetYjzhZskGzFlow*>(p->ptr), _ns1__GetYjzhZskGzFlow);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetYjzhZskGzFlow*>(p->ptr), _ns1__GetYjzhZskGzFlow);
		break;
	case SOAP_TYPE__ns1__GetYjzhZskGzFlowResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetYjzhZskGzFlowResponse*>(p->ptr), _ns1__GetYjzhZskGzFlowResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetYjzhZskGzFlowResponse*>(p->ptr), _ns1__GetYjzhZskGzFlowResponse);
		break;
	case SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetYjzhZskOtherFlowChartList*>(p->ptr), _ns1__GetYjzhZskOtherFlowChartList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetYjzhZskOtherFlowChartList*>(p->ptr), _ns1__GetYjzhZskOtherFlowChartList);
		break;
	case SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetYjzhZskOtherFlowChartListResponse*>(p->ptr), _ns1__GetYjzhZskOtherFlowChartListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetYjzhZskOtherFlowChartListResponse*>(p->ptr), _ns1__GetYjzhZskOtherFlowChartListResponse);
		break;
	case SOAP_TYPE__ns1__GetYjzhZskDevFlowChartList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetYjzhZskDevFlowChartList*>(p->ptr), _ns1__GetYjzhZskDevFlowChartList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetYjzhZskDevFlowChartList*>(p->ptr), _ns1__GetYjzhZskDevFlowChartList);
		break;
	case SOAP_TYPE__ns1__GetYjzhZskDevFlowChartListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetYjzhZskDevFlowChartListResponse*>(p->ptr), _ns1__GetYjzhZskDevFlowChartListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetYjzhZskDevFlowChartListResponse*>(p->ptr), _ns1__GetYjzhZskDevFlowChartListResponse);
		break;
	case SOAP_TYPE__ns1__GetPropList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetPropList*>(p->ptr), _ns1__GetPropList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetPropList*>(p->ptr), _ns1__GetPropList);
		break;
	case SOAP_TYPE__ns1__GetPropListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetPropListResponse*>(p->ptr), _ns1__GetPropListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetPropListResponse*>(p->ptr), _ns1__GetPropListResponse);
		break;
	case SOAP_TYPE__ns1__GetPropName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetPropName*>(p->ptr), _ns1__GetPropName);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetPropName*>(p->ptr), _ns1__GetPropName);
		break;
	case SOAP_TYPE__ns1__GetPropNameResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetPropNameResponse*>(p->ptr), _ns1__GetPropNameResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetPropNameResponse*>(p->ptr), _ns1__GetPropNameResponse);
		break;
	case SOAP_TYPE__ns1__CheckLoginUser:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__CheckLoginUser*>(p->ptr), _ns1__CheckLoginUser);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__CheckLoginUser*>(p->ptr), _ns1__CheckLoginUser);
		break;
	case SOAP_TYPE__ns1__CheckLoginUserResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__CheckLoginUserResponse*>(p->ptr), _ns1__CheckLoginUserResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__CheckLoginUserResponse*>(p->ptr), _ns1__CheckLoginUserResponse);
		break;
	case SOAP_TYPE__ns1__GetRyUnit:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetRyUnit*>(p->ptr), _ns1__GetRyUnit);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetRyUnit*>(p->ptr), _ns1__GetRyUnit);
		break;
	case SOAP_TYPE__ns1__GetRyUnitResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetRyUnitResponse*>(p->ptr), _ns1__GetRyUnitResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetRyUnitResponse*>(p->ptr), _ns1__GetRyUnitResponse);
		break;
	case SOAP_TYPE__ns1__GetDevCode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetDevCode*>(p->ptr), _ns1__GetDevCode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetDevCode*>(p->ptr), _ns1__GetDevCode);
		break;
	case SOAP_TYPE__ns1__GetDevCodeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetDevCodeResponse*>(p->ptr), _ns1__GetDevCodeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetDevCodeResponse*>(p->ptr), _ns1__GetDevCodeResponse);
		break;
	case SOAP_TYPE__ns1__CheckDevCode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__CheckDevCode*>(p->ptr), _ns1__CheckDevCode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__CheckDevCode*>(p->ptr), _ns1__CheckDevCode);
		break;
	case SOAP_TYPE__ns1__CheckDevCodeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__CheckDevCodeResponse*>(p->ptr), _ns1__CheckDevCodeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__CheckDevCodeResponse*>(p->ptr), _ns1__CheckDevCodeResponse);
		break;
	case SOAP_TYPE__ns1__HelloWorld:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__HelloWorld*>(p->ptr), _ns1__HelloWorld);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__HelloWorld*>(p->ptr), _ns1__HelloWorld);
		break;
	case SOAP_TYPE__ns1__HelloWorldResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__HelloWorldResponse*>(p->ptr), _ns1__HelloWorldResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__HelloWorldResponse*>(p->ptr), _ns1__HelloWorldResponse);
		break;
	case SOAP_TYPE__ns1__GetDBString:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetDBString*>(p->ptr), _ns1__GetDBString);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetDBString*>(p->ptr), _ns1__GetDBString);
		break;
	case SOAP_TYPE__ns1__GetDBStringResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetDBStringResponse*>(p->ptr), _ns1__GetDBStringResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetDBStringResponse*>(p->ptr), _ns1__GetDBStringResponse);
		break;
	case SOAP_TYPE__ns1__QueryData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__QueryData*>(p->ptr), _ns1__QueryData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__QueryData*>(p->ptr), _ns1__QueryData);
		break;
	case SOAP_TYPE__ns1__QueryDataResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__QueryDataResponse*>(p->ptr), _ns1__QueryDataResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__QueryDataResponse*>(p->ptr), _ns1__QueryDataResponse);
		break;
	case SOAP_TYPE__ns1__QueryDataCount:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__QueryDataCount*>(p->ptr), _ns1__QueryDataCount);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__QueryDataCount*>(p->ptr), _ns1__QueryDataCount);
		break;
	case SOAP_TYPE__ns1__QueryDataCountResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__QueryDataCountResponse*>(p->ptr), _ns1__QueryDataCountResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__QueryDataCountResponse*>(p->ptr), _ns1__QueryDataCountResponse);
		break;
	case SOAP_TYPE__ns1__ExecuteSql:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ExecuteSql*>(p->ptr), _ns1__ExecuteSql);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ExecuteSql*>(p->ptr), _ns1__ExecuteSql);
		break;
	case SOAP_TYPE__ns1__ExecuteSqlResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ExecuteSqlResponse*>(p->ptr), _ns1__ExecuteSqlResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ExecuteSqlResponse*>(p->ptr), _ns1__ExecuteSqlResponse);
		break;
	case SOAP_TYPE__ns1__SaveData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__SaveData*>(p->ptr), _ns1__SaveData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__SaveData*>(p->ptr), _ns1__SaveData);
		break;
	case SOAP_TYPE__ns1__SaveDataResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__SaveDataResponse*>(p->ptr), _ns1__SaveDataResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__SaveDataResponse*>(p->ptr), _ns1__SaveDataResponse);
		break;
	case SOAP_TYPE__ns1__SaveFileData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__SaveFileData*>(p->ptr), _ns1__SaveFileData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__SaveFileData*>(p->ptr), _ns1__SaveFileData);
		break;
	case SOAP_TYPE__ns1__SaveFileDataResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__SaveFileDataResponse*>(p->ptr), _ns1__SaveFileDataResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__SaveFileDataResponse*>(p->ptr), _ns1__SaveFileDataResponse);
		break;
	case SOAP_TYPE__ns1__DownPic:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__DownPic*>(p->ptr), _ns1__DownPic);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__DownPic*>(p->ptr), _ns1__DownPic);
		break;
	case SOAP_TYPE__ns1__DownPicResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__DownPicResponse*>(p->ptr), _ns1__DownPicResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__DownPicResponse*>(p->ptr), _ns1__DownPicResponse);
		break;
	case SOAP_TYPE__ns1__DownAllPic:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__DownAllPic*>(p->ptr), _ns1__DownAllPic);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__DownAllPic*>(p->ptr), _ns1__DownAllPic);
		break;
	case SOAP_TYPE__ns1__DownAllPicResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__DownAllPicResponse*>(p->ptr), _ns1__DownAllPicResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__DownAllPicResponse*>(p->ptr), _ns1__DownAllPicResponse);
		break;
	case SOAP_TYPE__ns1__GetGxdataUpTime:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetGxdataUpTime*>(p->ptr), _ns1__GetGxdataUpTime);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetGxdataUpTime*>(p->ptr), _ns1__GetGxdataUpTime);
		break;
	case SOAP_TYPE__ns1__GetGxdataUpTimeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetGxdataUpTimeResponse*>(p->ptr), _ns1__GetGxdataUpTimeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetGxdataUpTimeResponse*>(p->ptr), _ns1__GetGxdataUpTimeResponse);
		break;
	case SOAP_TYPE__ns1__signedUserInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__signedUserInfo*>(p->ptr), _ns1__signedUserInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__signedUserInfo*>(p->ptr), _ns1__signedUserInfo);
		break;
	case SOAP_TYPE__ns1__signedUserInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__signedUserInfoResponse*>(p->ptr), _ns1__signedUserInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__signedUserInfoResponse*>(p->ptr), _ns1__signedUserInfoResponse);
		break;
	case SOAP_TYPE__ns1__GetOsDateTime:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetOsDateTime*>(p->ptr), _ns1__GetOsDateTime);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetOsDateTime*>(p->ptr), _ns1__GetOsDateTime);
		break;
	case SOAP_TYPE__ns1__GetOsDateTimeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetOsDateTimeResponse*>(p->ptr), _ns1__GetOsDateTimeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetOsDateTimeResponse*>(p->ptr), _ns1__GetOsDateTimeResponse);
		break;
	case SOAP_TYPE__ns1__QueryPhotobw:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__QueryPhotobw*>(p->ptr), _ns1__QueryPhotobw);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__QueryPhotobw*>(p->ptr), _ns1__QueryPhotobw);
		break;
	case SOAP_TYPE__ns1__QueryPhotobwResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__QueryPhotobwResponse*>(p->ptr), _ns1__QueryPhotobwResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__QueryPhotobwResponse*>(p->ptr), _ns1__QueryPhotobwResponse);
		break;
	case SOAP_TYPE__ns1__TcdQuery:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__TcdQuery*>(p->ptr), _ns1__TcdQuery);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__TcdQuery*>(p->ptr), _ns1__TcdQuery);
		break;
	case SOAP_TYPE__ns1__TcdQueryResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__TcdQueryResponse*>(p->ptr), _ns1__TcdQueryResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__TcdQueryResponse*>(p->ptr), _ns1__TcdQueryResponse);
		break;
	case SOAP_TYPE__ns1__TcdSendup:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__TcdSendup*>(p->ptr), _ns1__TcdSendup);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__TcdSendup*>(p->ptr), _ns1__TcdSendup);
		break;
	case SOAP_TYPE__ns1__TcdSendupResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__TcdSendupResponse*>(p->ptr), _ns1__TcdSendupResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__TcdSendupResponse*>(p->ptr), _ns1__TcdSendupResponse);
		break;
	case SOAP_TYPE__ns1__UpLoadData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__UpLoadData*>(p->ptr), _ns1__UpLoadData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__UpLoadData*>(p->ptr), _ns1__UpLoadData);
		break;
	case SOAP_TYPE__ns1__UpLoadDataResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__UpLoadDataResponse*>(p->ptr), _ns1__UpLoadDataResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__UpLoadDataResponse*>(p->ptr), _ns1__UpLoadDataResponse);
		break;
	case SOAP_TYPE__ns1__ExecuteSqlForColb:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ExecuteSqlForColb*>(p->ptr), _ns1__ExecuteSqlForColb);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ExecuteSqlForColb*>(p->ptr), _ns1__ExecuteSqlForColb);
		break;
	case SOAP_TYPE__ns1__ExecuteSqlForColbResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ExecuteSqlForColbResponse*>(p->ptr), _ns1__ExecuteSqlForColbResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ExecuteSqlForColbResponse*>(p->ptr), _ns1__ExecuteSqlForColbResponse);
		break;
	case SOAP_TYPE__ns1__GetXHYDGLXTupdater:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetXHYDGLXTupdater*>(p->ptr), _ns1__GetXHYDGLXTupdater);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetXHYDGLXTupdater*>(p->ptr), _ns1__GetXHYDGLXTupdater);
		break;
	case SOAP_TYPE__ns1__GetXHYDGLXTupdaterResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetXHYDGLXTupdaterResponse*>(p->ptr), _ns1__GetXHYDGLXTupdaterResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetXHYDGLXTupdaterResponse*>(p->ptr), _ns1__GetXHYDGLXTupdaterResponse);
		break;
	case SOAP_TYPE__ns1__GetAPVupdater:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetAPVupdater*>(p->ptr), _ns1__GetAPVupdater);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetAPVupdater*>(p->ptr), _ns1__GetAPVupdater);
		break;
	case SOAP_TYPE__ns1__GetAPVupdaterResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetAPVupdaterResponse*>(p->ptr), _ns1__GetAPVupdaterResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetAPVupdaterResponse*>(p->ptr), _ns1__GetAPVupdaterResponse);
		break;
	case SOAP_TYPE__ns1__UpLoadFile:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__UpLoadFile*>(p->ptr), _ns1__UpLoadFile);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__UpLoadFile*>(p->ptr), _ns1__UpLoadFile);
		break;
	case SOAP_TYPE__ns1__UpLoadFileResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__UpLoadFileResponse*>(p->ptr), _ns1__UpLoadFileResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__UpLoadFileResponse*>(p->ptr), _ns1__UpLoadFileResponse);
		break;
	case SOAP_TYPE__ns1__upPic:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__upPic*>(p->ptr), _ns1__upPic);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__upPic*>(p->ptr), _ns1__upPic);
		break;
	case SOAP_TYPE__ns1__upPicResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__upPicResponse*>(p->ptr), _ns1__upPicResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__upPicResponse*>(p->ptr), _ns1__upPicResponse);
		break;
	case SOAP_TYPE__ns1__DownloadPic:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__DownloadPic*>(p->ptr), _ns1__DownloadPic);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__DownloadPic*>(p->ptr), _ns1__DownloadPic);
		break;
	case SOAP_TYPE__ns1__DownloadPicResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__DownloadPicResponse*>(p->ptr), _ns1__DownloadPicResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__DownloadPicResponse*>(p->ptr), _ns1__DownloadPicResponse);
		break;
	case SOAP_TYPE__ns1__GetPicNames:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetPicNames*>(p->ptr), _ns1__GetPicNames);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetPicNames*>(p->ptr), _ns1__GetPicNames);
		break;
	case SOAP_TYPE__ns1__GetPicNamesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetPicNamesResponse*>(p->ptr), _ns1__GetPicNamesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetPicNamesResponse*>(p->ptr), _ns1__GetPicNamesResponse);
		break;
	case SOAP_TYPE__ns1__GetDwInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetDwInfo*>(p->ptr), _ns1__GetDwInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetDwInfo*>(p->ptr), _ns1__GetDwInfo);
		break;
	case SOAP_TYPE__ns1__GetDwInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetDwInfoResponse*>(p->ptr), _ns1__GetDwInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetDwInfoResponse*>(p->ptr), _ns1__GetDwInfoResponse);
		break;
	case SOAP_TYPE__ns1__GetDwPic:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetDwPic*>(p->ptr), _ns1__GetDwPic);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetDwPic*>(p->ptr), _ns1__GetDwPic);
		break;
	case SOAP_TYPE__ns1__GetDwPicResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetDwPicResponse*>(p->ptr), _ns1__GetDwPicResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetDwPicResponse*>(p->ptr), _ns1__GetDwPicResponse);
		break;
	case SOAP_TYPE__ns1__GetDeviceXj:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetDeviceXj*>(p->ptr), _ns1__GetDeviceXj);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetDeviceXj*>(p->ptr), _ns1__GetDeviceXj);
		break;
	case SOAP_TYPE__ns1__GetDeviceXjResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetDeviceXjResponse*>(p->ptr), _ns1__GetDeviceXjResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetDeviceXjResponse*>(p->ptr), _ns1__GetDeviceXjResponse);
		break;
	case SOAP_TYPE__ns1__GetJxData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetJxData*>(p->ptr), _ns1__GetJxData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetJxData*>(p->ptr), _ns1__GetJxData);
		break;
	case SOAP_TYPE__ns1__GetJxDataResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetJxDataResponse*>(p->ptr), _ns1__GetJxDataResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetJxDataResponse*>(p->ptr), _ns1__GetJxDataResponse);
		break;
	case SOAP_TYPE__ns1__GetStationJxData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetStationJxData*>(p->ptr), _ns1__GetStationJxData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetStationJxData*>(p->ptr), _ns1__GetStationJxData);
		break;
	case SOAP_TYPE__ns1__GetStationJxDataResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetStationJxDataResponse*>(p->ptr), _ns1__GetStationJxDataResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetStationJxDataResponse*>(p->ptr), _ns1__GetStationJxDataResponse);
		break;
	case SOAP_TYPE__ns1__GetJxPic:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetJxPic*>(p->ptr), _ns1__GetJxPic);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetJxPic*>(p->ptr), _ns1__GetJxPic);
		break;
	case SOAP_TYPE__ns1__GetJxPicResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetJxPicResponse*>(p->ptr), _ns1__GetJxPicResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetJxPicResponse*>(p->ptr), _ns1__GetJxPicResponse);
		break;
	case SOAP_TYPE__ns1__GetDevPic:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetDevPic*>(p->ptr), _ns1__GetDevPic);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetDevPic*>(p->ptr), _ns1__GetDevPic);
		break;
	case SOAP_TYPE__ns1__GetDevPicResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetDevPicResponse*>(p->ptr), _ns1__GetDevPicResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetDevPicResponse*>(p->ptr), _ns1__GetDevPicResponse);
		break;
	case SOAP_TYPE__ns1__GetBgImg:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetBgImg*>(p->ptr), _ns1__GetBgImg);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetBgImg*>(p->ptr), _ns1__GetBgImg);
		break;
	case SOAP_TYPE__ns1__GetBgImgResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetBgImgResponse*>(p->ptr), _ns1__GetBgImgResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetBgImgResponse*>(p->ptr), _ns1__GetBgImgResponse);
		break;
	case SOAP_TYPE__ns1__GetDcsData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetDcsData*>(p->ptr), _ns1__GetDcsData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetDcsData*>(p->ptr), _ns1__GetDcsData);
		break;
	case SOAP_TYPE__ns1__GetDcsDataResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetDcsDataResponse*>(p->ptr), _ns1__GetDcsDataResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetDcsDataResponse*>(p->ptr), _ns1__GetDcsDataResponse);
		break;
	case SOAP_TYPE__ns1__DownLoadMobGPSData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__DownLoadMobGPSData*>(p->ptr), _ns1__DownLoadMobGPSData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__DownLoadMobGPSData*>(p->ptr), _ns1__DownLoadMobGPSData);
		break;
	case SOAP_TYPE__ns1__DownLoadMobGPSDataResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__DownLoadMobGPSDataResponse*>(p->ptr), _ns1__DownLoadMobGPSDataResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__DownLoadMobGPSDataResponse*>(p->ptr), _ns1__DownLoadMobGPSDataResponse);
		break;
	case SOAP_TYPE__ns1__MobDownLoadData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__MobDownLoadData*>(p->ptr), _ns1__MobDownLoadData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__MobDownLoadData*>(p->ptr), _ns1__MobDownLoadData);
		break;
	case SOAP_TYPE__ns1__MobDownLoadDataResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__MobDownLoadDataResponse*>(p->ptr), _ns1__MobDownLoadDataResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__MobDownLoadDataResponse*>(p->ptr), _ns1__MobDownLoadDataResponse);
		break;
	case SOAP_TYPE__ns1__GetOpenFireInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetOpenFireInfo*>(p->ptr), _ns1__GetOpenFireInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetOpenFireInfo*>(p->ptr), _ns1__GetOpenFireInfo);
		break;
	case SOAP_TYPE__ns1__GetOpenFireInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetOpenFireInfoResponse*>(p->ptr), _ns1__GetOpenFireInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetOpenFireInfoResponse*>(p->ptr), _ns1__GetOpenFireInfoResponse);
		break;
	case SOAP_TYPE__ns1__GetDwList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetDwList*>(p->ptr), _ns1__GetDwList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetDwList*>(p->ptr), _ns1__GetDwList);
		break;
	case SOAP_TYPE__ns1__GetDwListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetDwListResponse*>(p->ptr), _ns1__GetDwListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetDwListResponse*>(p->ptr), _ns1__GetDwListResponse);
		break;
	case SOAP_TYPE__ns1__GetUnitStation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetUnitStation*>(p->ptr), _ns1__GetUnitStation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetUnitStation*>(p->ptr), _ns1__GetUnitStation);
		break;
	case SOAP_TYPE__ns1__GetUnitStationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetUnitStationResponse*>(p->ptr), _ns1__GetUnitStationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetUnitStationResponse*>(p->ptr), _ns1__GetUnitStationResponse);
		break;
	case SOAP_TYPE__ns1__GetUnitStruct:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetUnitStruct*>(p->ptr), _ns1__GetUnitStruct);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetUnitStruct*>(p->ptr), _ns1__GetUnitStruct);
		break;
	case SOAP_TYPE__ns1__GetUnitStructResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetUnitStructResponse*>(p->ptr), _ns1__GetUnitStructResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetUnitStructResponse*>(p->ptr), _ns1__GetUnitStructResponse);
		break;
	case SOAP_TYPE__ns1__GetUnitPersonInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetUnitPersonInfo*>(p->ptr), _ns1__GetUnitPersonInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetUnitPersonInfo*>(p->ptr), _ns1__GetUnitPersonInfo);
		break;
	case SOAP_TYPE__ns1__GetUnitPersonInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetUnitPersonInfoResponse*>(p->ptr), _ns1__GetUnitPersonInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetUnitPersonInfoResponse*>(p->ptr), _ns1__GetUnitPersonInfoResponse);
		break;
	case SOAP_TYPE__ns1__GetFileSize:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetFileSize*>(p->ptr), _ns1__GetFileSize);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetFileSize*>(p->ptr), _ns1__GetFileSize);
		break;
	case SOAP_TYPE__ns1__GetFileSizeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetFileSizeResponse*>(p->ptr), _ns1__GetFileSizeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetFileSizeResponse*>(p->ptr), _ns1__GetFileSizeResponse);
		break;
	case SOAP_TYPE__ns1__GetXbList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetXbList*>(p->ptr), _ns1__GetXbList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetXbList*>(p->ptr), _ns1__GetXbList);
		break;
	case SOAP_TYPE__ns1__GetXbListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetXbListResponse*>(p->ptr), _ns1__GetXbListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetXbListResponse*>(p->ptr), _ns1__GetXbListResponse);
		break;
	case SOAP_TYPE__ns1__GetXbStationList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetXbStationList*>(p->ptr), _ns1__GetXbStationList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetXbStationList*>(p->ptr), _ns1__GetXbStationList);
		break;
	case SOAP_TYPE__ns1__GetXbStationListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetXbStationListResponse*>(p->ptr), _ns1__GetXbStationListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetXbStationListResponse*>(p->ptr), _ns1__GetXbStationListResponse);
		break;
	case SOAP_TYPE__ns1__GetMapDeviceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetMapDeviceType*>(p->ptr), _ns1__GetMapDeviceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetMapDeviceType*>(p->ptr), _ns1__GetMapDeviceType);
		break;
	case SOAP_TYPE__ns1__GetMapDeviceTypeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetMapDeviceTypeResponse*>(p->ptr), _ns1__GetMapDeviceTypeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetMapDeviceTypeResponse*>(p->ptr), _ns1__GetMapDeviceTypeResponse);
		break;
	case SOAP_TYPE__ns1__GetGxDeviceData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetGxDeviceData*>(p->ptr), _ns1__GetGxDeviceData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetGxDeviceData*>(p->ptr), _ns1__GetGxDeviceData);
		break;
	case SOAP_TYPE__ns1__GetGxDeviceDataResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetGxDeviceDataResponse*>(p->ptr), _ns1__GetGxDeviceDataResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetGxDeviceDataResponse*>(p->ptr), _ns1__GetGxDeviceDataResponse);
		break;
	case SOAP_TYPE__ns1__GetDownFileInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetDownFileInfo*>(p->ptr), _ns1__GetDownFileInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetDownFileInfo*>(p->ptr), _ns1__GetDownFileInfo);
		break;
	case SOAP_TYPE__ns1__GetDownFileInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetDownFileInfoResponse*>(p->ptr), _ns1__GetDownFileInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetDownFileInfoResponse*>(p->ptr), _ns1__GetDownFileInfoResponse);
		break;
	case SOAP_TYPE__ns1__DownMapfile:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__DownMapfile*>(p->ptr), _ns1__DownMapfile);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__DownMapfile*>(p->ptr), _ns1__DownMapfile);
		break;
	case SOAP_TYPE__ns1__DownMapfileResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__DownMapfileResponse*>(p->ptr), _ns1__DownMapfileResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__DownMapfileResponse*>(p->ptr), _ns1__DownMapfileResponse);
		break;
	case SOAP_TYPE__ns1__GetFileNew:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetFileNew*>(p->ptr), _ns1__GetFileNew);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetFileNew*>(p->ptr), _ns1__GetFileNew);
		break;
	case SOAP_TYPE__ns1__GetFileNewResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetFileNewResponse*>(p->ptr), _ns1__GetFileNewResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetFileNewResponse*>(p->ptr), _ns1__GetFileNewResponse);
		break;
	case SOAP_TYPE__ns1__AlterTable:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__AlterTable*>(p->ptr), _ns1__AlterTable);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__AlterTable*>(p->ptr), _ns1__AlterTable);
		break;
	case SOAP_TYPE__ns1__AlterTableResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__AlterTableResponse*>(p->ptr), _ns1__AlterTableResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__AlterTableResponse*>(p->ptr), _ns1__AlterTableResponse);
		break;
	case SOAP_TYPE__ns1__DownCQData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__DownCQData*>(p->ptr), _ns1__DownCQData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__DownCQData*>(p->ptr), _ns1__DownCQData);
		break;
	case SOAP_TYPE__ns1__DownCQDataResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__DownCQDataResponse*>(p->ptr), _ns1__DownCQDataResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__DownCQDataResponse*>(p->ptr), _ns1__DownCQDataResponse);
		break;
	case SOAP_TYPE__ns1__GetTabList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetTabList*>(p->ptr), _ns1__GetTabList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetTabList*>(p->ptr), _ns1__GetTabList);
		break;
	case SOAP_TYPE__ns1__GetTabListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetTabListResponse*>(p->ptr), _ns1__GetTabListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetTabListResponse*>(p->ptr), _ns1__GetTabListResponse);
		break;
	case SOAP_TYPE__ns1__IsOracleTable:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__IsOracleTable*>(p->ptr), _ns1__IsOracleTable);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__IsOracleTable*>(p->ptr), _ns1__IsOracleTable);
		break;
	case SOAP_TYPE__ns1__IsOracleTableResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__IsOracleTableResponse*>(p->ptr), _ns1__IsOracleTableResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__IsOracleTableResponse*>(p->ptr), _ns1__IsOracleTableResponse);
		break;
	case SOAP_TYPE__ns1__GetFieldInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetFieldInfo*>(p->ptr), _ns1__GetFieldInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetFieldInfo*>(p->ptr), _ns1__GetFieldInfo);
		break;
	case SOAP_TYPE__ns1__GetFieldInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetFieldInfoResponse*>(p->ptr), _ns1__GetFieldInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetFieldInfoResponse*>(p->ptr), _ns1__GetFieldInfoResponse);
		break;
	case SOAP_TYPE__ns1__ExecuteSqlForFile:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ExecuteSqlForFile*>(p->ptr), _ns1__ExecuteSqlForFile);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ExecuteSqlForFile*>(p->ptr), _ns1__ExecuteSqlForFile);
		break;
	case SOAP_TYPE__ns1__ExecuteSqlForFileResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ExecuteSqlForFileResponse*>(p->ptr), _ns1__ExecuteSqlForFileResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ExecuteSqlForFileResponse*>(p->ptr), _ns1__ExecuteSqlForFileResponse);
		break;
	case SOAP_TYPE__ns1__DownLoadFile:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__DownLoadFile*>(p->ptr), _ns1__DownLoadFile);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__DownLoadFile*>(p->ptr), _ns1__DownLoadFile);
		break;
	case SOAP_TYPE__ns1__DownLoadFileResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__DownLoadFileResponse*>(p->ptr), _ns1__DownLoadFileResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__DownLoadFileResponse*>(p->ptr), _ns1__DownLoadFileResponse);
		break;
	case SOAP_TYPE__ns1__WriteFile:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__WriteFile*>(p->ptr), _ns1__WriteFile);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__WriteFile*>(p->ptr), _ns1__WriteFile);
		break;
	case SOAP_TYPE__ns1__WriteFileResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__WriteFileResponse*>(p->ptr), _ns1__WriteFileResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__WriteFileResponse*>(p->ptr), _ns1__WriteFileResponse);
		break;
	case SOAP_TYPE__ns1__GetMapUpdateTime:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetMapUpdateTime*>(p->ptr), _ns1__GetMapUpdateTime);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetMapUpdateTime*>(p->ptr), _ns1__GetMapUpdateTime);
		break;
	case SOAP_TYPE__ns1__GetMapUpdateTimeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetMapUpdateTimeResponse*>(p->ptr), _ns1__GetMapUpdateTimeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetMapUpdateTimeResponse*>(p->ptr), _ns1__GetMapUpdateTimeResponse);
		break;
	case SOAP_TYPE__ns1__GetMapTabName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetMapTabName*>(p->ptr), _ns1__GetMapTabName);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetMapTabName*>(p->ptr), _ns1__GetMapTabName);
		break;
	case SOAP_TYPE__ns1__GetMapTabNameResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetMapTabNameResponse*>(p->ptr), _ns1__GetMapTabNameResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetMapTabNameResponse*>(p->ptr), _ns1__GetMapTabNameResponse);
		break;
	case SOAP_TYPE__ns1__GetMapDeviceData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetMapDeviceData*>(p->ptr), _ns1__GetMapDeviceData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetMapDeviceData*>(p->ptr), _ns1__GetMapDeviceData);
		break;
	case SOAP_TYPE__ns1__GetMapDeviceDataResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetMapDeviceDataResponse*>(p->ptr), _ns1__GetMapDeviceDataResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetMapDeviceDataResponse*>(p->ptr), _ns1__GetMapDeviceDataResponse);
		break;
	case SOAP_TYPE__ns1__GetMaList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetMaList*>(p->ptr), _ns1__GetMaList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetMaList*>(p->ptr), _ns1__GetMaList);
		break;
	case SOAP_TYPE__ns1__GetMaListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetMaListResponse*>(p->ptr), _ns1__GetMaListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetMaListResponse*>(p->ptr), _ns1__GetMaListResponse);
		break;
	case SOAP_TYPE__ns1__GetMangeUnit:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetMangeUnit*>(p->ptr), _ns1__GetMangeUnit);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetMangeUnit*>(p->ptr), _ns1__GetMangeUnit);
		break;
	case SOAP_TYPE__ns1__GetMangeUnitResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetMangeUnitResponse*>(p->ptr), _ns1__GetMangeUnitResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetMangeUnitResponse*>(p->ptr), _ns1__GetMangeUnitResponse);
		break;
	case SOAP_TYPE__ns1__GetMangeXb:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetMangeXb*>(p->ptr), _ns1__GetMangeXb);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetMangeXb*>(p->ptr), _ns1__GetMangeXb);
		break;
	case SOAP_TYPE__ns1__GetMangeXbResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetMangeXbResponse*>(p->ptr), _ns1__GetMangeXbResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetMangeXbResponse*>(p->ptr), _ns1__GetMangeXbResponse);
		break;
	case SOAP_TYPE__ns1__CheckMapVer:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__CheckMapVer*>(p->ptr), _ns1__CheckMapVer);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__CheckMapVer*>(p->ptr), _ns1__CheckMapVer);
		break;
	case SOAP_TYPE__ns1__CheckMapVerResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__CheckMapVerResponse*>(p->ptr), _ns1__CheckMapVerResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__CheckMapVerResponse*>(p->ptr), _ns1__CheckMapVerResponse);
		break;
	case SOAP_TYPE__ns1__GetMap:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetMap*>(p->ptr), _ns1__GetMap);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetMap*>(p->ptr), _ns1__GetMap);
		break;
	case SOAP_TYPE__ns1__GetMapResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetMapResponse*>(p->ptr), _ns1__GetMapResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetMapResponse*>(p->ptr), _ns1__GetMapResponse);
		break;
	case SOAP_TYPE__ns1__GetTableData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetTableData*>(p->ptr), _ns1__GetTableData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetTableData*>(p->ptr), _ns1__GetTableData);
		break;
	case SOAP_TYPE__ns1__GetTableDataResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetTableDataResponse*>(p->ptr), _ns1__GetTableDataResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetTableDataResponse*>(p->ptr), _ns1__GetTableDataResponse);
		break;
	case SOAP_TYPE__ns1__ServerLevel:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ServerLevel*>(p->ptr), _ns1__ServerLevel);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ServerLevel*>(p->ptr), _ns1__ServerLevel);
		break;
	case SOAP_TYPE__ns1__ServerLevelResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ServerLevelResponse*>(p->ptr), _ns1__ServerLevelResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ServerLevelResponse*>(p->ptr), _ns1__ServerLevelResponse);
		break;
	case SOAP_TYPE__ns1__GetMapListTime:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetMapListTime*>(p->ptr), _ns1__GetMapListTime);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetMapListTime*>(p->ptr), _ns1__GetMapListTime);
		break;
	case SOAP_TYPE__ns1__GetMapListTimeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetMapListTimeResponse*>(p->ptr), _ns1__GetMapListTimeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetMapListTimeResponse*>(p->ptr), _ns1__GetMapListTimeResponse);
		break;
	case SOAP_TYPE__ns1__UpdateGzclMap:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__UpdateGzclMap*>(p->ptr), _ns1__UpdateGzclMap);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__UpdateGzclMap*>(p->ptr), _ns1__UpdateGzclMap);
		break;
	case SOAP_TYPE__ns1__UpdateGzclMapResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__UpdateGzclMapResponse*>(p->ptr), _ns1__UpdateGzclMapResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__UpdateGzclMapResponse*>(p->ptr), _ns1__UpdateGzclMapResponse);
		break;
	case SOAP_TYPE__ns1__GetUnitMapVer:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetUnitMapVer*>(p->ptr), _ns1__GetUnitMapVer);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetUnitMapVer*>(p->ptr), _ns1__GetUnitMapVer);
		break;
	case SOAP_TYPE__ns1__GetUnitMapVerResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetUnitMapVerResponse*>(p->ptr), _ns1__GetUnitMapVerResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetUnitMapVerResponse*>(p->ptr), _ns1__GetUnitMapVerResponse);
		break;
	case SOAP_TYPE__ns1__GetMangeMapUpdate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetMangeMapUpdate*>(p->ptr), _ns1__GetMangeMapUpdate);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetMangeMapUpdate*>(p->ptr), _ns1__GetMangeMapUpdate);
		break;
	case SOAP_TYPE__ns1__GetMangeMapUpdateResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetMangeMapUpdateResponse*>(p->ptr), _ns1__GetMangeMapUpdateResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetMangeMapUpdateResponse*>(p->ptr), _ns1__GetMangeMapUpdateResponse);
		break;
	case SOAP_TYPE__ns1__OpenProcess:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__OpenProcess*>(p->ptr), _ns1__OpenProcess);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__OpenProcess*>(p->ptr), _ns1__OpenProcess);
		break;
	case SOAP_TYPE__ns1__OpenProcessResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__OpenProcessResponse*>(p->ptr), _ns1__OpenProcessResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__OpenProcessResponse*>(p->ptr), _ns1__OpenProcessResponse);
		break;
	case SOAP_TYPE__ns1__GetEmfPngVer:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetEmfPngVer*>(p->ptr), _ns1__GetEmfPngVer);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetEmfPngVer*>(p->ptr), _ns1__GetEmfPngVer);
		break;
	case SOAP_TYPE__ns1__GetEmfPngVerResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetEmfPngVerResponse*>(p->ptr), _ns1__GetEmfPngVerResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetEmfPngVerResponse*>(p->ptr), _ns1__GetEmfPngVerResponse);
		break;
	case SOAP_TYPE__ns1__GetEmfPngFile:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetEmfPngFile*>(p->ptr), _ns1__GetEmfPngFile);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetEmfPngFile*>(p->ptr), _ns1__GetEmfPngFile);
		break;
	case SOAP_TYPE__ns1__GetEmfPngFileResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetEmfPngFileResponse*>(p->ptr), _ns1__GetEmfPngFileResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetEmfPngFileResponse*>(p->ptr), _ns1__GetEmfPngFileResponse);
		break;
	case SOAP_TYPE__ns1__OpenMapExe:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__OpenMapExe*>(p->ptr), _ns1__OpenMapExe);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__OpenMapExe*>(p->ptr), _ns1__OpenMapExe);
		break;
	case SOAP_TYPE__ns1__OpenMapExeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__OpenMapExeResponse*>(p->ptr), _ns1__OpenMapExeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__OpenMapExeResponse*>(p->ptr), _ns1__OpenMapExeResponse);
		break;
	case SOAP_TYPE__ns1__ChaoQi:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ChaoQi*>(p->ptr), _ns1__ChaoQi);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ChaoQi*>(p->ptr), _ns1__ChaoQi);
		break;
	case SOAP_TYPE__ns1__ChaoQiResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ChaoQiResponse*>(p->ptr), _ns1__ChaoQiResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ChaoQiResponse*>(p->ptr), _ns1__ChaoQiResponse);
		break;
	case SOAP_TYPE__ns1__JiChaoQi:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__JiChaoQi*>(p->ptr), _ns1__JiChaoQi);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__JiChaoQi*>(p->ptr), _ns1__JiChaoQi);
		break;
	case SOAP_TYPE__ns1__JiChaoQiResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__JiChaoQiResponse*>(p->ptr), _ns1__JiChaoQiResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__JiChaoQiResponse*>(p->ptr), _ns1__JiChaoQiResponse);
		break;
	case SOAP_TYPE__ns1__GetZhouQi:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetZhouQi*>(p->ptr), _ns1__GetZhouQi);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetZhouQi*>(p->ptr), _ns1__GetZhouQi);
		break;
	case SOAP_TYPE__ns1__GetZhouQiResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetZhouQiResponse*>(p->ptr), _ns1__GetZhouQiResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetZhouQiResponse*>(p->ptr), _ns1__GetZhouQiResponse);
		break;
	case SOAP_TYPE__ns1__FlowChartEmf:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__FlowChartEmf*>(p->ptr), _ns1__FlowChartEmf);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__FlowChartEmf*>(p->ptr), _ns1__FlowChartEmf);
		break;
	case SOAP_TYPE__ns1__FlowChartEmfResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__FlowChartEmfResponse*>(p->ptr), _ns1__FlowChartEmfResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__FlowChartEmfResponse*>(p->ptr), _ns1__FlowChartEmfResponse);
		break;
	case SOAP_TYPE__ns1__SGCDrawEmf:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__SGCDrawEmf*>(p->ptr), _ns1__SGCDrawEmf);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__SGCDrawEmf*>(p->ptr), _ns1__SGCDrawEmf);
		break;
	case SOAP_TYPE__ns1__SGCDrawEmfResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__SGCDrawEmfResponse*>(p->ptr), _ns1__SGCDrawEmfResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__SGCDrawEmfResponse*>(p->ptr), _ns1__SGCDrawEmfResponse);
		break;
	case SOAP_TYPE__ns1__GzGetTypeList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GzGetTypeList*>(p->ptr), _ns1__GzGetTypeList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GzGetTypeList*>(p->ptr), _ns1__GzGetTypeList);
		break;
	case SOAP_TYPE__ns1__GzGetTypeListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GzGetTypeListResponse*>(p->ptr), _ns1__GzGetTypeListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GzGetTypeListResponse*>(p->ptr), _ns1__GzGetTypeListResponse);
		break;
	case SOAP_TYPE__ns1__GzGetDeviceStruct:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GzGetDeviceStruct*>(p->ptr), _ns1__GzGetDeviceStruct);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GzGetDeviceStruct*>(p->ptr), _ns1__GzGetDeviceStruct);
		break;
	case SOAP_TYPE__ns1__GzGetDeviceStructResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GzGetDeviceStructResponse*>(p->ptr), _ns1__GzGetDeviceStructResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GzGetDeviceStructResponse*>(p->ptr), _ns1__GzGetDeviceStructResponse);
		break;
	case SOAP_TYPE__ns1__SaveMapFile:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__SaveMapFile*>(p->ptr), _ns1__SaveMapFile);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__SaveMapFile*>(p->ptr), _ns1__SaveMapFile);
		break;
	case SOAP_TYPE__ns1__SaveMapFileResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__SaveMapFileResponse*>(p->ptr), _ns1__SaveMapFileResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__SaveMapFileResponse*>(p->ptr), _ns1__SaveMapFileResponse);
		break;
	case SOAP_TYPE__ns1__SelectYjzhStation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__SelectYjzhStation*>(p->ptr), _ns1__SelectYjzhStation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__SelectYjzhStation*>(p->ptr), _ns1__SelectYjzhStation);
		break;
	case SOAP_TYPE__ns1__SelectYjzhStationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__SelectYjzhStationResponse*>(p->ptr), _ns1__SelectYjzhStationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__SelectYjzhStationResponse*>(p->ptr), _ns1__SelectYjzhStationResponse);
		break;
	case SOAP_TYPE__ns1__SelectYjzhDevice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__SelectYjzhDevice*>(p->ptr), _ns1__SelectYjzhDevice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__SelectYjzhDevice*>(p->ptr), _ns1__SelectYjzhDevice);
		break;
	case SOAP_TYPE__ns1__SelectYjzhDeviceResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__SelectYjzhDeviceResponse*>(p->ptr), _ns1__SelectYjzhDeviceResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__SelectYjzhDeviceResponse*>(p->ptr), _ns1__SelectYjzhDeviceResponse);
		break;
	case SOAP_TYPE__ns1__GetYjzhZskAlarmTypes:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetYjzhZskAlarmTypes*>(p->ptr), _ns1__GetYjzhZskAlarmTypes);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetYjzhZskAlarmTypes*>(p->ptr), _ns1__GetYjzhZskAlarmTypes);
		break;
	case SOAP_TYPE__ns1__GetYjzhZskAlarmTypesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetYjzhZskAlarmTypesResponse*>(p->ptr), _ns1__GetYjzhZskAlarmTypesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetYjzhZskAlarmTypesResponse*>(p->ptr), _ns1__GetYjzhZskAlarmTypesResponse);
		break;
	case SOAP_TYPE___ns1__GetYjzhZskGzFlow:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetYjzhZskGzFlow*>(p->ptr), struct __ns1__GetYjzhZskGzFlow);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetYjzhZskGzFlow*>(p->ptr), struct __ns1__GetYjzhZskGzFlow);
		break;
	case SOAP_TYPE___ns1__GetYjzhZskOtherFlowChartList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetYjzhZskOtherFlowChartList*>(p->ptr), struct __ns1__GetYjzhZskOtherFlowChartList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetYjzhZskOtherFlowChartList*>(p->ptr), struct __ns1__GetYjzhZskOtherFlowChartList);
		break;
	case SOAP_TYPE___ns1__GetYjzhZskDevFlowChartList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetYjzhZskDevFlowChartList*>(p->ptr), struct __ns1__GetYjzhZskDevFlowChartList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetYjzhZskDevFlowChartList*>(p->ptr), struct __ns1__GetYjzhZskDevFlowChartList);
		break;
	case SOAP_TYPE___ns1__GetPropList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetPropList*>(p->ptr), struct __ns1__GetPropList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetPropList*>(p->ptr), struct __ns1__GetPropList);
		break;
	case SOAP_TYPE___ns1__GetPropName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetPropName*>(p->ptr), struct __ns1__GetPropName);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetPropName*>(p->ptr), struct __ns1__GetPropName);
		break;
	case SOAP_TYPE___ns1__CheckLoginUser:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__CheckLoginUser*>(p->ptr), struct __ns1__CheckLoginUser);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__CheckLoginUser*>(p->ptr), struct __ns1__CheckLoginUser);
		break;
	case SOAP_TYPE___ns1__GetRyUnit:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetRyUnit*>(p->ptr), struct __ns1__GetRyUnit);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetRyUnit*>(p->ptr), struct __ns1__GetRyUnit);
		break;
	case SOAP_TYPE___ns1__GetDevCode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetDevCode*>(p->ptr), struct __ns1__GetDevCode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetDevCode*>(p->ptr), struct __ns1__GetDevCode);
		break;
	case SOAP_TYPE___ns1__CheckDevCode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__CheckDevCode*>(p->ptr), struct __ns1__CheckDevCode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__CheckDevCode*>(p->ptr), struct __ns1__CheckDevCode);
		break;
	case SOAP_TYPE___ns1__HelloWorld:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__HelloWorld*>(p->ptr), struct __ns1__HelloWorld);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__HelloWorld*>(p->ptr), struct __ns1__HelloWorld);
		break;
	case SOAP_TYPE___ns1__GetDBString:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetDBString*>(p->ptr), struct __ns1__GetDBString);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetDBString*>(p->ptr), struct __ns1__GetDBString);
		break;
	case SOAP_TYPE___ns1__QueryData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__QueryData*>(p->ptr), struct __ns1__QueryData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__QueryData*>(p->ptr), struct __ns1__QueryData);
		break;
	case SOAP_TYPE___ns1__QueryDataCount:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__QueryDataCount*>(p->ptr), struct __ns1__QueryDataCount);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__QueryDataCount*>(p->ptr), struct __ns1__QueryDataCount);
		break;
	case SOAP_TYPE___ns1__ExecuteSql:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ExecuteSql*>(p->ptr), struct __ns1__ExecuteSql);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ExecuteSql*>(p->ptr), struct __ns1__ExecuteSql);
		break;
	case SOAP_TYPE___ns1__SaveData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__SaveData*>(p->ptr), struct __ns1__SaveData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__SaveData*>(p->ptr), struct __ns1__SaveData);
		break;
	case SOAP_TYPE___ns1__SaveFileData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__SaveFileData*>(p->ptr), struct __ns1__SaveFileData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__SaveFileData*>(p->ptr), struct __ns1__SaveFileData);
		break;
	case SOAP_TYPE___ns1__DownPic:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__DownPic*>(p->ptr), struct __ns1__DownPic);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__DownPic*>(p->ptr), struct __ns1__DownPic);
		break;
	case SOAP_TYPE___ns1__DownAllPic:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__DownAllPic*>(p->ptr), struct __ns1__DownAllPic);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__DownAllPic*>(p->ptr), struct __ns1__DownAllPic);
		break;
	case SOAP_TYPE___ns1__GetGxdataUpTime:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetGxdataUpTime*>(p->ptr), struct __ns1__GetGxdataUpTime);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetGxdataUpTime*>(p->ptr), struct __ns1__GetGxdataUpTime);
		break;
	case SOAP_TYPE___ns1__signedUserInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__signedUserInfo*>(p->ptr), struct __ns1__signedUserInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__signedUserInfo*>(p->ptr), struct __ns1__signedUserInfo);
		break;
	case SOAP_TYPE___ns1__GetOsDateTime:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetOsDateTime*>(p->ptr), struct __ns1__GetOsDateTime);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetOsDateTime*>(p->ptr), struct __ns1__GetOsDateTime);
		break;
	case SOAP_TYPE___ns1__QueryPhotobw:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__QueryPhotobw*>(p->ptr), struct __ns1__QueryPhotobw);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__QueryPhotobw*>(p->ptr), struct __ns1__QueryPhotobw);
		break;
	case SOAP_TYPE___ns1__TcdQuery:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__TcdQuery*>(p->ptr), struct __ns1__TcdQuery);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__TcdQuery*>(p->ptr), struct __ns1__TcdQuery);
		break;
	case SOAP_TYPE___ns1__TcdSendup:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__TcdSendup*>(p->ptr), struct __ns1__TcdSendup);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__TcdSendup*>(p->ptr), struct __ns1__TcdSendup);
		break;
	case SOAP_TYPE___ns1__UpLoadData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__UpLoadData*>(p->ptr), struct __ns1__UpLoadData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__UpLoadData*>(p->ptr), struct __ns1__UpLoadData);
		break;
	case SOAP_TYPE___ns1__ExecuteSqlForColb:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ExecuteSqlForColb*>(p->ptr), struct __ns1__ExecuteSqlForColb);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ExecuteSqlForColb*>(p->ptr), struct __ns1__ExecuteSqlForColb);
		break;
	case SOAP_TYPE___ns1__GetXHYDGLXTupdater:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetXHYDGLXTupdater*>(p->ptr), struct __ns1__GetXHYDGLXTupdater);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetXHYDGLXTupdater*>(p->ptr), struct __ns1__GetXHYDGLXTupdater);
		break;
	case SOAP_TYPE___ns1__GetAPVupdater:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetAPVupdater*>(p->ptr), struct __ns1__GetAPVupdater);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetAPVupdater*>(p->ptr), struct __ns1__GetAPVupdater);
		break;
	case SOAP_TYPE___ns1__UpLoadFile:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__UpLoadFile*>(p->ptr), struct __ns1__UpLoadFile);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__UpLoadFile*>(p->ptr), struct __ns1__UpLoadFile);
		break;
	case SOAP_TYPE___ns1__upPic:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__upPic*>(p->ptr), struct __ns1__upPic);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__upPic*>(p->ptr), struct __ns1__upPic);
		break;
	case SOAP_TYPE___ns1__DownloadPic:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__DownloadPic*>(p->ptr), struct __ns1__DownloadPic);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__DownloadPic*>(p->ptr), struct __ns1__DownloadPic);
		break;
	case SOAP_TYPE___ns1__GetPicNames:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetPicNames*>(p->ptr), struct __ns1__GetPicNames);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetPicNames*>(p->ptr), struct __ns1__GetPicNames);
		break;
	case SOAP_TYPE___ns1__GetDwInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetDwInfo*>(p->ptr), struct __ns1__GetDwInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetDwInfo*>(p->ptr), struct __ns1__GetDwInfo);
		break;
	case SOAP_TYPE___ns1__GetDwPic:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetDwPic*>(p->ptr), struct __ns1__GetDwPic);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetDwPic*>(p->ptr), struct __ns1__GetDwPic);
		break;
	case SOAP_TYPE___ns1__GetDeviceXj:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetDeviceXj*>(p->ptr), struct __ns1__GetDeviceXj);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetDeviceXj*>(p->ptr), struct __ns1__GetDeviceXj);
		break;
	case SOAP_TYPE___ns1__GetJxData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetJxData*>(p->ptr), struct __ns1__GetJxData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetJxData*>(p->ptr), struct __ns1__GetJxData);
		break;
	case SOAP_TYPE___ns1__GetStationJxData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetStationJxData*>(p->ptr), struct __ns1__GetStationJxData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetStationJxData*>(p->ptr), struct __ns1__GetStationJxData);
		break;
	case SOAP_TYPE___ns1__GetJxPic:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetJxPic*>(p->ptr), struct __ns1__GetJxPic);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetJxPic*>(p->ptr), struct __ns1__GetJxPic);
		break;
	case SOAP_TYPE___ns1__GetDevPic:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetDevPic*>(p->ptr), struct __ns1__GetDevPic);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetDevPic*>(p->ptr), struct __ns1__GetDevPic);
		break;
	case SOAP_TYPE___ns1__GetBgImg:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetBgImg*>(p->ptr), struct __ns1__GetBgImg);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetBgImg*>(p->ptr), struct __ns1__GetBgImg);
		break;
	case SOAP_TYPE___ns1__GetDcsData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetDcsData*>(p->ptr), struct __ns1__GetDcsData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetDcsData*>(p->ptr), struct __ns1__GetDcsData);
		break;
	case SOAP_TYPE___ns1__DownLoadMobGPSData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__DownLoadMobGPSData*>(p->ptr), struct __ns1__DownLoadMobGPSData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__DownLoadMobGPSData*>(p->ptr), struct __ns1__DownLoadMobGPSData);
		break;
	case SOAP_TYPE___ns1__MobDownLoadData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__MobDownLoadData*>(p->ptr), struct __ns1__MobDownLoadData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__MobDownLoadData*>(p->ptr), struct __ns1__MobDownLoadData);
		break;
	case SOAP_TYPE___ns1__GetOpenFireInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetOpenFireInfo*>(p->ptr), struct __ns1__GetOpenFireInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetOpenFireInfo*>(p->ptr), struct __ns1__GetOpenFireInfo);
		break;
	case SOAP_TYPE___ns1__GetDwList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetDwList*>(p->ptr), struct __ns1__GetDwList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetDwList*>(p->ptr), struct __ns1__GetDwList);
		break;
	case SOAP_TYPE___ns1__GetUnitStation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetUnitStation*>(p->ptr), struct __ns1__GetUnitStation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetUnitStation*>(p->ptr), struct __ns1__GetUnitStation);
		break;
	case SOAP_TYPE___ns1__GetUnitStruct:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetUnitStruct*>(p->ptr), struct __ns1__GetUnitStruct);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetUnitStruct*>(p->ptr), struct __ns1__GetUnitStruct);
		break;
	case SOAP_TYPE___ns1__GetUnitPersonInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetUnitPersonInfo*>(p->ptr), struct __ns1__GetUnitPersonInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetUnitPersonInfo*>(p->ptr), struct __ns1__GetUnitPersonInfo);
		break;
	case SOAP_TYPE___ns1__GetFileSize:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetFileSize*>(p->ptr), struct __ns1__GetFileSize);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetFileSize*>(p->ptr), struct __ns1__GetFileSize);
		break;
	case SOAP_TYPE___ns1__GetXbList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetXbList*>(p->ptr), struct __ns1__GetXbList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetXbList*>(p->ptr), struct __ns1__GetXbList);
		break;
	case SOAP_TYPE___ns1__GetXbStationList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetXbStationList*>(p->ptr), struct __ns1__GetXbStationList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetXbStationList*>(p->ptr), struct __ns1__GetXbStationList);
		break;
	case SOAP_TYPE___ns1__GetMapDeviceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetMapDeviceType*>(p->ptr), struct __ns1__GetMapDeviceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetMapDeviceType*>(p->ptr), struct __ns1__GetMapDeviceType);
		break;
	case SOAP_TYPE___ns1__GetGxDeviceData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetGxDeviceData*>(p->ptr), struct __ns1__GetGxDeviceData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetGxDeviceData*>(p->ptr), struct __ns1__GetGxDeviceData);
		break;
	case SOAP_TYPE___ns1__GetDownFileInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetDownFileInfo*>(p->ptr), struct __ns1__GetDownFileInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetDownFileInfo*>(p->ptr), struct __ns1__GetDownFileInfo);
		break;
	case SOAP_TYPE___ns1__DownMapfile:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__DownMapfile*>(p->ptr), struct __ns1__DownMapfile);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__DownMapfile*>(p->ptr), struct __ns1__DownMapfile);
		break;
	case SOAP_TYPE___ns1__GetFileNew:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetFileNew*>(p->ptr), struct __ns1__GetFileNew);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetFileNew*>(p->ptr), struct __ns1__GetFileNew);
		break;
	case SOAP_TYPE___ns1__AlterTable:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__AlterTable*>(p->ptr), struct __ns1__AlterTable);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__AlterTable*>(p->ptr), struct __ns1__AlterTable);
		break;
	case SOAP_TYPE___ns1__DownCQData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__DownCQData*>(p->ptr), struct __ns1__DownCQData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__DownCQData*>(p->ptr), struct __ns1__DownCQData);
		break;
	case SOAP_TYPE___ns1__GetTabList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetTabList*>(p->ptr), struct __ns1__GetTabList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetTabList*>(p->ptr), struct __ns1__GetTabList);
		break;
	case SOAP_TYPE___ns1__IsOracleTable:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__IsOracleTable*>(p->ptr), struct __ns1__IsOracleTable);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__IsOracleTable*>(p->ptr), struct __ns1__IsOracleTable);
		break;
	case SOAP_TYPE___ns1__GetFieldInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetFieldInfo*>(p->ptr), struct __ns1__GetFieldInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetFieldInfo*>(p->ptr), struct __ns1__GetFieldInfo);
		break;
	case SOAP_TYPE___ns1__ExecuteSqlForFile:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ExecuteSqlForFile*>(p->ptr), struct __ns1__ExecuteSqlForFile);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ExecuteSqlForFile*>(p->ptr), struct __ns1__ExecuteSqlForFile);
		break;
	case SOAP_TYPE___ns1__DownLoadFile:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__DownLoadFile*>(p->ptr), struct __ns1__DownLoadFile);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__DownLoadFile*>(p->ptr), struct __ns1__DownLoadFile);
		break;
	case SOAP_TYPE___ns1__WriteFile:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__WriteFile*>(p->ptr), struct __ns1__WriteFile);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__WriteFile*>(p->ptr), struct __ns1__WriteFile);
		break;
	case SOAP_TYPE___ns1__GetMapUpdateTime:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetMapUpdateTime*>(p->ptr), struct __ns1__GetMapUpdateTime);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetMapUpdateTime*>(p->ptr), struct __ns1__GetMapUpdateTime);
		break;
	case SOAP_TYPE___ns1__GetMapTabName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetMapTabName*>(p->ptr), struct __ns1__GetMapTabName);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetMapTabName*>(p->ptr), struct __ns1__GetMapTabName);
		break;
	case SOAP_TYPE___ns1__GetMapDeviceData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetMapDeviceData*>(p->ptr), struct __ns1__GetMapDeviceData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetMapDeviceData*>(p->ptr), struct __ns1__GetMapDeviceData);
		break;
	case SOAP_TYPE___ns1__GetMaList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetMaList*>(p->ptr), struct __ns1__GetMaList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetMaList*>(p->ptr), struct __ns1__GetMaList);
		break;
	case SOAP_TYPE___ns1__GetMangeUnit:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetMangeUnit*>(p->ptr), struct __ns1__GetMangeUnit);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetMangeUnit*>(p->ptr), struct __ns1__GetMangeUnit);
		break;
	case SOAP_TYPE___ns1__GetMangeXb:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetMangeXb*>(p->ptr), struct __ns1__GetMangeXb);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetMangeXb*>(p->ptr), struct __ns1__GetMangeXb);
		break;
	case SOAP_TYPE___ns1__CheckMapVer:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__CheckMapVer*>(p->ptr), struct __ns1__CheckMapVer);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__CheckMapVer*>(p->ptr), struct __ns1__CheckMapVer);
		break;
	case SOAP_TYPE___ns1__GetMap:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetMap*>(p->ptr), struct __ns1__GetMap);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetMap*>(p->ptr), struct __ns1__GetMap);
		break;
	case SOAP_TYPE___ns1__GetTableData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetTableData*>(p->ptr), struct __ns1__GetTableData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetTableData*>(p->ptr), struct __ns1__GetTableData);
		break;
	case SOAP_TYPE___ns1__ServerLevel:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ServerLevel*>(p->ptr), struct __ns1__ServerLevel);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ServerLevel*>(p->ptr), struct __ns1__ServerLevel);
		break;
	case SOAP_TYPE___ns1__GetMapListTime:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetMapListTime*>(p->ptr), struct __ns1__GetMapListTime);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetMapListTime*>(p->ptr), struct __ns1__GetMapListTime);
		break;
	case SOAP_TYPE___ns1__UpdateGzclMap:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__UpdateGzclMap*>(p->ptr), struct __ns1__UpdateGzclMap);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__UpdateGzclMap*>(p->ptr), struct __ns1__UpdateGzclMap);
		break;
	case SOAP_TYPE___ns1__GetUnitMapVer:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetUnitMapVer*>(p->ptr), struct __ns1__GetUnitMapVer);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetUnitMapVer*>(p->ptr), struct __ns1__GetUnitMapVer);
		break;
	case SOAP_TYPE___ns1__GetMangeMapUpdate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetMangeMapUpdate*>(p->ptr), struct __ns1__GetMangeMapUpdate);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetMangeMapUpdate*>(p->ptr), struct __ns1__GetMangeMapUpdate);
		break;
	case SOAP_TYPE___ns1__OpenProcess:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__OpenProcess*>(p->ptr), struct __ns1__OpenProcess);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__OpenProcess*>(p->ptr), struct __ns1__OpenProcess);
		break;
	case SOAP_TYPE___ns1__GetEmfPngVer:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetEmfPngVer*>(p->ptr), struct __ns1__GetEmfPngVer);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetEmfPngVer*>(p->ptr), struct __ns1__GetEmfPngVer);
		break;
	case SOAP_TYPE___ns1__GetEmfPngFile:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetEmfPngFile*>(p->ptr), struct __ns1__GetEmfPngFile);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetEmfPngFile*>(p->ptr), struct __ns1__GetEmfPngFile);
		break;
	case SOAP_TYPE___ns1__OpenMapExe:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__OpenMapExe*>(p->ptr), struct __ns1__OpenMapExe);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__OpenMapExe*>(p->ptr), struct __ns1__OpenMapExe);
		break;
	case SOAP_TYPE___ns1__ChaoQi:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ChaoQi*>(p->ptr), struct __ns1__ChaoQi);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ChaoQi*>(p->ptr), struct __ns1__ChaoQi);
		break;
	case SOAP_TYPE___ns1__JiChaoQi:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__JiChaoQi*>(p->ptr), struct __ns1__JiChaoQi);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__JiChaoQi*>(p->ptr), struct __ns1__JiChaoQi);
		break;
	case SOAP_TYPE___ns1__GetZhouQi:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetZhouQi*>(p->ptr), struct __ns1__GetZhouQi);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetZhouQi*>(p->ptr), struct __ns1__GetZhouQi);
		break;
	case SOAP_TYPE___ns1__FlowChartEmf:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__FlowChartEmf*>(p->ptr), struct __ns1__FlowChartEmf);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__FlowChartEmf*>(p->ptr), struct __ns1__FlowChartEmf);
		break;
	case SOAP_TYPE___ns1__SGCDrawEmf:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__SGCDrawEmf*>(p->ptr), struct __ns1__SGCDrawEmf);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__SGCDrawEmf*>(p->ptr), struct __ns1__SGCDrawEmf);
		break;
	case SOAP_TYPE___ns1__GzGetTypeList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GzGetTypeList*>(p->ptr), struct __ns1__GzGetTypeList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GzGetTypeList*>(p->ptr), struct __ns1__GzGetTypeList);
		break;
	case SOAP_TYPE___ns1__GzGetDeviceStruct:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GzGetDeviceStruct*>(p->ptr), struct __ns1__GzGetDeviceStruct);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GzGetDeviceStruct*>(p->ptr), struct __ns1__GzGetDeviceStruct);
		break;
	case SOAP_TYPE___ns1__SaveMapFile:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__SaveMapFile*>(p->ptr), struct __ns1__SaveMapFile);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__SaveMapFile*>(p->ptr), struct __ns1__SaveMapFile);
		break;
	case SOAP_TYPE___ns1__SelectYjzhStation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__SelectYjzhStation*>(p->ptr), struct __ns1__SelectYjzhStation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__SelectYjzhStation*>(p->ptr), struct __ns1__SelectYjzhStation);
		break;
	case SOAP_TYPE___ns1__SelectYjzhDevice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__SelectYjzhDevice*>(p->ptr), struct __ns1__SelectYjzhDevice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__SelectYjzhDevice*>(p->ptr), struct __ns1__SelectYjzhDevice);
		break;
	case SOAP_TYPE___ns1__GetYjzhZskAlarmTypes:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetYjzhZskAlarmTypes*>(p->ptr), struct __ns1__GetYjzhZskAlarmTypes);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetYjzhZskAlarmTypes*>(p->ptr), struct __ns1__GetYjzhZskAlarmTypes);
		break;
	case SOAP_TYPE___ns1__GetYjzhZskGzFlow_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetYjzhZskGzFlow_*>(p->ptr), struct __ns1__GetYjzhZskGzFlow_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetYjzhZskGzFlow_*>(p->ptr), struct __ns1__GetYjzhZskGzFlow_);
		break;
	case SOAP_TYPE___ns1__GetYjzhZskOtherFlowChartList_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetYjzhZskOtherFlowChartList_*>(p->ptr), struct __ns1__GetYjzhZskOtherFlowChartList_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetYjzhZskOtherFlowChartList_*>(p->ptr), struct __ns1__GetYjzhZskOtherFlowChartList_);
		break;
	case SOAP_TYPE___ns1__GetYjzhZskDevFlowChartList_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetYjzhZskDevFlowChartList_*>(p->ptr), struct __ns1__GetYjzhZskDevFlowChartList_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetYjzhZskDevFlowChartList_*>(p->ptr), struct __ns1__GetYjzhZskDevFlowChartList_);
		break;
	case SOAP_TYPE___ns1__GetPropList_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetPropList_*>(p->ptr), struct __ns1__GetPropList_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetPropList_*>(p->ptr), struct __ns1__GetPropList_);
		break;
	case SOAP_TYPE___ns1__GetPropName_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetPropName_*>(p->ptr), struct __ns1__GetPropName_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetPropName_*>(p->ptr), struct __ns1__GetPropName_);
		break;
	case SOAP_TYPE___ns1__CheckLoginUser_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__CheckLoginUser_*>(p->ptr), struct __ns1__CheckLoginUser_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__CheckLoginUser_*>(p->ptr), struct __ns1__CheckLoginUser_);
		break;
	case SOAP_TYPE___ns1__GetRyUnit_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetRyUnit_*>(p->ptr), struct __ns1__GetRyUnit_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetRyUnit_*>(p->ptr), struct __ns1__GetRyUnit_);
		break;
	case SOAP_TYPE___ns1__GetDevCode_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetDevCode_*>(p->ptr), struct __ns1__GetDevCode_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetDevCode_*>(p->ptr), struct __ns1__GetDevCode_);
		break;
	case SOAP_TYPE___ns1__CheckDevCode_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__CheckDevCode_*>(p->ptr), struct __ns1__CheckDevCode_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__CheckDevCode_*>(p->ptr), struct __ns1__CheckDevCode_);
		break;
	case SOAP_TYPE___ns1__HelloWorld_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__HelloWorld_*>(p->ptr), struct __ns1__HelloWorld_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__HelloWorld_*>(p->ptr), struct __ns1__HelloWorld_);
		break;
	case SOAP_TYPE___ns1__GetDBString_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetDBString_*>(p->ptr), struct __ns1__GetDBString_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetDBString_*>(p->ptr), struct __ns1__GetDBString_);
		break;
	case SOAP_TYPE___ns1__QueryData_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__QueryData_*>(p->ptr), struct __ns1__QueryData_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__QueryData_*>(p->ptr), struct __ns1__QueryData_);
		break;
	case SOAP_TYPE___ns1__QueryDataCount_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__QueryDataCount_*>(p->ptr), struct __ns1__QueryDataCount_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__QueryDataCount_*>(p->ptr), struct __ns1__QueryDataCount_);
		break;
	case SOAP_TYPE___ns1__ExecuteSql_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ExecuteSql_*>(p->ptr), struct __ns1__ExecuteSql_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ExecuteSql_*>(p->ptr), struct __ns1__ExecuteSql_);
		break;
	case SOAP_TYPE___ns1__SaveData_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__SaveData_*>(p->ptr), struct __ns1__SaveData_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__SaveData_*>(p->ptr), struct __ns1__SaveData_);
		break;
	case SOAP_TYPE___ns1__SaveFileData_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__SaveFileData_*>(p->ptr), struct __ns1__SaveFileData_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__SaveFileData_*>(p->ptr), struct __ns1__SaveFileData_);
		break;
	case SOAP_TYPE___ns1__DownPic_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__DownPic_*>(p->ptr), struct __ns1__DownPic_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__DownPic_*>(p->ptr), struct __ns1__DownPic_);
		break;
	case SOAP_TYPE___ns1__DownAllPic_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__DownAllPic_*>(p->ptr), struct __ns1__DownAllPic_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__DownAllPic_*>(p->ptr), struct __ns1__DownAllPic_);
		break;
	case SOAP_TYPE___ns1__GetGxdataUpTime_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetGxdataUpTime_*>(p->ptr), struct __ns1__GetGxdataUpTime_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetGxdataUpTime_*>(p->ptr), struct __ns1__GetGxdataUpTime_);
		break;
	case SOAP_TYPE___ns1__signedUserInfo_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__signedUserInfo_*>(p->ptr), struct __ns1__signedUserInfo_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__signedUserInfo_*>(p->ptr), struct __ns1__signedUserInfo_);
		break;
	case SOAP_TYPE___ns1__GetOsDateTime_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetOsDateTime_*>(p->ptr), struct __ns1__GetOsDateTime_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetOsDateTime_*>(p->ptr), struct __ns1__GetOsDateTime_);
		break;
	case SOAP_TYPE___ns1__QueryPhotobw_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__QueryPhotobw_*>(p->ptr), struct __ns1__QueryPhotobw_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__QueryPhotobw_*>(p->ptr), struct __ns1__QueryPhotobw_);
		break;
	case SOAP_TYPE___ns1__TcdQuery_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__TcdQuery_*>(p->ptr), struct __ns1__TcdQuery_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__TcdQuery_*>(p->ptr), struct __ns1__TcdQuery_);
		break;
	case SOAP_TYPE___ns1__TcdSendup_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__TcdSendup_*>(p->ptr), struct __ns1__TcdSendup_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__TcdSendup_*>(p->ptr), struct __ns1__TcdSendup_);
		break;
	case SOAP_TYPE___ns1__UpLoadData_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__UpLoadData_*>(p->ptr), struct __ns1__UpLoadData_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__UpLoadData_*>(p->ptr), struct __ns1__UpLoadData_);
		break;
	case SOAP_TYPE___ns1__ExecuteSqlForColb_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ExecuteSqlForColb_*>(p->ptr), struct __ns1__ExecuteSqlForColb_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ExecuteSqlForColb_*>(p->ptr), struct __ns1__ExecuteSqlForColb_);
		break;
	case SOAP_TYPE___ns1__GetXHYDGLXTupdater_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetXHYDGLXTupdater_*>(p->ptr), struct __ns1__GetXHYDGLXTupdater_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetXHYDGLXTupdater_*>(p->ptr), struct __ns1__GetXHYDGLXTupdater_);
		break;
	case SOAP_TYPE___ns1__GetAPVupdater_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetAPVupdater_*>(p->ptr), struct __ns1__GetAPVupdater_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetAPVupdater_*>(p->ptr), struct __ns1__GetAPVupdater_);
		break;
	case SOAP_TYPE___ns1__UpLoadFile_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__UpLoadFile_*>(p->ptr), struct __ns1__UpLoadFile_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__UpLoadFile_*>(p->ptr), struct __ns1__UpLoadFile_);
		break;
	case SOAP_TYPE___ns1__upPic_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__upPic_*>(p->ptr), struct __ns1__upPic_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__upPic_*>(p->ptr), struct __ns1__upPic_);
		break;
	case SOAP_TYPE___ns1__DownloadPic_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__DownloadPic_*>(p->ptr), struct __ns1__DownloadPic_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__DownloadPic_*>(p->ptr), struct __ns1__DownloadPic_);
		break;
	case SOAP_TYPE___ns1__GetPicNames_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetPicNames_*>(p->ptr), struct __ns1__GetPicNames_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetPicNames_*>(p->ptr), struct __ns1__GetPicNames_);
		break;
	case SOAP_TYPE___ns1__GetDwInfo_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetDwInfo_*>(p->ptr), struct __ns1__GetDwInfo_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetDwInfo_*>(p->ptr), struct __ns1__GetDwInfo_);
		break;
	case SOAP_TYPE___ns1__GetDwPic_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetDwPic_*>(p->ptr), struct __ns1__GetDwPic_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetDwPic_*>(p->ptr), struct __ns1__GetDwPic_);
		break;
	case SOAP_TYPE___ns1__GetDeviceXj_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetDeviceXj_*>(p->ptr), struct __ns1__GetDeviceXj_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetDeviceXj_*>(p->ptr), struct __ns1__GetDeviceXj_);
		break;
	case SOAP_TYPE___ns1__GetJxData_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetJxData_*>(p->ptr), struct __ns1__GetJxData_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetJxData_*>(p->ptr), struct __ns1__GetJxData_);
		break;
	case SOAP_TYPE___ns1__GetStationJxData_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetStationJxData_*>(p->ptr), struct __ns1__GetStationJxData_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetStationJxData_*>(p->ptr), struct __ns1__GetStationJxData_);
		break;
	case SOAP_TYPE___ns1__GetJxPic_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetJxPic_*>(p->ptr), struct __ns1__GetJxPic_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetJxPic_*>(p->ptr), struct __ns1__GetJxPic_);
		break;
	case SOAP_TYPE___ns1__GetDevPic_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetDevPic_*>(p->ptr), struct __ns1__GetDevPic_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetDevPic_*>(p->ptr), struct __ns1__GetDevPic_);
		break;
	case SOAP_TYPE___ns1__GetBgImg_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetBgImg_*>(p->ptr), struct __ns1__GetBgImg_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetBgImg_*>(p->ptr), struct __ns1__GetBgImg_);
		break;
	case SOAP_TYPE___ns1__GetDcsData_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetDcsData_*>(p->ptr), struct __ns1__GetDcsData_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetDcsData_*>(p->ptr), struct __ns1__GetDcsData_);
		break;
	case SOAP_TYPE___ns1__DownLoadMobGPSData_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__DownLoadMobGPSData_*>(p->ptr), struct __ns1__DownLoadMobGPSData_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__DownLoadMobGPSData_*>(p->ptr), struct __ns1__DownLoadMobGPSData_);
		break;
	case SOAP_TYPE___ns1__MobDownLoadData_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__MobDownLoadData_*>(p->ptr), struct __ns1__MobDownLoadData_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__MobDownLoadData_*>(p->ptr), struct __ns1__MobDownLoadData_);
		break;
	case SOAP_TYPE___ns1__GetOpenFireInfo_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetOpenFireInfo_*>(p->ptr), struct __ns1__GetOpenFireInfo_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetOpenFireInfo_*>(p->ptr), struct __ns1__GetOpenFireInfo_);
		break;
	case SOAP_TYPE___ns1__GetDwList_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetDwList_*>(p->ptr), struct __ns1__GetDwList_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetDwList_*>(p->ptr), struct __ns1__GetDwList_);
		break;
	case SOAP_TYPE___ns1__GetUnitStation_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetUnitStation_*>(p->ptr), struct __ns1__GetUnitStation_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetUnitStation_*>(p->ptr), struct __ns1__GetUnitStation_);
		break;
	case SOAP_TYPE___ns1__GetUnitStruct_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetUnitStruct_*>(p->ptr), struct __ns1__GetUnitStruct_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetUnitStruct_*>(p->ptr), struct __ns1__GetUnitStruct_);
		break;
	case SOAP_TYPE___ns1__GetUnitPersonInfo_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetUnitPersonInfo_*>(p->ptr), struct __ns1__GetUnitPersonInfo_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetUnitPersonInfo_*>(p->ptr), struct __ns1__GetUnitPersonInfo_);
		break;
	case SOAP_TYPE___ns1__GetFileSize_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetFileSize_*>(p->ptr), struct __ns1__GetFileSize_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetFileSize_*>(p->ptr), struct __ns1__GetFileSize_);
		break;
	case SOAP_TYPE___ns1__GetXbList_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetXbList_*>(p->ptr), struct __ns1__GetXbList_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetXbList_*>(p->ptr), struct __ns1__GetXbList_);
		break;
	case SOAP_TYPE___ns1__GetXbStationList_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetXbStationList_*>(p->ptr), struct __ns1__GetXbStationList_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetXbStationList_*>(p->ptr), struct __ns1__GetXbStationList_);
		break;
	case SOAP_TYPE___ns1__GetMapDeviceType_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetMapDeviceType_*>(p->ptr), struct __ns1__GetMapDeviceType_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetMapDeviceType_*>(p->ptr), struct __ns1__GetMapDeviceType_);
		break;
	case SOAP_TYPE___ns1__GetGxDeviceData_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetGxDeviceData_*>(p->ptr), struct __ns1__GetGxDeviceData_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetGxDeviceData_*>(p->ptr), struct __ns1__GetGxDeviceData_);
		break;
	case SOAP_TYPE___ns1__GetDownFileInfo_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetDownFileInfo_*>(p->ptr), struct __ns1__GetDownFileInfo_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetDownFileInfo_*>(p->ptr), struct __ns1__GetDownFileInfo_);
		break;
	case SOAP_TYPE___ns1__DownMapfile_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__DownMapfile_*>(p->ptr), struct __ns1__DownMapfile_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__DownMapfile_*>(p->ptr), struct __ns1__DownMapfile_);
		break;
	case SOAP_TYPE___ns1__GetFileNew_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetFileNew_*>(p->ptr), struct __ns1__GetFileNew_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetFileNew_*>(p->ptr), struct __ns1__GetFileNew_);
		break;
	case SOAP_TYPE___ns1__AlterTable_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__AlterTable_*>(p->ptr), struct __ns1__AlterTable_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__AlterTable_*>(p->ptr), struct __ns1__AlterTable_);
		break;
	case SOAP_TYPE___ns1__DownCQData_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__DownCQData_*>(p->ptr), struct __ns1__DownCQData_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__DownCQData_*>(p->ptr), struct __ns1__DownCQData_);
		break;
	case SOAP_TYPE___ns1__GetTabList_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetTabList_*>(p->ptr), struct __ns1__GetTabList_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetTabList_*>(p->ptr), struct __ns1__GetTabList_);
		break;
	case SOAP_TYPE___ns1__IsOracleTable_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__IsOracleTable_*>(p->ptr), struct __ns1__IsOracleTable_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__IsOracleTable_*>(p->ptr), struct __ns1__IsOracleTable_);
		break;
	case SOAP_TYPE___ns1__GetFieldInfo_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetFieldInfo_*>(p->ptr), struct __ns1__GetFieldInfo_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetFieldInfo_*>(p->ptr), struct __ns1__GetFieldInfo_);
		break;
	case SOAP_TYPE___ns1__ExecuteSqlForFile_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ExecuteSqlForFile_*>(p->ptr), struct __ns1__ExecuteSqlForFile_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ExecuteSqlForFile_*>(p->ptr), struct __ns1__ExecuteSqlForFile_);
		break;
	case SOAP_TYPE___ns1__DownLoadFile_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__DownLoadFile_*>(p->ptr), struct __ns1__DownLoadFile_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__DownLoadFile_*>(p->ptr), struct __ns1__DownLoadFile_);
		break;
	case SOAP_TYPE___ns1__WriteFile_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__WriteFile_*>(p->ptr), struct __ns1__WriteFile_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__WriteFile_*>(p->ptr), struct __ns1__WriteFile_);
		break;
	case SOAP_TYPE___ns1__GetMapUpdateTime_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetMapUpdateTime_*>(p->ptr), struct __ns1__GetMapUpdateTime_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetMapUpdateTime_*>(p->ptr), struct __ns1__GetMapUpdateTime_);
		break;
	case SOAP_TYPE___ns1__GetMapTabName_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetMapTabName_*>(p->ptr), struct __ns1__GetMapTabName_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetMapTabName_*>(p->ptr), struct __ns1__GetMapTabName_);
		break;
	case SOAP_TYPE___ns1__GetMapDeviceData_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetMapDeviceData_*>(p->ptr), struct __ns1__GetMapDeviceData_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetMapDeviceData_*>(p->ptr), struct __ns1__GetMapDeviceData_);
		break;
	case SOAP_TYPE___ns1__GetMaList_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetMaList_*>(p->ptr), struct __ns1__GetMaList_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetMaList_*>(p->ptr), struct __ns1__GetMaList_);
		break;
	case SOAP_TYPE___ns1__GetMangeUnit_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetMangeUnit_*>(p->ptr), struct __ns1__GetMangeUnit_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetMangeUnit_*>(p->ptr), struct __ns1__GetMangeUnit_);
		break;
	case SOAP_TYPE___ns1__GetMangeXb_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetMangeXb_*>(p->ptr), struct __ns1__GetMangeXb_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetMangeXb_*>(p->ptr), struct __ns1__GetMangeXb_);
		break;
	case SOAP_TYPE___ns1__CheckMapVer_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__CheckMapVer_*>(p->ptr), struct __ns1__CheckMapVer_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__CheckMapVer_*>(p->ptr), struct __ns1__CheckMapVer_);
		break;
	case SOAP_TYPE___ns1__GetMap_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetMap_*>(p->ptr), struct __ns1__GetMap_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetMap_*>(p->ptr), struct __ns1__GetMap_);
		break;
	case SOAP_TYPE___ns1__GetTableData_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetTableData_*>(p->ptr), struct __ns1__GetTableData_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetTableData_*>(p->ptr), struct __ns1__GetTableData_);
		break;
	case SOAP_TYPE___ns1__ServerLevel_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ServerLevel_*>(p->ptr), struct __ns1__ServerLevel_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ServerLevel_*>(p->ptr), struct __ns1__ServerLevel_);
		break;
	case SOAP_TYPE___ns1__GetMapListTime_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetMapListTime_*>(p->ptr), struct __ns1__GetMapListTime_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetMapListTime_*>(p->ptr), struct __ns1__GetMapListTime_);
		break;
	case SOAP_TYPE___ns1__UpdateGzclMap_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__UpdateGzclMap_*>(p->ptr), struct __ns1__UpdateGzclMap_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__UpdateGzclMap_*>(p->ptr), struct __ns1__UpdateGzclMap_);
		break;
	case SOAP_TYPE___ns1__GetUnitMapVer_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetUnitMapVer_*>(p->ptr), struct __ns1__GetUnitMapVer_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetUnitMapVer_*>(p->ptr), struct __ns1__GetUnitMapVer_);
		break;
	case SOAP_TYPE___ns1__GetMangeMapUpdate_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetMangeMapUpdate_*>(p->ptr), struct __ns1__GetMangeMapUpdate_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetMangeMapUpdate_*>(p->ptr), struct __ns1__GetMangeMapUpdate_);
		break;
	case SOAP_TYPE___ns1__OpenProcess_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__OpenProcess_*>(p->ptr), struct __ns1__OpenProcess_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__OpenProcess_*>(p->ptr), struct __ns1__OpenProcess_);
		break;
	case SOAP_TYPE___ns1__GetEmfPngVer_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetEmfPngVer_*>(p->ptr), struct __ns1__GetEmfPngVer_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetEmfPngVer_*>(p->ptr), struct __ns1__GetEmfPngVer_);
		break;
	case SOAP_TYPE___ns1__GetEmfPngFile_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetEmfPngFile_*>(p->ptr), struct __ns1__GetEmfPngFile_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetEmfPngFile_*>(p->ptr), struct __ns1__GetEmfPngFile_);
		break;
	case SOAP_TYPE___ns1__OpenMapExe_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__OpenMapExe_*>(p->ptr), struct __ns1__OpenMapExe_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__OpenMapExe_*>(p->ptr), struct __ns1__OpenMapExe_);
		break;
	case SOAP_TYPE___ns1__ChaoQi_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ChaoQi_*>(p->ptr), struct __ns1__ChaoQi_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ChaoQi_*>(p->ptr), struct __ns1__ChaoQi_);
		break;
	case SOAP_TYPE___ns1__JiChaoQi_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__JiChaoQi_*>(p->ptr), struct __ns1__JiChaoQi_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__JiChaoQi_*>(p->ptr), struct __ns1__JiChaoQi_);
		break;
	case SOAP_TYPE___ns1__GetZhouQi_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetZhouQi_*>(p->ptr), struct __ns1__GetZhouQi_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetZhouQi_*>(p->ptr), struct __ns1__GetZhouQi_);
		break;
	case SOAP_TYPE___ns1__FlowChartEmf_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__FlowChartEmf_*>(p->ptr), struct __ns1__FlowChartEmf_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__FlowChartEmf_*>(p->ptr), struct __ns1__FlowChartEmf_);
		break;
	case SOAP_TYPE___ns1__SGCDrawEmf_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__SGCDrawEmf_*>(p->ptr), struct __ns1__SGCDrawEmf_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__SGCDrawEmf_*>(p->ptr), struct __ns1__SGCDrawEmf_);
		break;
	case SOAP_TYPE___ns1__GzGetTypeList_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GzGetTypeList_*>(p->ptr), struct __ns1__GzGetTypeList_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GzGetTypeList_*>(p->ptr), struct __ns1__GzGetTypeList_);
		break;
	case SOAP_TYPE___ns1__GzGetDeviceStruct_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GzGetDeviceStruct_*>(p->ptr), struct __ns1__GzGetDeviceStruct_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GzGetDeviceStruct_*>(p->ptr), struct __ns1__GzGetDeviceStruct_);
		break;
	case SOAP_TYPE___ns1__SaveMapFile_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__SaveMapFile_*>(p->ptr), struct __ns1__SaveMapFile_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__SaveMapFile_*>(p->ptr), struct __ns1__SaveMapFile_);
		break;
	case SOAP_TYPE___ns1__SelectYjzhStation_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__SelectYjzhStation_*>(p->ptr), struct __ns1__SelectYjzhStation_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__SelectYjzhStation_*>(p->ptr), struct __ns1__SelectYjzhStation_);
		break;
	case SOAP_TYPE___ns1__SelectYjzhDevice_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__SelectYjzhDevice_*>(p->ptr), struct __ns1__SelectYjzhDevice_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__SelectYjzhDevice_*>(p->ptr), struct __ns1__SelectYjzhDevice_);
		break;
	case SOAP_TYPE___ns1__GetYjzhZskAlarmTypes_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetYjzhZskAlarmTypes_*>(p->ptr), struct __ns1__GetYjzhZskAlarmTypes_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetYjzhZskAlarmTypes_*>(p->ptr), struct __ns1__GetYjzhZskAlarmTypes_);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{	(void)t; (void)b; /* appease -Wall -Werror */
	return 0;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_xsd__base64Binary:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__base64Binary type=%d location=%p object=%p\n", t, p, q));
		*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
		break;
	case SOAP_TYPE_ns1__ArrayOfBase64Binary:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfBase64Binary type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfBase64Binary*)p = *(ns1__ArrayOfBase64Binary*)q;
		break;
	case SOAP_TYPE__ns1__GetYjzhZskGzFlow:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetYjzhZskGzFlow type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetYjzhZskGzFlow*)p = *(_ns1__GetYjzhZskGzFlow*)q;
		break;
	case SOAP_TYPE__ns1__GetYjzhZskGzFlowResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetYjzhZskGzFlowResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetYjzhZskGzFlowResponse*)p = *(_ns1__GetYjzhZskGzFlowResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetYjzhZskOtherFlowChartList type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetYjzhZskOtherFlowChartList*)p = *(_ns1__GetYjzhZskOtherFlowChartList*)q;
		break;
	case SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetYjzhZskOtherFlowChartListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetYjzhZskOtherFlowChartListResponse*)p = *(_ns1__GetYjzhZskOtherFlowChartListResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetYjzhZskDevFlowChartList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetYjzhZskDevFlowChartList type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetYjzhZskDevFlowChartList*)p = *(_ns1__GetYjzhZskDevFlowChartList*)q;
		break;
	case SOAP_TYPE__ns1__GetYjzhZskDevFlowChartListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetYjzhZskDevFlowChartListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetYjzhZskDevFlowChartListResponse*)p = *(_ns1__GetYjzhZskDevFlowChartListResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetPropList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetPropList type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetPropList*)p = *(_ns1__GetPropList*)q;
		break;
	case SOAP_TYPE__ns1__GetPropListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetPropListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetPropListResponse*)p = *(_ns1__GetPropListResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetPropName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetPropName type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetPropName*)p = *(_ns1__GetPropName*)q;
		break;
	case SOAP_TYPE__ns1__GetPropNameResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetPropNameResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetPropNameResponse*)p = *(_ns1__GetPropNameResponse*)q;
		break;
	case SOAP_TYPE__ns1__CheckLoginUser:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CheckLoginUser type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CheckLoginUser*)p = *(_ns1__CheckLoginUser*)q;
		break;
	case SOAP_TYPE__ns1__CheckLoginUserResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CheckLoginUserResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CheckLoginUserResponse*)p = *(_ns1__CheckLoginUserResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetRyUnit:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetRyUnit type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetRyUnit*)p = *(_ns1__GetRyUnit*)q;
		break;
	case SOAP_TYPE__ns1__GetRyUnitResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetRyUnitResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetRyUnitResponse*)p = *(_ns1__GetRyUnitResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetDevCode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetDevCode type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetDevCode*)p = *(_ns1__GetDevCode*)q;
		break;
	case SOAP_TYPE__ns1__GetDevCodeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetDevCodeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetDevCodeResponse*)p = *(_ns1__GetDevCodeResponse*)q;
		break;
	case SOAP_TYPE__ns1__CheckDevCode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CheckDevCode type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CheckDevCode*)p = *(_ns1__CheckDevCode*)q;
		break;
	case SOAP_TYPE__ns1__CheckDevCodeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CheckDevCodeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CheckDevCodeResponse*)p = *(_ns1__CheckDevCodeResponse*)q;
		break;
	case SOAP_TYPE__ns1__HelloWorld:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__HelloWorld type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__HelloWorld*)p = *(_ns1__HelloWorld*)q;
		break;
	case SOAP_TYPE__ns1__HelloWorldResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__HelloWorldResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__HelloWorldResponse*)p = *(_ns1__HelloWorldResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetDBString:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetDBString type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetDBString*)p = *(_ns1__GetDBString*)q;
		break;
	case SOAP_TYPE__ns1__GetDBStringResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetDBStringResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetDBStringResponse*)p = *(_ns1__GetDBStringResponse*)q;
		break;
	case SOAP_TYPE__ns1__QueryData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__QueryData type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__QueryData*)p = *(_ns1__QueryData*)q;
		break;
	case SOAP_TYPE__ns1__QueryDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__QueryDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__QueryDataResponse*)p = *(_ns1__QueryDataResponse*)q;
		break;
	case SOAP_TYPE__ns1__QueryDataCount:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__QueryDataCount type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__QueryDataCount*)p = *(_ns1__QueryDataCount*)q;
		break;
	case SOAP_TYPE__ns1__QueryDataCountResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__QueryDataCountResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__QueryDataCountResponse*)p = *(_ns1__QueryDataCountResponse*)q;
		break;
	case SOAP_TYPE__ns1__ExecuteSql:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ExecuteSql type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ExecuteSql*)p = *(_ns1__ExecuteSql*)q;
		break;
	case SOAP_TYPE__ns1__ExecuteSqlResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ExecuteSqlResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ExecuteSqlResponse*)p = *(_ns1__ExecuteSqlResponse*)q;
		break;
	case SOAP_TYPE__ns1__SaveData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SaveData type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SaveData*)p = *(_ns1__SaveData*)q;
		break;
	case SOAP_TYPE__ns1__SaveDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SaveDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SaveDataResponse*)p = *(_ns1__SaveDataResponse*)q;
		break;
	case SOAP_TYPE__ns1__SaveFileData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SaveFileData type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SaveFileData*)p = *(_ns1__SaveFileData*)q;
		break;
	case SOAP_TYPE__ns1__SaveFileDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SaveFileDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SaveFileDataResponse*)p = *(_ns1__SaveFileDataResponse*)q;
		break;
	case SOAP_TYPE__ns1__DownPic:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DownPic type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DownPic*)p = *(_ns1__DownPic*)q;
		break;
	case SOAP_TYPE__ns1__DownPicResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DownPicResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DownPicResponse*)p = *(_ns1__DownPicResponse*)q;
		break;
	case SOAP_TYPE__ns1__DownAllPic:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DownAllPic type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DownAllPic*)p = *(_ns1__DownAllPic*)q;
		break;
	case SOAP_TYPE__ns1__DownAllPicResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DownAllPicResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DownAllPicResponse*)p = *(_ns1__DownAllPicResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetGxdataUpTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetGxdataUpTime type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetGxdataUpTime*)p = *(_ns1__GetGxdataUpTime*)q;
		break;
	case SOAP_TYPE__ns1__GetGxdataUpTimeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetGxdataUpTimeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetGxdataUpTimeResponse*)p = *(_ns1__GetGxdataUpTimeResponse*)q;
		break;
	case SOAP_TYPE__ns1__signedUserInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__signedUserInfo type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__signedUserInfo*)p = *(_ns1__signedUserInfo*)q;
		break;
	case SOAP_TYPE__ns1__signedUserInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__signedUserInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__signedUserInfoResponse*)p = *(_ns1__signedUserInfoResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetOsDateTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetOsDateTime type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetOsDateTime*)p = *(_ns1__GetOsDateTime*)q;
		break;
	case SOAP_TYPE__ns1__GetOsDateTimeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetOsDateTimeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetOsDateTimeResponse*)p = *(_ns1__GetOsDateTimeResponse*)q;
		break;
	case SOAP_TYPE__ns1__QueryPhotobw:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__QueryPhotobw type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__QueryPhotobw*)p = *(_ns1__QueryPhotobw*)q;
		break;
	case SOAP_TYPE__ns1__QueryPhotobwResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__QueryPhotobwResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__QueryPhotobwResponse*)p = *(_ns1__QueryPhotobwResponse*)q;
		break;
	case SOAP_TYPE__ns1__TcdQuery:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__TcdQuery type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__TcdQuery*)p = *(_ns1__TcdQuery*)q;
		break;
	case SOAP_TYPE__ns1__TcdQueryResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__TcdQueryResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__TcdQueryResponse*)p = *(_ns1__TcdQueryResponse*)q;
		break;
	case SOAP_TYPE__ns1__TcdSendup:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__TcdSendup type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__TcdSendup*)p = *(_ns1__TcdSendup*)q;
		break;
	case SOAP_TYPE__ns1__TcdSendupResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__TcdSendupResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__TcdSendupResponse*)p = *(_ns1__TcdSendupResponse*)q;
		break;
	case SOAP_TYPE__ns1__UpLoadData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UpLoadData type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UpLoadData*)p = *(_ns1__UpLoadData*)q;
		break;
	case SOAP_TYPE__ns1__UpLoadDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UpLoadDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UpLoadDataResponse*)p = *(_ns1__UpLoadDataResponse*)q;
		break;
	case SOAP_TYPE__ns1__ExecuteSqlForColb:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ExecuteSqlForColb type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ExecuteSqlForColb*)p = *(_ns1__ExecuteSqlForColb*)q;
		break;
	case SOAP_TYPE__ns1__ExecuteSqlForColbResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ExecuteSqlForColbResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ExecuteSqlForColbResponse*)p = *(_ns1__ExecuteSqlForColbResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetXHYDGLXTupdater:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetXHYDGLXTupdater type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetXHYDGLXTupdater*)p = *(_ns1__GetXHYDGLXTupdater*)q;
		break;
	case SOAP_TYPE__ns1__GetXHYDGLXTupdaterResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetXHYDGLXTupdaterResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetXHYDGLXTupdaterResponse*)p = *(_ns1__GetXHYDGLXTupdaterResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetAPVupdater:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetAPVupdater type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetAPVupdater*)p = *(_ns1__GetAPVupdater*)q;
		break;
	case SOAP_TYPE__ns1__GetAPVupdaterResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetAPVupdaterResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetAPVupdaterResponse*)p = *(_ns1__GetAPVupdaterResponse*)q;
		break;
	case SOAP_TYPE__ns1__UpLoadFile:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UpLoadFile type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UpLoadFile*)p = *(_ns1__UpLoadFile*)q;
		break;
	case SOAP_TYPE__ns1__UpLoadFileResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UpLoadFileResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UpLoadFileResponse*)p = *(_ns1__UpLoadFileResponse*)q;
		break;
	case SOAP_TYPE__ns1__upPic:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__upPic type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__upPic*)p = *(_ns1__upPic*)q;
		break;
	case SOAP_TYPE__ns1__upPicResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__upPicResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__upPicResponse*)p = *(_ns1__upPicResponse*)q;
		break;
	case SOAP_TYPE__ns1__DownloadPic:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DownloadPic type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DownloadPic*)p = *(_ns1__DownloadPic*)q;
		break;
	case SOAP_TYPE__ns1__DownloadPicResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DownloadPicResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DownloadPicResponse*)p = *(_ns1__DownloadPicResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetPicNames:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetPicNames type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetPicNames*)p = *(_ns1__GetPicNames*)q;
		break;
	case SOAP_TYPE__ns1__GetPicNamesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetPicNamesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetPicNamesResponse*)p = *(_ns1__GetPicNamesResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetDwInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetDwInfo type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetDwInfo*)p = *(_ns1__GetDwInfo*)q;
		break;
	case SOAP_TYPE__ns1__GetDwInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetDwInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetDwInfoResponse*)p = *(_ns1__GetDwInfoResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetDwPic:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetDwPic type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetDwPic*)p = *(_ns1__GetDwPic*)q;
		break;
	case SOAP_TYPE__ns1__GetDwPicResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetDwPicResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetDwPicResponse*)p = *(_ns1__GetDwPicResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetDeviceXj:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetDeviceXj type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetDeviceXj*)p = *(_ns1__GetDeviceXj*)q;
		break;
	case SOAP_TYPE__ns1__GetDeviceXjResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetDeviceXjResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetDeviceXjResponse*)p = *(_ns1__GetDeviceXjResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetJxData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetJxData type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetJxData*)p = *(_ns1__GetJxData*)q;
		break;
	case SOAP_TYPE__ns1__GetJxDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetJxDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetJxDataResponse*)p = *(_ns1__GetJxDataResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetStationJxData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetStationJxData type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetStationJxData*)p = *(_ns1__GetStationJxData*)q;
		break;
	case SOAP_TYPE__ns1__GetStationJxDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetStationJxDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetStationJxDataResponse*)p = *(_ns1__GetStationJxDataResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetJxPic:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetJxPic type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetJxPic*)p = *(_ns1__GetJxPic*)q;
		break;
	case SOAP_TYPE__ns1__GetJxPicResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetJxPicResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetJxPicResponse*)p = *(_ns1__GetJxPicResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetDevPic:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetDevPic type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetDevPic*)p = *(_ns1__GetDevPic*)q;
		break;
	case SOAP_TYPE__ns1__GetDevPicResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetDevPicResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetDevPicResponse*)p = *(_ns1__GetDevPicResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetBgImg:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetBgImg type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetBgImg*)p = *(_ns1__GetBgImg*)q;
		break;
	case SOAP_TYPE__ns1__GetBgImgResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetBgImgResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetBgImgResponse*)p = *(_ns1__GetBgImgResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetDcsData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetDcsData type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetDcsData*)p = *(_ns1__GetDcsData*)q;
		break;
	case SOAP_TYPE__ns1__GetDcsDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetDcsDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetDcsDataResponse*)p = *(_ns1__GetDcsDataResponse*)q;
		break;
	case SOAP_TYPE__ns1__DownLoadMobGPSData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DownLoadMobGPSData type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DownLoadMobGPSData*)p = *(_ns1__DownLoadMobGPSData*)q;
		break;
	case SOAP_TYPE__ns1__DownLoadMobGPSDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DownLoadMobGPSDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DownLoadMobGPSDataResponse*)p = *(_ns1__DownLoadMobGPSDataResponse*)q;
		break;
	case SOAP_TYPE__ns1__MobDownLoadData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__MobDownLoadData type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__MobDownLoadData*)p = *(_ns1__MobDownLoadData*)q;
		break;
	case SOAP_TYPE__ns1__MobDownLoadDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__MobDownLoadDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__MobDownLoadDataResponse*)p = *(_ns1__MobDownLoadDataResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetOpenFireInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetOpenFireInfo type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetOpenFireInfo*)p = *(_ns1__GetOpenFireInfo*)q;
		break;
	case SOAP_TYPE__ns1__GetOpenFireInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetOpenFireInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetOpenFireInfoResponse*)p = *(_ns1__GetOpenFireInfoResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetDwList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetDwList type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetDwList*)p = *(_ns1__GetDwList*)q;
		break;
	case SOAP_TYPE__ns1__GetDwListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetDwListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetDwListResponse*)p = *(_ns1__GetDwListResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetUnitStation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetUnitStation type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetUnitStation*)p = *(_ns1__GetUnitStation*)q;
		break;
	case SOAP_TYPE__ns1__GetUnitStationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetUnitStationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetUnitStationResponse*)p = *(_ns1__GetUnitStationResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetUnitStruct:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetUnitStruct type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetUnitStruct*)p = *(_ns1__GetUnitStruct*)q;
		break;
	case SOAP_TYPE__ns1__GetUnitStructResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetUnitStructResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetUnitStructResponse*)p = *(_ns1__GetUnitStructResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetUnitPersonInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetUnitPersonInfo type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetUnitPersonInfo*)p = *(_ns1__GetUnitPersonInfo*)q;
		break;
	case SOAP_TYPE__ns1__GetUnitPersonInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetUnitPersonInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetUnitPersonInfoResponse*)p = *(_ns1__GetUnitPersonInfoResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetFileSize:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetFileSize type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetFileSize*)p = *(_ns1__GetFileSize*)q;
		break;
	case SOAP_TYPE__ns1__GetFileSizeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetFileSizeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetFileSizeResponse*)p = *(_ns1__GetFileSizeResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetXbList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetXbList type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetXbList*)p = *(_ns1__GetXbList*)q;
		break;
	case SOAP_TYPE__ns1__GetXbListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetXbListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetXbListResponse*)p = *(_ns1__GetXbListResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetXbStationList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetXbStationList type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetXbStationList*)p = *(_ns1__GetXbStationList*)q;
		break;
	case SOAP_TYPE__ns1__GetXbStationListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetXbStationListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetXbStationListResponse*)p = *(_ns1__GetXbStationListResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetMapDeviceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMapDeviceType type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMapDeviceType*)p = *(_ns1__GetMapDeviceType*)q;
		break;
	case SOAP_TYPE__ns1__GetMapDeviceTypeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMapDeviceTypeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMapDeviceTypeResponse*)p = *(_ns1__GetMapDeviceTypeResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetGxDeviceData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetGxDeviceData type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetGxDeviceData*)p = *(_ns1__GetGxDeviceData*)q;
		break;
	case SOAP_TYPE__ns1__GetGxDeviceDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetGxDeviceDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetGxDeviceDataResponse*)p = *(_ns1__GetGxDeviceDataResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetDownFileInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetDownFileInfo type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetDownFileInfo*)p = *(_ns1__GetDownFileInfo*)q;
		break;
	case SOAP_TYPE__ns1__GetDownFileInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetDownFileInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetDownFileInfoResponse*)p = *(_ns1__GetDownFileInfoResponse*)q;
		break;
	case SOAP_TYPE__ns1__DownMapfile:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DownMapfile type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DownMapfile*)p = *(_ns1__DownMapfile*)q;
		break;
	case SOAP_TYPE__ns1__DownMapfileResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DownMapfileResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DownMapfileResponse*)p = *(_ns1__DownMapfileResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetFileNew:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetFileNew type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetFileNew*)p = *(_ns1__GetFileNew*)q;
		break;
	case SOAP_TYPE__ns1__GetFileNewResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetFileNewResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetFileNewResponse*)p = *(_ns1__GetFileNewResponse*)q;
		break;
	case SOAP_TYPE__ns1__AlterTable:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__AlterTable type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__AlterTable*)p = *(_ns1__AlterTable*)q;
		break;
	case SOAP_TYPE__ns1__AlterTableResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__AlterTableResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__AlterTableResponse*)p = *(_ns1__AlterTableResponse*)q;
		break;
	case SOAP_TYPE__ns1__DownCQData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DownCQData type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DownCQData*)p = *(_ns1__DownCQData*)q;
		break;
	case SOAP_TYPE__ns1__DownCQDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DownCQDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DownCQDataResponse*)p = *(_ns1__DownCQDataResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetTabList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetTabList type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetTabList*)p = *(_ns1__GetTabList*)q;
		break;
	case SOAP_TYPE__ns1__GetTabListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetTabListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetTabListResponse*)p = *(_ns1__GetTabListResponse*)q;
		break;
	case SOAP_TYPE__ns1__IsOracleTable:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__IsOracleTable type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__IsOracleTable*)p = *(_ns1__IsOracleTable*)q;
		break;
	case SOAP_TYPE__ns1__IsOracleTableResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__IsOracleTableResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__IsOracleTableResponse*)p = *(_ns1__IsOracleTableResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetFieldInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetFieldInfo type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetFieldInfo*)p = *(_ns1__GetFieldInfo*)q;
		break;
	case SOAP_TYPE__ns1__GetFieldInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetFieldInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetFieldInfoResponse*)p = *(_ns1__GetFieldInfoResponse*)q;
		break;
	case SOAP_TYPE__ns1__ExecuteSqlForFile:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ExecuteSqlForFile type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ExecuteSqlForFile*)p = *(_ns1__ExecuteSqlForFile*)q;
		break;
	case SOAP_TYPE__ns1__ExecuteSqlForFileResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ExecuteSqlForFileResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ExecuteSqlForFileResponse*)p = *(_ns1__ExecuteSqlForFileResponse*)q;
		break;
	case SOAP_TYPE__ns1__DownLoadFile:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DownLoadFile type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DownLoadFile*)p = *(_ns1__DownLoadFile*)q;
		break;
	case SOAP_TYPE__ns1__DownLoadFileResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DownLoadFileResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DownLoadFileResponse*)p = *(_ns1__DownLoadFileResponse*)q;
		break;
	case SOAP_TYPE__ns1__WriteFile:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__WriteFile type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__WriteFile*)p = *(_ns1__WriteFile*)q;
		break;
	case SOAP_TYPE__ns1__WriteFileResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__WriteFileResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__WriteFileResponse*)p = *(_ns1__WriteFileResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetMapUpdateTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMapUpdateTime type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMapUpdateTime*)p = *(_ns1__GetMapUpdateTime*)q;
		break;
	case SOAP_TYPE__ns1__GetMapUpdateTimeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMapUpdateTimeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMapUpdateTimeResponse*)p = *(_ns1__GetMapUpdateTimeResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetMapTabName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMapTabName type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMapTabName*)p = *(_ns1__GetMapTabName*)q;
		break;
	case SOAP_TYPE__ns1__GetMapTabNameResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMapTabNameResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMapTabNameResponse*)p = *(_ns1__GetMapTabNameResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetMapDeviceData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMapDeviceData type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMapDeviceData*)p = *(_ns1__GetMapDeviceData*)q;
		break;
	case SOAP_TYPE__ns1__GetMapDeviceDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMapDeviceDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMapDeviceDataResponse*)p = *(_ns1__GetMapDeviceDataResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetMaList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMaList type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMaList*)p = *(_ns1__GetMaList*)q;
		break;
	case SOAP_TYPE__ns1__GetMaListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMaListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMaListResponse*)p = *(_ns1__GetMaListResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetMangeUnit:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMangeUnit type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMangeUnit*)p = *(_ns1__GetMangeUnit*)q;
		break;
	case SOAP_TYPE__ns1__GetMangeUnitResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMangeUnitResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMangeUnitResponse*)p = *(_ns1__GetMangeUnitResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetMangeXb:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMangeXb type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMangeXb*)p = *(_ns1__GetMangeXb*)q;
		break;
	case SOAP_TYPE__ns1__GetMangeXbResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMangeXbResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMangeXbResponse*)p = *(_ns1__GetMangeXbResponse*)q;
		break;
	case SOAP_TYPE__ns1__CheckMapVer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CheckMapVer type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CheckMapVer*)p = *(_ns1__CheckMapVer*)q;
		break;
	case SOAP_TYPE__ns1__CheckMapVerResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CheckMapVerResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CheckMapVerResponse*)p = *(_ns1__CheckMapVerResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetMap:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMap type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMap*)p = *(_ns1__GetMap*)q;
		break;
	case SOAP_TYPE__ns1__GetMapResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMapResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMapResponse*)p = *(_ns1__GetMapResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetTableData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetTableData type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetTableData*)p = *(_ns1__GetTableData*)q;
		break;
	case SOAP_TYPE__ns1__GetTableDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetTableDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetTableDataResponse*)p = *(_ns1__GetTableDataResponse*)q;
		break;
	case SOAP_TYPE__ns1__ServerLevel:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ServerLevel type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ServerLevel*)p = *(_ns1__ServerLevel*)q;
		break;
	case SOAP_TYPE__ns1__ServerLevelResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ServerLevelResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ServerLevelResponse*)p = *(_ns1__ServerLevelResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetMapListTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMapListTime type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMapListTime*)p = *(_ns1__GetMapListTime*)q;
		break;
	case SOAP_TYPE__ns1__GetMapListTimeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMapListTimeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMapListTimeResponse*)p = *(_ns1__GetMapListTimeResponse*)q;
		break;
	case SOAP_TYPE__ns1__UpdateGzclMap:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UpdateGzclMap type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UpdateGzclMap*)p = *(_ns1__UpdateGzclMap*)q;
		break;
	case SOAP_TYPE__ns1__UpdateGzclMapResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UpdateGzclMapResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UpdateGzclMapResponse*)p = *(_ns1__UpdateGzclMapResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetUnitMapVer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetUnitMapVer type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetUnitMapVer*)p = *(_ns1__GetUnitMapVer*)q;
		break;
	case SOAP_TYPE__ns1__GetUnitMapVerResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetUnitMapVerResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetUnitMapVerResponse*)p = *(_ns1__GetUnitMapVerResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetMangeMapUpdate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMangeMapUpdate type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMangeMapUpdate*)p = *(_ns1__GetMangeMapUpdate*)q;
		break;
	case SOAP_TYPE__ns1__GetMangeMapUpdateResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetMangeMapUpdateResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetMangeMapUpdateResponse*)p = *(_ns1__GetMangeMapUpdateResponse*)q;
		break;
	case SOAP_TYPE__ns1__OpenProcess:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__OpenProcess type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__OpenProcess*)p = *(_ns1__OpenProcess*)q;
		break;
	case SOAP_TYPE__ns1__OpenProcessResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__OpenProcessResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__OpenProcessResponse*)p = *(_ns1__OpenProcessResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetEmfPngVer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetEmfPngVer type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetEmfPngVer*)p = *(_ns1__GetEmfPngVer*)q;
		break;
	case SOAP_TYPE__ns1__GetEmfPngVerResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetEmfPngVerResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetEmfPngVerResponse*)p = *(_ns1__GetEmfPngVerResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetEmfPngFile:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetEmfPngFile type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetEmfPngFile*)p = *(_ns1__GetEmfPngFile*)q;
		break;
	case SOAP_TYPE__ns1__GetEmfPngFileResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetEmfPngFileResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetEmfPngFileResponse*)p = *(_ns1__GetEmfPngFileResponse*)q;
		break;
	case SOAP_TYPE__ns1__OpenMapExe:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__OpenMapExe type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__OpenMapExe*)p = *(_ns1__OpenMapExe*)q;
		break;
	case SOAP_TYPE__ns1__OpenMapExeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__OpenMapExeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__OpenMapExeResponse*)p = *(_ns1__OpenMapExeResponse*)q;
		break;
	case SOAP_TYPE__ns1__ChaoQi:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ChaoQi type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ChaoQi*)p = *(_ns1__ChaoQi*)q;
		break;
	case SOAP_TYPE__ns1__ChaoQiResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ChaoQiResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ChaoQiResponse*)p = *(_ns1__ChaoQiResponse*)q;
		break;
	case SOAP_TYPE__ns1__JiChaoQi:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__JiChaoQi type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__JiChaoQi*)p = *(_ns1__JiChaoQi*)q;
		break;
	case SOAP_TYPE__ns1__JiChaoQiResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__JiChaoQiResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__JiChaoQiResponse*)p = *(_ns1__JiChaoQiResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetZhouQi:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetZhouQi type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetZhouQi*)p = *(_ns1__GetZhouQi*)q;
		break;
	case SOAP_TYPE__ns1__GetZhouQiResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetZhouQiResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetZhouQiResponse*)p = *(_ns1__GetZhouQiResponse*)q;
		break;
	case SOAP_TYPE__ns1__FlowChartEmf:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__FlowChartEmf type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__FlowChartEmf*)p = *(_ns1__FlowChartEmf*)q;
		break;
	case SOAP_TYPE__ns1__FlowChartEmfResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__FlowChartEmfResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__FlowChartEmfResponse*)p = *(_ns1__FlowChartEmfResponse*)q;
		break;
	case SOAP_TYPE__ns1__SGCDrawEmf:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SGCDrawEmf type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SGCDrawEmf*)p = *(_ns1__SGCDrawEmf*)q;
		break;
	case SOAP_TYPE__ns1__SGCDrawEmfResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SGCDrawEmfResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SGCDrawEmfResponse*)p = *(_ns1__SGCDrawEmfResponse*)q;
		break;
	case SOAP_TYPE__ns1__GzGetTypeList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GzGetTypeList type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GzGetTypeList*)p = *(_ns1__GzGetTypeList*)q;
		break;
	case SOAP_TYPE__ns1__GzGetTypeListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GzGetTypeListResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GzGetTypeListResponse*)p = *(_ns1__GzGetTypeListResponse*)q;
		break;
	case SOAP_TYPE__ns1__GzGetDeviceStruct:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GzGetDeviceStruct type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GzGetDeviceStruct*)p = *(_ns1__GzGetDeviceStruct*)q;
		break;
	case SOAP_TYPE__ns1__GzGetDeviceStructResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GzGetDeviceStructResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GzGetDeviceStructResponse*)p = *(_ns1__GzGetDeviceStructResponse*)q;
		break;
	case SOAP_TYPE__ns1__SaveMapFile:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SaveMapFile type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SaveMapFile*)p = *(_ns1__SaveMapFile*)q;
		break;
	case SOAP_TYPE__ns1__SaveMapFileResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SaveMapFileResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SaveMapFileResponse*)p = *(_ns1__SaveMapFileResponse*)q;
		break;
	case SOAP_TYPE__ns1__SelectYjzhStation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SelectYjzhStation type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SelectYjzhStation*)p = *(_ns1__SelectYjzhStation*)q;
		break;
	case SOAP_TYPE__ns1__SelectYjzhStationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SelectYjzhStationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SelectYjzhStationResponse*)p = *(_ns1__SelectYjzhStationResponse*)q;
		break;
	case SOAP_TYPE__ns1__SelectYjzhDevice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SelectYjzhDevice type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SelectYjzhDevice*)p = *(_ns1__SelectYjzhDevice*)q;
		break;
	case SOAP_TYPE__ns1__SelectYjzhDeviceResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SelectYjzhDeviceResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SelectYjzhDeviceResponse*)p = *(_ns1__SelectYjzhDeviceResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetYjzhZskAlarmTypes:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetYjzhZskAlarmTypes type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetYjzhZskAlarmTypes*)p = *(_ns1__GetYjzhZskAlarmTypes*)q;
		break;
	case SOAP_TYPE__ns1__GetYjzhZskAlarmTypesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetYjzhZskAlarmTypesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetYjzhZskAlarmTypesResponse*)p = *(_ns1__GetYjzhZskAlarmTypesResponse*)q;
		break;
	case SOAP_TYPE___ns1__GetYjzhZskGzFlow:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetYjzhZskGzFlow type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetYjzhZskGzFlow*)p = *(struct __ns1__GetYjzhZskGzFlow*)q;
		break;
	case SOAP_TYPE___ns1__GetYjzhZskOtherFlowChartList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetYjzhZskOtherFlowChartList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetYjzhZskOtherFlowChartList*)p = *(struct __ns1__GetYjzhZskOtherFlowChartList*)q;
		break;
	case SOAP_TYPE___ns1__GetYjzhZskDevFlowChartList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetYjzhZskDevFlowChartList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetYjzhZskDevFlowChartList*)p = *(struct __ns1__GetYjzhZskDevFlowChartList*)q;
		break;
	case SOAP_TYPE___ns1__GetPropList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetPropList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetPropList*)p = *(struct __ns1__GetPropList*)q;
		break;
	case SOAP_TYPE___ns1__GetPropName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetPropName type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetPropName*)p = *(struct __ns1__GetPropName*)q;
		break;
	case SOAP_TYPE___ns1__CheckLoginUser:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CheckLoginUser type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CheckLoginUser*)p = *(struct __ns1__CheckLoginUser*)q;
		break;
	case SOAP_TYPE___ns1__GetRyUnit:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetRyUnit type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetRyUnit*)p = *(struct __ns1__GetRyUnit*)q;
		break;
	case SOAP_TYPE___ns1__GetDevCode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetDevCode type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetDevCode*)p = *(struct __ns1__GetDevCode*)q;
		break;
	case SOAP_TYPE___ns1__CheckDevCode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CheckDevCode type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CheckDevCode*)p = *(struct __ns1__CheckDevCode*)q;
		break;
	case SOAP_TYPE___ns1__HelloWorld:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__HelloWorld type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__HelloWorld*)p = *(struct __ns1__HelloWorld*)q;
		break;
	case SOAP_TYPE___ns1__GetDBString:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetDBString type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetDBString*)p = *(struct __ns1__GetDBString*)q;
		break;
	case SOAP_TYPE___ns1__QueryData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QueryData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QueryData*)p = *(struct __ns1__QueryData*)q;
		break;
	case SOAP_TYPE___ns1__QueryDataCount:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QueryDataCount type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QueryDataCount*)p = *(struct __ns1__QueryDataCount*)q;
		break;
	case SOAP_TYPE___ns1__ExecuteSql:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ExecuteSql type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ExecuteSql*)p = *(struct __ns1__ExecuteSql*)q;
		break;
	case SOAP_TYPE___ns1__SaveData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SaveData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SaveData*)p = *(struct __ns1__SaveData*)q;
		break;
	case SOAP_TYPE___ns1__SaveFileData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SaveFileData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SaveFileData*)p = *(struct __ns1__SaveFileData*)q;
		break;
	case SOAP_TYPE___ns1__DownPic:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DownPic type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DownPic*)p = *(struct __ns1__DownPic*)q;
		break;
	case SOAP_TYPE___ns1__DownAllPic:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DownAllPic type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DownAllPic*)p = *(struct __ns1__DownAllPic*)q;
		break;
	case SOAP_TYPE___ns1__GetGxdataUpTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetGxdataUpTime type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetGxdataUpTime*)p = *(struct __ns1__GetGxdataUpTime*)q;
		break;
	case SOAP_TYPE___ns1__signedUserInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__signedUserInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__signedUserInfo*)p = *(struct __ns1__signedUserInfo*)q;
		break;
	case SOAP_TYPE___ns1__GetOsDateTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetOsDateTime type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetOsDateTime*)p = *(struct __ns1__GetOsDateTime*)q;
		break;
	case SOAP_TYPE___ns1__QueryPhotobw:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QueryPhotobw type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QueryPhotobw*)p = *(struct __ns1__QueryPhotobw*)q;
		break;
	case SOAP_TYPE___ns1__TcdQuery:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__TcdQuery type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__TcdQuery*)p = *(struct __ns1__TcdQuery*)q;
		break;
	case SOAP_TYPE___ns1__TcdSendup:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__TcdSendup type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__TcdSendup*)p = *(struct __ns1__TcdSendup*)q;
		break;
	case SOAP_TYPE___ns1__UpLoadData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UpLoadData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UpLoadData*)p = *(struct __ns1__UpLoadData*)q;
		break;
	case SOAP_TYPE___ns1__ExecuteSqlForColb:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ExecuteSqlForColb type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ExecuteSqlForColb*)p = *(struct __ns1__ExecuteSqlForColb*)q;
		break;
	case SOAP_TYPE___ns1__GetXHYDGLXTupdater:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetXHYDGLXTupdater type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetXHYDGLXTupdater*)p = *(struct __ns1__GetXHYDGLXTupdater*)q;
		break;
	case SOAP_TYPE___ns1__GetAPVupdater:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetAPVupdater type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetAPVupdater*)p = *(struct __ns1__GetAPVupdater*)q;
		break;
	case SOAP_TYPE___ns1__UpLoadFile:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UpLoadFile type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UpLoadFile*)p = *(struct __ns1__UpLoadFile*)q;
		break;
	case SOAP_TYPE___ns1__upPic:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__upPic type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__upPic*)p = *(struct __ns1__upPic*)q;
		break;
	case SOAP_TYPE___ns1__DownloadPic:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DownloadPic type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DownloadPic*)p = *(struct __ns1__DownloadPic*)q;
		break;
	case SOAP_TYPE___ns1__GetPicNames:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetPicNames type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetPicNames*)p = *(struct __ns1__GetPicNames*)q;
		break;
	case SOAP_TYPE___ns1__GetDwInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetDwInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetDwInfo*)p = *(struct __ns1__GetDwInfo*)q;
		break;
	case SOAP_TYPE___ns1__GetDwPic:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetDwPic type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetDwPic*)p = *(struct __ns1__GetDwPic*)q;
		break;
	case SOAP_TYPE___ns1__GetDeviceXj:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetDeviceXj type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetDeviceXj*)p = *(struct __ns1__GetDeviceXj*)q;
		break;
	case SOAP_TYPE___ns1__GetJxData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetJxData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetJxData*)p = *(struct __ns1__GetJxData*)q;
		break;
	case SOAP_TYPE___ns1__GetStationJxData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetStationJxData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetStationJxData*)p = *(struct __ns1__GetStationJxData*)q;
		break;
	case SOAP_TYPE___ns1__GetJxPic:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetJxPic type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetJxPic*)p = *(struct __ns1__GetJxPic*)q;
		break;
	case SOAP_TYPE___ns1__GetDevPic:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetDevPic type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetDevPic*)p = *(struct __ns1__GetDevPic*)q;
		break;
	case SOAP_TYPE___ns1__GetBgImg:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetBgImg type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetBgImg*)p = *(struct __ns1__GetBgImg*)q;
		break;
	case SOAP_TYPE___ns1__GetDcsData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetDcsData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetDcsData*)p = *(struct __ns1__GetDcsData*)q;
		break;
	case SOAP_TYPE___ns1__DownLoadMobGPSData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DownLoadMobGPSData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DownLoadMobGPSData*)p = *(struct __ns1__DownLoadMobGPSData*)q;
		break;
	case SOAP_TYPE___ns1__MobDownLoadData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__MobDownLoadData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__MobDownLoadData*)p = *(struct __ns1__MobDownLoadData*)q;
		break;
	case SOAP_TYPE___ns1__GetOpenFireInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetOpenFireInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetOpenFireInfo*)p = *(struct __ns1__GetOpenFireInfo*)q;
		break;
	case SOAP_TYPE___ns1__GetDwList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetDwList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetDwList*)p = *(struct __ns1__GetDwList*)q;
		break;
	case SOAP_TYPE___ns1__GetUnitStation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetUnitStation type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetUnitStation*)p = *(struct __ns1__GetUnitStation*)q;
		break;
	case SOAP_TYPE___ns1__GetUnitStruct:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetUnitStruct type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetUnitStruct*)p = *(struct __ns1__GetUnitStruct*)q;
		break;
	case SOAP_TYPE___ns1__GetUnitPersonInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetUnitPersonInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetUnitPersonInfo*)p = *(struct __ns1__GetUnitPersonInfo*)q;
		break;
	case SOAP_TYPE___ns1__GetFileSize:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetFileSize type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetFileSize*)p = *(struct __ns1__GetFileSize*)q;
		break;
	case SOAP_TYPE___ns1__GetXbList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetXbList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetXbList*)p = *(struct __ns1__GetXbList*)q;
		break;
	case SOAP_TYPE___ns1__GetXbStationList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetXbStationList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetXbStationList*)p = *(struct __ns1__GetXbStationList*)q;
		break;
	case SOAP_TYPE___ns1__GetMapDeviceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMapDeviceType type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMapDeviceType*)p = *(struct __ns1__GetMapDeviceType*)q;
		break;
	case SOAP_TYPE___ns1__GetGxDeviceData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetGxDeviceData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetGxDeviceData*)p = *(struct __ns1__GetGxDeviceData*)q;
		break;
	case SOAP_TYPE___ns1__GetDownFileInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetDownFileInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetDownFileInfo*)p = *(struct __ns1__GetDownFileInfo*)q;
		break;
	case SOAP_TYPE___ns1__DownMapfile:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DownMapfile type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DownMapfile*)p = *(struct __ns1__DownMapfile*)q;
		break;
	case SOAP_TYPE___ns1__GetFileNew:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetFileNew type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetFileNew*)p = *(struct __ns1__GetFileNew*)q;
		break;
	case SOAP_TYPE___ns1__AlterTable:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__AlterTable type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__AlterTable*)p = *(struct __ns1__AlterTable*)q;
		break;
	case SOAP_TYPE___ns1__DownCQData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DownCQData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DownCQData*)p = *(struct __ns1__DownCQData*)q;
		break;
	case SOAP_TYPE___ns1__GetTabList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetTabList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetTabList*)p = *(struct __ns1__GetTabList*)q;
		break;
	case SOAP_TYPE___ns1__IsOracleTable:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__IsOracleTable type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__IsOracleTable*)p = *(struct __ns1__IsOracleTable*)q;
		break;
	case SOAP_TYPE___ns1__GetFieldInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetFieldInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetFieldInfo*)p = *(struct __ns1__GetFieldInfo*)q;
		break;
	case SOAP_TYPE___ns1__ExecuteSqlForFile:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ExecuteSqlForFile type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ExecuteSqlForFile*)p = *(struct __ns1__ExecuteSqlForFile*)q;
		break;
	case SOAP_TYPE___ns1__DownLoadFile:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DownLoadFile type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DownLoadFile*)p = *(struct __ns1__DownLoadFile*)q;
		break;
	case SOAP_TYPE___ns1__WriteFile:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__WriteFile type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__WriteFile*)p = *(struct __ns1__WriteFile*)q;
		break;
	case SOAP_TYPE___ns1__GetMapUpdateTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMapUpdateTime type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMapUpdateTime*)p = *(struct __ns1__GetMapUpdateTime*)q;
		break;
	case SOAP_TYPE___ns1__GetMapTabName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMapTabName type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMapTabName*)p = *(struct __ns1__GetMapTabName*)q;
		break;
	case SOAP_TYPE___ns1__GetMapDeviceData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMapDeviceData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMapDeviceData*)p = *(struct __ns1__GetMapDeviceData*)q;
		break;
	case SOAP_TYPE___ns1__GetMaList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMaList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMaList*)p = *(struct __ns1__GetMaList*)q;
		break;
	case SOAP_TYPE___ns1__GetMangeUnit:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMangeUnit type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMangeUnit*)p = *(struct __ns1__GetMangeUnit*)q;
		break;
	case SOAP_TYPE___ns1__GetMangeXb:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMangeXb type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMangeXb*)p = *(struct __ns1__GetMangeXb*)q;
		break;
	case SOAP_TYPE___ns1__CheckMapVer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CheckMapVer type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CheckMapVer*)p = *(struct __ns1__CheckMapVer*)q;
		break;
	case SOAP_TYPE___ns1__GetMap:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMap type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMap*)p = *(struct __ns1__GetMap*)q;
		break;
	case SOAP_TYPE___ns1__GetTableData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetTableData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetTableData*)p = *(struct __ns1__GetTableData*)q;
		break;
	case SOAP_TYPE___ns1__ServerLevel:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ServerLevel type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ServerLevel*)p = *(struct __ns1__ServerLevel*)q;
		break;
	case SOAP_TYPE___ns1__GetMapListTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMapListTime type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMapListTime*)p = *(struct __ns1__GetMapListTime*)q;
		break;
	case SOAP_TYPE___ns1__UpdateGzclMap:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UpdateGzclMap type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UpdateGzclMap*)p = *(struct __ns1__UpdateGzclMap*)q;
		break;
	case SOAP_TYPE___ns1__GetUnitMapVer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetUnitMapVer type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetUnitMapVer*)p = *(struct __ns1__GetUnitMapVer*)q;
		break;
	case SOAP_TYPE___ns1__GetMangeMapUpdate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMangeMapUpdate type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMangeMapUpdate*)p = *(struct __ns1__GetMangeMapUpdate*)q;
		break;
	case SOAP_TYPE___ns1__OpenProcess:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__OpenProcess type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__OpenProcess*)p = *(struct __ns1__OpenProcess*)q;
		break;
	case SOAP_TYPE___ns1__GetEmfPngVer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetEmfPngVer type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetEmfPngVer*)p = *(struct __ns1__GetEmfPngVer*)q;
		break;
	case SOAP_TYPE___ns1__GetEmfPngFile:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetEmfPngFile type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetEmfPngFile*)p = *(struct __ns1__GetEmfPngFile*)q;
		break;
	case SOAP_TYPE___ns1__OpenMapExe:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__OpenMapExe type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__OpenMapExe*)p = *(struct __ns1__OpenMapExe*)q;
		break;
	case SOAP_TYPE___ns1__ChaoQi:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ChaoQi type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ChaoQi*)p = *(struct __ns1__ChaoQi*)q;
		break;
	case SOAP_TYPE___ns1__JiChaoQi:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__JiChaoQi type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__JiChaoQi*)p = *(struct __ns1__JiChaoQi*)q;
		break;
	case SOAP_TYPE___ns1__GetZhouQi:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetZhouQi type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetZhouQi*)p = *(struct __ns1__GetZhouQi*)q;
		break;
	case SOAP_TYPE___ns1__FlowChartEmf:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__FlowChartEmf type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__FlowChartEmf*)p = *(struct __ns1__FlowChartEmf*)q;
		break;
	case SOAP_TYPE___ns1__SGCDrawEmf:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SGCDrawEmf type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SGCDrawEmf*)p = *(struct __ns1__SGCDrawEmf*)q;
		break;
	case SOAP_TYPE___ns1__GzGetTypeList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GzGetTypeList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GzGetTypeList*)p = *(struct __ns1__GzGetTypeList*)q;
		break;
	case SOAP_TYPE___ns1__GzGetDeviceStruct:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GzGetDeviceStruct type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GzGetDeviceStruct*)p = *(struct __ns1__GzGetDeviceStruct*)q;
		break;
	case SOAP_TYPE___ns1__SaveMapFile:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SaveMapFile type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SaveMapFile*)p = *(struct __ns1__SaveMapFile*)q;
		break;
	case SOAP_TYPE___ns1__SelectYjzhStation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SelectYjzhStation type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SelectYjzhStation*)p = *(struct __ns1__SelectYjzhStation*)q;
		break;
	case SOAP_TYPE___ns1__SelectYjzhDevice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SelectYjzhDevice type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SelectYjzhDevice*)p = *(struct __ns1__SelectYjzhDevice*)q;
		break;
	case SOAP_TYPE___ns1__GetYjzhZskAlarmTypes:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetYjzhZskAlarmTypes type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetYjzhZskAlarmTypes*)p = *(struct __ns1__GetYjzhZskAlarmTypes*)q;
		break;
	case SOAP_TYPE___ns1__GetYjzhZskGzFlow_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetYjzhZskGzFlow_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetYjzhZskGzFlow_*)p = *(struct __ns1__GetYjzhZskGzFlow_*)q;
		break;
	case SOAP_TYPE___ns1__GetYjzhZskOtherFlowChartList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetYjzhZskOtherFlowChartList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetYjzhZskOtherFlowChartList_*)p = *(struct __ns1__GetYjzhZskOtherFlowChartList_*)q;
		break;
	case SOAP_TYPE___ns1__GetYjzhZskDevFlowChartList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetYjzhZskDevFlowChartList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetYjzhZskDevFlowChartList_*)p = *(struct __ns1__GetYjzhZskDevFlowChartList_*)q;
		break;
	case SOAP_TYPE___ns1__GetPropList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetPropList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetPropList_*)p = *(struct __ns1__GetPropList_*)q;
		break;
	case SOAP_TYPE___ns1__GetPropName_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetPropName_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetPropName_*)p = *(struct __ns1__GetPropName_*)q;
		break;
	case SOAP_TYPE___ns1__CheckLoginUser_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CheckLoginUser_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CheckLoginUser_*)p = *(struct __ns1__CheckLoginUser_*)q;
		break;
	case SOAP_TYPE___ns1__GetRyUnit_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetRyUnit_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetRyUnit_*)p = *(struct __ns1__GetRyUnit_*)q;
		break;
	case SOAP_TYPE___ns1__GetDevCode_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetDevCode_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetDevCode_*)p = *(struct __ns1__GetDevCode_*)q;
		break;
	case SOAP_TYPE___ns1__CheckDevCode_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CheckDevCode_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CheckDevCode_*)p = *(struct __ns1__CheckDevCode_*)q;
		break;
	case SOAP_TYPE___ns1__HelloWorld_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__HelloWorld_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__HelloWorld_*)p = *(struct __ns1__HelloWorld_*)q;
		break;
	case SOAP_TYPE___ns1__GetDBString_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetDBString_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetDBString_*)p = *(struct __ns1__GetDBString_*)q;
		break;
	case SOAP_TYPE___ns1__QueryData_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QueryData_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QueryData_*)p = *(struct __ns1__QueryData_*)q;
		break;
	case SOAP_TYPE___ns1__QueryDataCount_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QueryDataCount_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QueryDataCount_*)p = *(struct __ns1__QueryDataCount_*)q;
		break;
	case SOAP_TYPE___ns1__ExecuteSql_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ExecuteSql_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ExecuteSql_*)p = *(struct __ns1__ExecuteSql_*)q;
		break;
	case SOAP_TYPE___ns1__SaveData_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SaveData_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SaveData_*)p = *(struct __ns1__SaveData_*)q;
		break;
	case SOAP_TYPE___ns1__SaveFileData_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SaveFileData_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SaveFileData_*)p = *(struct __ns1__SaveFileData_*)q;
		break;
	case SOAP_TYPE___ns1__DownPic_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DownPic_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DownPic_*)p = *(struct __ns1__DownPic_*)q;
		break;
	case SOAP_TYPE___ns1__DownAllPic_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DownAllPic_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DownAllPic_*)p = *(struct __ns1__DownAllPic_*)q;
		break;
	case SOAP_TYPE___ns1__GetGxdataUpTime_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetGxdataUpTime_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetGxdataUpTime_*)p = *(struct __ns1__GetGxdataUpTime_*)q;
		break;
	case SOAP_TYPE___ns1__signedUserInfo_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__signedUserInfo_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__signedUserInfo_*)p = *(struct __ns1__signedUserInfo_*)q;
		break;
	case SOAP_TYPE___ns1__GetOsDateTime_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetOsDateTime_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetOsDateTime_*)p = *(struct __ns1__GetOsDateTime_*)q;
		break;
	case SOAP_TYPE___ns1__QueryPhotobw_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__QueryPhotobw_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__QueryPhotobw_*)p = *(struct __ns1__QueryPhotobw_*)q;
		break;
	case SOAP_TYPE___ns1__TcdQuery_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__TcdQuery_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__TcdQuery_*)p = *(struct __ns1__TcdQuery_*)q;
		break;
	case SOAP_TYPE___ns1__TcdSendup_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__TcdSendup_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__TcdSendup_*)p = *(struct __ns1__TcdSendup_*)q;
		break;
	case SOAP_TYPE___ns1__UpLoadData_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UpLoadData_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UpLoadData_*)p = *(struct __ns1__UpLoadData_*)q;
		break;
	case SOAP_TYPE___ns1__ExecuteSqlForColb_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ExecuteSqlForColb_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ExecuteSqlForColb_*)p = *(struct __ns1__ExecuteSqlForColb_*)q;
		break;
	case SOAP_TYPE___ns1__GetXHYDGLXTupdater_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetXHYDGLXTupdater_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetXHYDGLXTupdater_*)p = *(struct __ns1__GetXHYDGLXTupdater_*)q;
		break;
	case SOAP_TYPE___ns1__GetAPVupdater_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetAPVupdater_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetAPVupdater_*)p = *(struct __ns1__GetAPVupdater_*)q;
		break;
	case SOAP_TYPE___ns1__UpLoadFile_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UpLoadFile_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UpLoadFile_*)p = *(struct __ns1__UpLoadFile_*)q;
		break;
	case SOAP_TYPE___ns1__upPic_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__upPic_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__upPic_*)p = *(struct __ns1__upPic_*)q;
		break;
	case SOAP_TYPE___ns1__DownloadPic_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DownloadPic_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DownloadPic_*)p = *(struct __ns1__DownloadPic_*)q;
		break;
	case SOAP_TYPE___ns1__GetPicNames_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetPicNames_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetPicNames_*)p = *(struct __ns1__GetPicNames_*)q;
		break;
	case SOAP_TYPE___ns1__GetDwInfo_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetDwInfo_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetDwInfo_*)p = *(struct __ns1__GetDwInfo_*)q;
		break;
	case SOAP_TYPE___ns1__GetDwPic_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetDwPic_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetDwPic_*)p = *(struct __ns1__GetDwPic_*)q;
		break;
	case SOAP_TYPE___ns1__GetDeviceXj_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetDeviceXj_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetDeviceXj_*)p = *(struct __ns1__GetDeviceXj_*)q;
		break;
	case SOAP_TYPE___ns1__GetJxData_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetJxData_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetJxData_*)p = *(struct __ns1__GetJxData_*)q;
		break;
	case SOAP_TYPE___ns1__GetStationJxData_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetStationJxData_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetStationJxData_*)p = *(struct __ns1__GetStationJxData_*)q;
		break;
	case SOAP_TYPE___ns1__GetJxPic_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetJxPic_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetJxPic_*)p = *(struct __ns1__GetJxPic_*)q;
		break;
	case SOAP_TYPE___ns1__GetDevPic_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetDevPic_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetDevPic_*)p = *(struct __ns1__GetDevPic_*)q;
		break;
	case SOAP_TYPE___ns1__GetBgImg_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetBgImg_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetBgImg_*)p = *(struct __ns1__GetBgImg_*)q;
		break;
	case SOAP_TYPE___ns1__GetDcsData_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetDcsData_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetDcsData_*)p = *(struct __ns1__GetDcsData_*)q;
		break;
	case SOAP_TYPE___ns1__DownLoadMobGPSData_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DownLoadMobGPSData_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DownLoadMobGPSData_*)p = *(struct __ns1__DownLoadMobGPSData_*)q;
		break;
	case SOAP_TYPE___ns1__MobDownLoadData_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__MobDownLoadData_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__MobDownLoadData_*)p = *(struct __ns1__MobDownLoadData_*)q;
		break;
	case SOAP_TYPE___ns1__GetOpenFireInfo_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetOpenFireInfo_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetOpenFireInfo_*)p = *(struct __ns1__GetOpenFireInfo_*)q;
		break;
	case SOAP_TYPE___ns1__GetDwList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetDwList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetDwList_*)p = *(struct __ns1__GetDwList_*)q;
		break;
	case SOAP_TYPE___ns1__GetUnitStation_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetUnitStation_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetUnitStation_*)p = *(struct __ns1__GetUnitStation_*)q;
		break;
	case SOAP_TYPE___ns1__GetUnitStruct_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetUnitStruct_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetUnitStruct_*)p = *(struct __ns1__GetUnitStruct_*)q;
		break;
	case SOAP_TYPE___ns1__GetUnitPersonInfo_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetUnitPersonInfo_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetUnitPersonInfo_*)p = *(struct __ns1__GetUnitPersonInfo_*)q;
		break;
	case SOAP_TYPE___ns1__GetFileSize_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetFileSize_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetFileSize_*)p = *(struct __ns1__GetFileSize_*)q;
		break;
	case SOAP_TYPE___ns1__GetXbList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetXbList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetXbList_*)p = *(struct __ns1__GetXbList_*)q;
		break;
	case SOAP_TYPE___ns1__GetXbStationList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetXbStationList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetXbStationList_*)p = *(struct __ns1__GetXbStationList_*)q;
		break;
	case SOAP_TYPE___ns1__GetMapDeviceType_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMapDeviceType_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMapDeviceType_*)p = *(struct __ns1__GetMapDeviceType_*)q;
		break;
	case SOAP_TYPE___ns1__GetGxDeviceData_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetGxDeviceData_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetGxDeviceData_*)p = *(struct __ns1__GetGxDeviceData_*)q;
		break;
	case SOAP_TYPE___ns1__GetDownFileInfo_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetDownFileInfo_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetDownFileInfo_*)p = *(struct __ns1__GetDownFileInfo_*)q;
		break;
	case SOAP_TYPE___ns1__DownMapfile_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DownMapfile_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DownMapfile_*)p = *(struct __ns1__DownMapfile_*)q;
		break;
	case SOAP_TYPE___ns1__GetFileNew_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetFileNew_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetFileNew_*)p = *(struct __ns1__GetFileNew_*)q;
		break;
	case SOAP_TYPE___ns1__AlterTable_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__AlterTable_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__AlterTable_*)p = *(struct __ns1__AlterTable_*)q;
		break;
	case SOAP_TYPE___ns1__DownCQData_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DownCQData_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DownCQData_*)p = *(struct __ns1__DownCQData_*)q;
		break;
	case SOAP_TYPE___ns1__GetTabList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetTabList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetTabList_*)p = *(struct __ns1__GetTabList_*)q;
		break;
	case SOAP_TYPE___ns1__IsOracleTable_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__IsOracleTable_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__IsOracleTable_*)p = *(struct __ns1__IsOracleTable_*)q;
		break;
	case SOAP_TYPE___ns1__GetFieldInfo_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetFieldInfo_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetFieldInfo_*)p = *(struct __ns1__GetFieldInfo_*)q;
		break;
	case SOAP_TYPE___ns1__ExecuteSqlForFile_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ExecuteSqlForFile_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ExecuteSqlForFile_*)p = *(struct __ns1__ExecuteSqlForFile_*)q;
		break;
	case SOAP_TYPE___ns1__DownLoadFile_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DownLoadFile_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DownLoadFile_*)p = *(struct __ns1__DownLoadFile_*)q;
		break;
	case SOAP_TYPE___ns1__WriteFile_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__WriteFile_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__WriteFile_*)p = *(struct __ns1__WriteFile_*)q;
		break;
	case SOAP_TYPE___ns1__GetMapUpdateTime_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMapUpdateTime_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMapUpdateTime_*)p = *(struct __ns1__GetMapUpdateTime_*)q;
		break;
	case SOAP_TYPE___ns1__GetMapTabName_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMapTabName_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMapTabName_*)p = *(struct __ns1__GetMapTabName_*)q;
		break;
	case SOAP_TYPE___ns1__GetMapDeviceData_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMapDeviceData_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMapDeviceData_*)p = *(struct __ns1__GetMapDeviceData_*)q;
		break;
	case SOAP_TYPE___ns1__GetMaList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMaList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMaList_*)p = *(struct __ns1__GetMaList_*)q;
		break;
	case SOAP_TYPE___ns1__GetMangeUnit_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMangeUnit_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMangeUnit_*)p = *(struct __ns1__GetMangeUnit_*)q;
		break;
	case SOAP_TYPE___ns1__GetMangeXb_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMangeXb_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMangeXb_*)p = *(struct __ns1__GetMangeXb_*)q;
		break;
	case SOAP_TYPE___ns1__CheckMapVer_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CheckMapVer_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CheckMapVer_*)p = *(struct __ns1__CheckMapVer_*)q;
		break;
	case SOAP_TYPE___ns1__GetMap_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMap_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMap_*)p = *(struct __ns1__GetMap_*)q;
		break;
	case SOAP_TYPE___ns1__GetTableData_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetTableData_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetTableData_*)p = *(struct __ns1__GetTableData_*)q;
		break;
	case SOAP_TYPE___ns1__ServerLevel_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ServerLevel_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ServerLevel_*)p = *(struct __ns1__ServerLevel_*)q;
		break;
	case SOAP_TYPE___ns1__GetMapListTime_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMapListTime_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMapListTime_*)p = *(struct __ns1__GetMapListTime_*)q;
		break;
	case SOAP_TYPE___ns1__UpdateGzclMap_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UpdateGzclMap_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UpdateGzclMap_*)p = *(struct __ns1__UpdateGzclMap_*)q;
		break;
	case SOAP_TYPE___ns1__GetUnitMapVer_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetUnitMapVer_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetUnitMapVer_*)p = *(struct __ns1__GetUnitMapVer_*)q;
		break;
	case SOAP_TYPE___ns1__GetMangeMapUpdate_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetMangeMapUpdate_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetMangeMapUpdate_*)p = *(struct __ns1__GetMangeMapUpdate_*)q;
		break;
	case SOAP_TYPE___ns1__OpenProcess_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__OpenProcess_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__OpenProcess_*)p = *(struct __ns1__OpenProcess_*)q;
		break;
	case SOAP_TYPE___ns1__GetEmfPngVer_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetEmfPngVer_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetEmfPngVer_*)p = *(struct __ns1__GetEmfPngVer_*)q;
		break;
	case SOAP_TYPE___ns1__GetEmfPngFile_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetEmfPngFile_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetEmfPngFile_*)p = *(struct __ns1__GetEmfPngFile_*)q;
		break;
	case SOAP_TYPE___ns1__OpenMapExe_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__OpenMapExe_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__OpenMapExe_*)p = *(struct __ns1__OpenMapExe_*)q;
		break;
	case SOAP_TYPE___ns1__ChaoQi_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ChaoQi_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ChaoQi_*)p = *(struct __ns1__ChaoQi_*)q;
		break;
	case SOAP_TYPE___ns1__JiChaoQi_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__JiChaoQi_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__JiChaoQi_*)p = *(struct __ns1__JiChaoQi_*)q;
		break;
	case SOAP_TYPE___ns1__GetZhouQi_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetZhouQi_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetZhouQi_*)p = *(struct __ns1__GetZhouQi_*)q;
		break;
	case SOAP_TYPE___ns1__FlowChartEmf_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__FlowChartEmf_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__FlowChartEmf_*)p = *(struct __ns1__FlowChartEmf_*)q;
		break;
	case SOAP_TYPE___ns1__SGCDrawEmf_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SGCDrawEmf_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SGCDrawEmf_*)p = *(struct __ns1__SGCDrawEmf_*)q;
		break;
	case SOAP_TYPE___ns1__GzGetTypeList_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GzGetTypeList_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GzGetTypeList_*)p = *(struct __ns1__GzGetTypeList_*)q;
		break;
	case SOAP_TYPE___ns1__GzGetDeviceStruct_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GzGetDeviceStruct_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GzGetDeviceStruct_*)p = *(struct __ns1__GzGetDeviceStruct_*)q;
		break;
	case SOAP_TYPE___ns1__SaveMapFile_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SaveMapFile_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SaveMapFile_*)p = *(struct __ns1__SaveMapFile_*)q;
		break;
	case SOAP_TYPE___ns1__SelectYjzhStation_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SelectYjzhStation_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SelectYjzhStation_*)p = *(struct __ns1__SelectYjzhStation_*)q;
		break;
	case SOAP_TYPE___ns1__SelectYjzhDevice_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SelectYjzhDevice_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SelectYjzhDevice_*)p = *(struct __ns1__SelectYjzhDevice_*)q;
		break;
	case SOAP_TYPE___ns1__GetYjzhZskAlarmTypes_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetYjzhZskAlarmTypes_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetYjzhZskAlarmTypes_*)p = *(struct __ns1__GetYjzhZskAlarmTypes_*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	a = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return a;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_new_LONG64(struct soap *soap, int n)
{
	LONG64 *a = static_cast<LONG64 *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(LONG64)));
	for (LONG64 *p = a; p && n--; ++p)
		soap_default_LONG64(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	if (soap_out_LONG64(soap, tag ? tag : "long", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	a = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return a;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_new_unsignedByte(struct soap *soap, int n)
{
	unsigned char *a = static_cast<unsigned char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned char)));
	for (unsigned char *p = a; p && n--; ++p)
		soap_default_unsignedByte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	if (soap_out_unsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	a = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return a;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_new_unsignedInt(struct soap *soap, int n)
{
	unsigned int *a = static_cast<unsigned int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned int)));
	for (unsigned int *p = a; p && n--; ++p)
		soap_default_unsignedInt(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out_unsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2bool(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_new_bool(struct soap *soap, int n)
{
	bool *a = static_cast<bool *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(bool)));
	for (bool *p = a; p && n--; ++p)
		soap_default_bool(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetYjzhZskAlarmTypesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetYjzhZskAlarmTypesResponse::GetYjzhZskAlarmTypesResult);
	/* transient soap skipped */
}

void _ns1__GetYjzhZskAlarmTypesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetYjzhZskAlarmTypesResponse::GetYjzhZskAlarmTypesResult);
#endif
}

int _ns1__GetYjzhZskAlarmTypesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetYjzhZskAlarmTypesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetYjzhZskAlarmTypesResponse(struct soap *soap, const char *tag, int id, const _ns1__GetYjzhZskAlarmTypesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetYjzhZskAlarmTypesResponse), type))
		return soap->error;
	if (a->GetYjzhZskAlarmTypesResult)
		soap_element_result(soap, "ns1:GetYjzhZskAlarmTypesResult");
	if (soap_out_string(soap, "ns1:GetYjzhZskAlarmTypesResult", -1, (char*const*)&a->_ns1__GetYjzhZskAlarmTypesResponse::GetYjzhZskAlarmTypesResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetYjzhZskAlarmTypesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetYjzhZskAlarmTypesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetYjzhZskAlarmTypesResponse * SOAP_FMAC4 soap_in__ns1__GetYjzhZskAlarmTypesResponse(struct soap *soap, const char *tag, _ns1__GetYjzhZskAlarmTypesResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetYjzhZskAlarmTypesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetYjzhZskAlarmTypesResponse, sizeof(_ns1__GetYjzhZskAlarmTypesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetYjzhZskAlarmTypesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetYjzhZskAlarmTypesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetYjzhZskAlarmTypesResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetYjzhZskAlarmTypesResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetYjzhZskAlarmTypesResult", (char**)&a->_ns1__GetYjzhZskAlarmTypesResponse::GetYjzhZskAlarmTypesResult, "xsd:string"))
				{	soap_flag_GetYjzhZskAlarmTypesResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetYjzhZskAlarmTypesResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetYjzhZskAlarmTypesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetYjzhZskAlarmTypesResponse, SOAP_TYPE__ns1__GetYjzhZskAlarmTypesResponse, sizeof(_ns1__GetYjzhZskAlarmTypesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetYjzhZskAlarmTypesResponse * SOAP_FMAC2 soap_instantiate__ns1__GetYjzhZskAlarmTypesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetYjzhZskAlarmTypesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetYjzhZskAlarmTypesResponse *p;
	size_t k = sizeof(_ns1__GetYjzhZskAlarmTypesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetYjzhZskAlarmTypesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetYjzhZskAlarmTypesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetYjzhZskAlarmTypesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetYjzhZskAlarmTypesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetYjzhZskAlarmTypesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetYjzhZskAlarmTypesResponse(soap, tag ? tag : "ns1:GetYjzhZskAlarmTypesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetYjzhZskAlarmTypesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetYjzhZskAlarmTypesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetYjzhZskAlarmTypesResponse * SOAP_FMAC4 soap_get__ns1__GetYjzhZskAlarmTypesResponse(struct soap *soap, _ns1__GetYjzhZskAlarmTypesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetYjzhZskAlarmTypesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetYjzhZskAlarmTypes::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetYjzhZskAlarmTypes::xb);
	soap_default_string(soap, &this->_ns1__GetYjzhZskAlarmTypes::cz);
	soap_default_string(soap, &this->_ns1__GetYjzhZskAlarmTypes::devtypeid);
	soap_default_string(soap, &this->_ns1__GetYjzhZskAlarmTypes::devname);
	/* transient soap skipped */
}

void _ns1__GetYjzhZskAlarmTypes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetYjzhZskAlarmTypes::xb);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetYjzhZskAlarmTypes::cz);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetYjzhZskAlarmTypes::devtypeid);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetYjzhZskAlarmTypes::devname);
#endif
}

int _ns1__GetYjzhZskAlarmTypes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetYjzhZskAlarmTypes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetYjzhZskAlarmTypes(struct soap *soap, const char *tag, int id, const _ns1__GetYjzhZskAlarmTypes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetYjzhZskAlarmTypes), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xb", -1, (char*const*)&a->_ns1__GetYjzhZskAlarmTypes::xb, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:cz", -1, (char*const*)&a->_ns1__GetYjzhZskAlarmTypes::cz, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:devtypeid", -1, (char*const*)&a->_ns1__GetYjzhZskAlarmTypes::devtypeid, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:devname", -1, (char*const*)&a->_ns1__GetYjzhZskAlarmTypes::devname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetYjzhZskAlarmTypes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetYjzhZskAlarmTypes(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetYjzhZskAlarmTypes * SOAP_FMAC4 soap_in__ns1__GetYjzhZskAlarmTypes(struct soap *soap, const char *tag, _ns1__GetYjzhZskAlarmTypes *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetYjzhZskAlarmTypes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetYjzhZskAlarmTypes, sizeof(_ns1__GetYjzhZskAlarmTypes), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetYjzhZskAlarmTypes)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetYjzhZskAlarmTypes *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_xb1 = 1;
	size_t soap_flag_cz1 = 1;
	size_t soap_flag_devtypeid1 = 1;
	size_t soap_flag_devname1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:xb", (char**)&a->_ns1__GetYjzhZskAlarmTypes::xb, "xsd:string"))
				{	soap_flag_xb1--;
					continue;
				}
			}
			if (soap_flag_cz1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:cz", (char**)&a->_ns1__GetYjzhZskAlarmTypes::cz, "xsd:string"))
				{	soap_flag_cz1--;
					continue;
				}
			}
			if (soap_flag_devtypeid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:devtypeid", (char**)&a->_ns1__GetYjzhZskAlarmTypes::devtypeid, "xsd:string"))
				{	soap_flag_devtypeid1--;
					continue;
				}
			}
			if (soap_flag_devname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:devname", (char**)&a->_ns1__GetYjzhZskAlarmTypes::devname, "xsd:string"))
				{	soap_flag_devname1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetYjzhZskAlarmTypes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetYjzhZskAlarmTypes, SOAP_TYPE__ns1__GetYjzhZskAlarmTypes, sizeof(_ns1__GetYjzhZskAlarmTypes), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetYjzhZskAlarmTypes * SOAP_FMAC2 soap_instantiate__ns1__GetYjzhZskAlarmTypes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetYjzhZskAlarmTypes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetYjzhZskAlarmTypes *p;
	size_t k = sizeof(_ns1__GetYjzhZskAlarmTypes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetYjzhZskAlarmTypes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetYjzhZskAlarmTypes);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetYjzhZskAlarmTypes, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetYjzhZskAlarmTypes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetYjzhZskAlarmTypes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetYjzhZskAlarmTypes(soap, tag ? tag : "ns1:GetYjzhZskAlarmTypes", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetYjzhZskAlarmTypes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetYjzhZskAlarmTypes(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetYjzhZskAlarmTypes * SOAP_FMAC4 soap_get__ns1__GetYjzhZskAlarmTypes(struct soap *soap, _ns1__GetYjzhZskAlarmTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetYjzhZskAlarmTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SelectYjzhDeviceResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SelectYjzhDeviceResponse::SelectYjzhDeviceResult);
	/* transient soap skipped */
}

void _ns1__SelectYjzhDeviceResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__SelectYjzhDeviceResponse::SelectYjzhDeviceResult);
#endif
}

int _ns1__SelectYjzhDeviceResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SelectYjzhDeviceResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SelectYjzhDeviceResponse(struct soap *soap, const char *tag, int id, const _ns1__SelectYjzhDeviceResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SelectYjzhDeviceResponse), type))
		return soap->error;
	if (a->SelectYjzhDeviceResult)
		soap_element_result(soap, "ns1:SelectYjzhDeviceResult");
	if (soap_out_string(soap, "ns1:SelectYjzhDeviceResult", -1, (char*const*)&a->_ns1__SelectYjzhDeviceResponse::SelectYjzhDeviceResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SelectYjzhDeviceResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SelectYjzhDeviceResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SelectYjzhDeviceResponse * SOAP_FMAC4 soap_in__ns1__SelectYjzhDeviceResponse(struct soap *soap, const char *tag, _ns1__SelectYjzhDeviceResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SelectYjzhDeviceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SelectYjzhDeviceResponse, sizeof(_ns1__SelectYjzhDeviceResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SelectYjzhDeviceResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SelectYjzhDeviceResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SelectYjzhDeviceResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SelectYjzhDeviceResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:SelectYjzhDeviceResult", (char**)&a->_ns1__SelectYjzhDeviceResponse::SelectYjzhDeviceResult, "xsd:string"))
				{	soap_flag_SelectYjzhDeviceResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:SelectYjzhDeviceResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SelectYjzhDeviceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SelectYjzhDeviceResponse, SOAP_TYPE__ns1__SelectYjzhDeviceResponse, sizeof(_ns1__SelectYjzhDeviceResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SelectYjzhDeviceResponse * SOAP_FMAC2 soap_instantiate__ns1__SelectYjzhDeviceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SelectYjzhDeviceResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SelectYjzhDeviceResponse *p;
	size_t k = sizeof(_ns1__SelectYjzhDeviceResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__SelectYjzhDeviceResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__SelectYjzhDeviceResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__SelectYjzhDeviceResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SelectYjzhDeviceResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__SelectYjzhDeviceResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SelectYjzhDeviceResponse(soap, tag ? tag : "ns1:SelectYjzhDeviceResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SelectYjzhDeviceResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SelectYjzhDeviceResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SelectYjzhDeviceResponse * SOAP_FMAC4 soap_get__ns1__SelectYjzhDeviceResponse(struct soap *soap, _ns1__SelectYjzhDeviceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SelectYjzhDeviceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SelectYjzhDevice::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SelectYjzhDevice::xb);
	soap_default_string(soap, &this->_ns1__SelectYjzhDevice::station);
	soap_default_string(soap, &this->_ns1__SelectYjzhDevice::typeid_);
	/* transient soap skipped */
}

void _ns1__SelectYjzhDevice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__SelectYjzhDevice::xb);
	soap_serialize_string(soap, (char*const*)&this->_ns1__SelectYjzhDevice::station);
	soap_serialize_string(soap, (char*const*)&this->_ns1__SelectYjzhDevice::typeid_);
#endif
}

int _ns1__SelectYjzhDevice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SelectYjzhDevice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SelectYjzhDevice(struct soap *soap, const char *tag, int id, const _ns1__SelectYjzhDevice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SelectYjzhDevice), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xb", -1, (char*const*)&a->_ns1__SelectYjzhDevice::xb, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:station", -1, (char*const*)&a->_ns1__SelectYjzhDevice::station, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:typeid", -1, (char*const*)&a->_ns1__SelectYjzhDevice::typeid_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SelectYjzhDevice::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SelectYjzhDevice(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SelectYjzhDevice * SOAP_FMAC4 soap_in__ns1__SelectYjzhDevice(struct soap *soap, const char *tag, _ns1__SelectYjzhDevice *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SelectYjzhDevice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SelectYjzhDevice, sizeof(_ns1__SelectYjzhDevice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SelectYjzhDevice)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SelectYjzhDevice *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_xb1 = 1;
	size_t soap_flag_station1 = 1;
	size_t soap_flag_typeid_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:xb", (char**)&a->_ns1__SelectYjzhDevice::xb, "xsd:string"))
				{	soap_flag_xb1--;
					continue;
				}
			}
			if (soap_flag_station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:station", (char**)&a->_ns1__SelectYjzhDevice::station, "xsd:string"))
				{	soap_flag_station1--;
					continue;
				}
			}
			if (soap_flag_typeid_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:typeid", (char**)&a->_ns1__SelectYjzhDevice::typeid_, "xsd:string"))
				{	soap_flag_typeid_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SelectYjzhDevice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SelectYjzhDevice, SOAP_TYPE__ns1__SelectYjzhDevice, sizeof(_ns1__SelectYjzhDevice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SelectYjzhDevice * SOAP_FMAC2 soap_instantiate__ns1__SelectYjzhDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SelectYjzhDevice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SelectYjzhDevice *p;
	size_t k = sizeof(_ns1__SelectYjzhDevice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__SelectYjzhDevice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__SelectYjzhDevice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__SelectYjzhDevice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SelectYjzhDevice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__SelectYjzhDevice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SelectYjzhDevice(soap, tag ? tag : "ns1:SelectYjzhDevice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SelectYjzhDevice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SelectYjzhDevice(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SelectYjzhDevice * SOAP_FMAC4 soap_get__ns1__SelectYjzhDevice(struct soap *soap, _ns1__SelectYjzhDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SelectYjzhDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SelectYjzhStationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SelectYjzhStationResponse::SelectYjzhStationResult);
	/* transient soap skipped */
}

void _ns1__SelectYjzhStationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__SelectYjzhStationResponse::SelectYjzhStationResult);
#endif
}

int _ns1__SelectYjzhStationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SelectYjzhStationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SelectYjzhStationResponse(struct soap *soap, const char *tag, int id, const _ns1__SelectYjzhStationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SelectYjzhStationResponse), type))
		return soap->error;
	if (a->SelectYjzhStationResult)
		soap_element_result(soap, "ns1:SelectYjzhStationResult");
	if (soap_out_string(soap, "ns1:SelectYjzhStationResult", -1, (char*const*)&a->_ns1__SelectYjzhStationResponse::SelectYjzhStationResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SelectYjzhStationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SelectYjzhStationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SelectYjzhStationResponse * SOAP_FMAC4 soap_in__ns1__SelectYjzhStationResponse(struct soap *soap, const char *tag, _ns1__SelectYjzhStationResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SelectYjzhStationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SelectYjzhStationResponse, sizeof(_ns1__SelectYjzhStationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SelectYjzhStationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SelectYjzhStationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SelectYjzhStationResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SelectYjzhStationResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:SelectYjzhStationResult", (char**)&a->_ns1__SelectYjzhStationResponse::SelectYjzhStationResult, "xsd:string"))
				{	soap_flag_SelectYjzhStationResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:SelectYjzhStationResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SelectYjzhStationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SelectYjzhStationResponse, SOAP_TYPE__ns1__SelectYjzhStationResponse, sizeof(_ns1__SelectYjzhStationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SelectYjzhStationResponse * SOAP_FMAC2 soap_instantiate__ns1__SelectYjzhStationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SelectYjzhStationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SelectYjzhStationResponse *p;
	size_t k = sizeof(_ns1__SelectYjzhStationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__SelectYjzhStationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__SelectYjzhStationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__SelectYjzhStationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SelectYjzhStationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__SelectYjzhStationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SelectYjzhStationResponse(soap, tag ? tag : "ns1:SelectYjzhStationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SelectYjzhStationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SelectYjzhStationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SelectYjzhStationResponse * SOAP_FMAC4 soap_get__ns1__SelectYjzhStationResponse(struct soap *soap, _ns1__SelectYjzhStationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SelectYjzhStationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SelectYjzhStation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SelectYjzhStation::xb);
	/* transient soap skipped */
}

void _ns1__SelectYjzhStation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__SelectYjzhStation::xb);
#endif
}

int _ns1__SelectYjzhStation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SelectYjzhStation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SelectYjzhStation(struct soap *soap, const char *tag, int id, const _ns1__SelectYjzhStation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SelectYjzhStation), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xb", -1, (char*const*)&a->_ns1__SelectYjzhStation::xb, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SelectYjzhStation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SelectYjzhStation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SelectYjzhStation * SOAP_FMAC4 soap_in__ns1__SelectYjzhStation(struct soap *soap, const char *tag, _ns1__SelectYjzhStation *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SelectYjzhStation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SelectYjzhStation, sizeof(_ns1__SelectYjzhStation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SelectYjzhStation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SelectYjzhStation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_xb1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:xb", (char**)&a->_ns1__SelectYjzhStation::xb, "xsd:string"))
				{	soap_flag_xb1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SelectYjzhStation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SelectYjzhStation, SOAP_TYPE__ns1__SelectYjzhStation, sizeof(_ns1__SelectYjzhStation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SelectYjzhStation * SOAP_FMAC2 soap_instantiate__ns1__SelectYjzhStation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SelectYjzhStation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SelectYjzhStation *p;
	size_t k = sizeof(_ns1__SelectYjzhStation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__SelectYjzhStation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__SelectYjzhStation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__SelectYjzhStation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SelectYjzhStation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__SelectYjzhStation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SelectYjzhStation(soap, tag ? tag : "ns1:SelectYjzhStation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SelectYjzhStation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SelectYjzhStation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SelectYjzhStation * SOAP_FMAC4 soap_get__ns1__SelectYjzhStation(struct soap *soap, _ns1__SelectYjzhStation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SelectYjzhStation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SaveMapFileResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SaveMapFileResponse::SaveMapFileResult);
	/* transient soap skipped */
}

void _ns1__SaveMapFileResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__SaveMapFileResponse::SaveMapFileResult);
#endif
}

int _ns1__SaveMapFileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SaveMapFileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SaveMapFileResponse(struct soap *soap, const char *tag, int id, const _ns1__SaveMapFileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SaveMapFileResponse), type))
		return soap->error;
	if (a->SaveMapFileResult)
		soap_element_result(soap, "ns1:SaveMapFileResult");
	if (soap_out_string(soap, "ns1:SaveMapFileResult", -1, (char*const*)&a->_ns1__SaveMapFileResponse::SaveMapFileResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SaveMapFileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SaveMapFileResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SaveMapFileResponse * SOAP_FMAC4 soap_in__ns1__SaveMapFileResponse(struct soap *soap, const char *tag, _ns1__SaveMapFileResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SaveMapFileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SaveMapFileResponse, sizeof(_ns1__SaveMapFileResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SaveMapFileResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SaveMapFileResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SaveMapFileResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SaveMapFileResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:SaveMapFileResult", (char**)&a->_ns1__SaveMapFileResponse::SaveMapFileResult, "xsd:string"))
				{	soap_flag_SaveMapFileResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:SaveMapFileResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SaveMapFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SaveMapFileResponse, SOAP_TYPE__ns1__SaveMapFileResponse, sizeof(_ns1__SaveMapFileResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SaveMapFileResponse * SOAP_FMAC2 soap_instantiate__ns1__SaveMapFileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SaveMapFileResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SaveMapFileResponse *p;
	size_t k = sizeof(_ns1__SaveMapFileResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__SaveMapFileResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__SaveMapFileResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__SaveMapFileResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SaveMapFileResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__SaveMapFileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SaveMapFileResponse(soap, tag ? tag : "ns1:SaveMapFileResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SaveMapFileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SaveMapFileResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SaveMapFileResponse * SOAP_FMAC4 soap_get__ns1__SaveMapFileResponse(struct soap *soap, _ns1__SaveMapFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SaveMapFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SaveMapFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SaveMapFile::Lh);
	soap_default_string(soap, &this->_ns1__SaveMapFile::mapid);
	soap_default_string(soap, &this->_ns1__SaveMapFile::page);
	/* transient soap skipped */
}

void _ns1__SaveMapFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__SaveMapFile::Lh);
	soap_serialize_string(soap, (char*const*)&this->_ns1__SaveMapFile::mapid);
	soap_serialize_string(soap, (char*const*)&this->_ns1__SaveMapFile::page);
#endif
}

int _ns1__SaveMapFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SaveMapFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SaveMapFile(struct soap *soap, const char *tag, int id, const _ns1__SaveMapFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SaveMapFile), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Lh", -1, (char*const*)&a->_ns1__SaveMapFile::Lh, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:mapid", -1, (char*const*)&a->_ns1__SaveMapFile::mapid, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:page", -1, (char*const*)&a->_ns1__SaveMapFile::page, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SaveMapFile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SaveMapFile(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SaveMapFile * SOAP_FMAC4 soap_in__ns1__SaveMapFile(struct soap *soap, const char *tag, _ns1__SaveMapFile *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SaveMapFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SaveMapFile, sizeof(_ns1__SaveMapFile), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SaveMapFile)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SaveMapFile *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Lh1 = 1;
	size_t soap_flag_mapid1 = 1;
	size_t soap_flag_page1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Lh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:Lh", (char**)&a->_ns1__SaveMapFile::Lh, "xsd:string"))
				{	soap_flag_Lh1--;
					continue;
				}
			}
			if (soap_flag_mapid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:mapid", (char**)&a->_ns1__SaveMapFile::mapid, "xsd:string"))
				{	soap_flag_mapid1--;
					continue;
				}
			}
			if (soap_flag_page1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:page", (char**)&a->_ns1__SaveMapFile::page, "xsd:string"))
				{	soap_flag_page1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SaveMapFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SaveMapFile, SOAP_TYPE__ns1__SaveMapFile, sizeof(_ns1__SaveMapFile), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SaveMapFile * SOAP_FMAC2 soap_instantiate__ns1__SaveMapFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SaveMapFile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SaveMapFile *p;
	size_t k = sizeof(_ns1__SaveMapFile);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__SaveMapFile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__SaveMapFile);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__SaveMapFile, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SaveMapFile location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__SaveMapFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SaveMapFile(soap, tag ? tag : "ns1:SaveMapFile", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SaveMapFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SaveMapFile(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SaveMapFile * SOAP_FMAC4 soap_get__ns1__SaveMapFile(struct soap *soap, _ns1__SaveMapFile *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SaveMapFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GzGetDeviceStructResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GzGetDeviceStructResponse::GzGetDeviceStructResult);
	/* transient soap skipped */
}

void _ns1__GzGetDeviceStructResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GzGetDeviceStructResponse::GzGetDeviceStructResult);
#endif
}

int _ns1__GzGetDeviceStructResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GzGetDeviceStructResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GzGetDeviceStructResponse(struct soap *soap, const char *tag, int id, const _ns1__GzGetDeviceStructResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GzGetDeviceStructResponse), type))
		return soap->error;
	if (a->GzGetDeviceStructResult)
		soap_element_result(soap, "ns1:GzGetDeviceStructResult");
	if (soap_out_string(soap, "ns1:GzGetDeviceStructResult", -1, (char*const*)&a->_ns1__GzGetDeviceStructResponse::GzGetDeviceStructResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GzGetDeviceStructResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GzGetDeviceStructResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GzGetDeviceStructResponse * SOAP_FMAC4 soap_in__ns1__GzGetDeviceStructResponse(struct soap *soap, const char *tag, _ns1__GzGetDeviceStructResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GzGetDeviceStructResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GzGetDeviceStructResponse, sizeof(_ns1__GzGetDeviceStructResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GzGetDeviceStructResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GzGetDeviceStructResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GzGetDeviceStructResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GzGetDeviceStructResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GzGetDeviceStructResult", (char**)&a->_ns1__GzGetDeviceStructResponse::GzGetDeviceStructResult, "xsd:string"))
				{	soap_flag_GzGetDeviceStructResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GzGetDeviceStructResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GzGetDeviceStructResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GzGetDeviceStructResponse, SOAP_TYPE__ns1__GzGetDeviceStructResponse, sizeof(_ns1__GzGetDeviceStructResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GzGetDeviceStructResponse * SOAP_FMAC2 soap_instantiate__ns1__GzGetDeviceStructResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GzGetDeviceStructResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GzGetDeviceStructResponse *p;
	size_t k = sizeof(_ns1__GzGetDeviceStructResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GzGetDeviceStructResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GzGetDeviceStructResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GzGetDeviceStructResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GzGetDeviceStructResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GzGetDeviceStructResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GzGetDeviceStructResponse(soap, tag ? tag : "ns1:GzGetDeviceStructResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GzGetDeviceStructResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GzGetDeviceStructResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GzGetDeviceStructResponse * SOAP_FMAC4 soap_get__ns1__GzGetDeviceStructResponse(struct soap *soap, _ns1__GzGetDeviceStructResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GzGetDeviceStructResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GzGetDeviceStruct::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GzGetDeviceStruct::tztype);
	soap_default_string(soap, &this->_ns1__GzGetDeviceStruct::xb);
	soap_default_string(soap, &this->_ns1__GzGetDeviceStruct::station);
	/* transient soap skipped */
}

void _ns1__GzGetDeviceStruct::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GzGetDeviceStruct::tztype);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GzGetDeviceStruct::xb);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GzGetDeviceStruct::station);
#endif
}

int _ns1__GzGetDeviceStruct::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GzGetDeviceStruct(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GzGetDeviceStruct(struct soap *soap, const char *tag, int id, const _ns1__GzGetDeviceStruct *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GzGetDeviceStruct), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:tztype", -1, (char*const*)&a->_ns1__GzGetDeviceStruct::tztype, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:xb", -1, (char*const*)&a->_ns1__GzGetDeviceStruct::xb, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:station", -1, (char*const*)&a->_ns1__GzGetDeviceStruct::station, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GzGetDeviceStruct::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GzGetDeviceStruct(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GzGetDeviceStruct * SOAP_FMAC4 soap_in__ns1__GzGetDeviceStruct(struct soap *soap, const char *tag, _ns1__GzGetDeviceStruct *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GzGetDeviceStruct *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GzGetDeviceStruct, sizeof(_ns1__GzGetDeviceStruct), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GzGetDeviceStruct)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GzGetDeviceStruct *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_tztype1 = 1;
	size_t soap_flag_xb1 = 1;
	size_t soap_flag_station1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tztype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:tztype", (char**)&a->_ns1__GzGetDeviceStruct::tztype, "xsd:string"))
				{	soap_flag_tztype1--;
					continue;
				}
			}
			if (soap_flag_xb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:xb", (char**)&a->_ns1__GzGetDeviceStruct::xb, "xsd:string"))
				{	soap_flag_xb1--;
					continue;
				}
			}
			if (soap_flag_station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:station", (char**)&a->_ns1__GzGetDeviceStruct::station, "xsd:string"))
				{	soap_flag_station1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GzGetDeviceStruct *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GzGetDeviceStruct, SOAP_TYPE__ns1__GzGetDeviceStruct, sizeof(_ns1__GzGetDeviceStruct), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GzGetDeviceStruct * SOAP_FMAC2 soap_instantiate__ns1__GzGetDeviceStruct(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GzGetDeviceStruct(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GzGetDeviceStruct *p;
	size_t k = sizeof(_ns1__GzGetDeviceStruct);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GzGetDeviceStruct, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GzGetDeviceStruct);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GzGetDeviceStruct, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GzGetDeviceStruct location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GzGetDeviceStruct::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GzGetDeviceStruct(soap, tag ? tag : "ns1:GzGetDeviceStruct", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GzGetDeviceStruct::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GzGetDeviceStruct(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GzGetDeviceStruct * SOAP_FMAC4 soap_get__ns1__GzGetDeviceStruct(struct soap *soap, _ns1__GzGetDeviceStruct *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GzGetDeviceStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GzGetTypeListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GzGetTypeListResponse::GzGetTypeListResult);
	/* transient soap skipped */
}

void _ns1__GzGetTypeListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GzGetTypeListResponse::GzGetTypeListResult);
#endif
}

int _ns1__GzGetTypeListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GzGetTypeListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GzGetTypeListResponse(struct soap *soap, const char *tag, int id, const _ns1__GzGetTypeListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GzGetTypeListResponse), type))
		return soap->error;
	if (a->GzGetTypeListResult)
		soap_element_result(soap, "ns1:GzGetTypeListResult");
	if (soap_out_string(soap, "ns1:GzGetTypeListResult", -1, (char*const*)&a->_ns1__GzGetTypeListResponse::GzGetTypeListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GzGetTypeListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GzGetTypeListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GzGetTypeListResponse * SOAP_FMAC4 soap_in__ns1__GzGetTypeListResponse(struct soap *soap, const char *tag, _ns1__GzGetTypeListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GzGetTypeListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GzGetTypeListResponse, sizeof(_ns1__GzGetTypeListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GzGetTypeListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GzGetTypeListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GzGetTypeListResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GzGetTypeListResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GzGetTypeListResult", (char**)&a->_ns1__GzGetTypeListResponse::GzGetTypeListResult, "xsd:string"))
				{	soap_flag_GzGetTypeListResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GzGetTypeListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GzGetTypeListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GzGetTypeListResponse, SOAP_TYPE__ns1__GzGetTypeListResponse, sizeof(_ns1__GzGetTypeListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GzGetTypeListResponse * SOAP_FMAC2 soap_instantiate__ns1__GzGetTypeListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GzGetTypeListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GzGetTypeListResponse *p;
	size_t k = sizeof(_ns1__GzGetTypeListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GzGetTypeListResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GzGetTypeListResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GzGetTypeListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GzGetTypeListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GzGetTypeListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GzGetTypeListResponse(soap, tag ? tag : "ns1:GzGetTypeListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GzGetTypeListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GzGetTypeListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GzGetTypeListResponse * SOAP_FMAC4 soap_get__ns1__GzGetTypeListResponse(struct soap *soap, _ns1__GzGetTypeListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GzGetTypeListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GzGetTypeList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GzGetTypeList::tztype);
	/* transient soap skipped */
}

void _ns1__GzGetTypeList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GzGetTypeList::tztype);
#endif
}

int _ns1__GzGetTypeList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GzGetTypeList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GzGetTypeList(struct soap *soap, const char *tag, int id, const _ns1__GzGetTypeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GzGetTypeList), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:tztype", -1, (char*const*)&a->_ns1__GzGetTypeList::tztype, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GzGetTypeList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GzGetTypeList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GzGetTypeList * SOAP_FMAC4 soap_in__ns1__GzGetTypeList(struct soap *soap, const char *tag, _ns1__GzGetTypeList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GzGetTypeList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GzGetTypeList, sizeof(_ns1__GzGetTypeList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GzGetTypeList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GzGetTypeList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_tztype1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tztype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:tztype", (char**)&a->_ns1__GzGetTypeList::tztype, "xsd:string"))
				{	soap_flag_tztype1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GzGetTypeList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GzGetTypeList, SOAP_TYPE__ns1__GzGetTypeList, sizeof(_ns1__GzGetTypeList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GzGetTypeList * SOAP_FMAC2 soap_instantiate__ns1__GzGetTypeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GzGetTypeList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GzGetTypeList *p;
	size_t k = sizeof(_ns1__GzGetTypeList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GzGetTypeList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GzGetTypeList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GzGetTypeList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GzGetTypeList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GzGetTypeList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GzGetTypeList(soap, tag ? tag : "ns1:GzGetTypeList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GzGetTypeList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GzGetTypeList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GzGetTypeList * SOAP_FMAC4 soap_get__ns1__GzGetTypeList(struct soap *soap, _ns1__GzGetTypeList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GzGetTypeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SGCDrawEmfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SGCDrawEmfResponse::SGCDrawEmfResult);
	/* transient soap skipped */
}

void _ns1__SGCDrawEmfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__SGCDrawEmfResponse::SGCDrawEmfResult);
#endif
}

int _ns1__SGCDrawEmfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SGCDrawEmfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SGCDrawEmfResponse(struct soap *soap, const char *tag, int id, const _ns1__SGCDrawEmfResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SGCDrawEmfResponse), type))
		return soap->error;
	if (a->SGCDrawEmfResult)
		soap_element_result(soap, "ns1:SGCDrawEmfResult");
	if (soap_out_string(soap, "ns1:SGCDrawEmfResult", -1, (char*const*)&a->_ns1__SGCDrawEmfResponse::SGCDrawEmfResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SGCDrawEmfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SGCDrawEmfResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SGCDrawEmfResponse * SOAP_FMAC4 soap_in__ns1__SGCDrawEmfResponse(struct soap *soap, const char *tag, _ns1__SGCDrawEmfResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SGCDrawEmfResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SGCDrawEmfResponse, sizeof(_ns1__SGCDrawEmfResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SGCDrawEmfResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SGCDrawEmfResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SGCDrawEmfResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SGCDrawEmfResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:SGCDrawEmfResult", (char**)&a->_ns1__SGCDrawEmfResponse::SGCDrawEmfResult, "xsd:string"))
				{	soap_flag_SGCDrawEmfResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:SGCDrawEmfResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SGCDrawEmfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SGCDrawEmfResponse, SOAP_TYPE__ns1__SGCDrawEmfResponse, sizeof(_ns1__SGCDrawEmfResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SGCDrawEmfResponse * SOAP_FMAC2 soap_instantiate__ns1__SGCDrawEmfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SGCDrawEmfResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SGCDrawEmfResponse *p;
	size_t k = sizeof(_ns1__SGCDrawEmfResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__SGCDrawEmfResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__SGCDrawEmfResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__SGCDrawEmfResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SGCDrawEmfResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__SGCDrawEmfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SGCDrawEmfResponse(soap, tag ? tag : "ns1:SGCDrawEmfResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SGCDrawEmfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SGCDrawEmfResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SGCDrawEmfResponse * SOAP_FMAC4 soap_get__ns1__SGCDrawEmfResponse(struct soap *soap, _ns1__SGCDrawEmfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SGCDrawEmfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SGCDrawEmf::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SGCDrawEmf::guid);
	soap_default_string(soap, &this->_ns1__SGCDrawEmf::rel);
	/* transient soap skipped */
}

void _ns1__SGCDrawEmf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__SGCDrawEmf::guid);
	soap_serialize_string(soap, (char*const*)&this->_ns1__SGCDrawEmf::rel);
#endif
}

int _ns1__SGCDrawEmf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SGCDrawEmf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SGCDrawEmf(struct soap *soap, const char *tag, int id, const _ns1__SGCDrawEmf *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SGCDrawEmf), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:guid", -1, (char*const*)&a->_ns1__SGCDrawEmf::guid, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:rel", -1, (char*const*)&a->_ns1__SGCDrawEmf::rel, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SGCDrawEmf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SGCDrawEmf(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SGCDrawEmf * SOAP_FMAC4 soap_in__ns1__SGCDrawEmf(struct soap *soap, const char *tag, _ns1__SGCDrawEmf *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SGCDrawEmf *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SGCDrawEmf, sizeof(_ns1__SGCDrawEmf), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SGCDrawEmf)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SGCDrawEmf *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_guid1 = 1;
	size_t soap_flag_rel1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:guid", (char**)&a->_ns1__SGCDrawEmf::guid, "xsd:string"))
				{	soap_flag_guid1--;
					continue;
				}
			}
			if (soap_flag_rel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:rel", (char**)&a->_ns1__SGCDrawEmf::rel, "xsd:string"))
				{	soap_flag_rel1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SGCDrawEmf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SGCDrawEmf, SOAP_TYPE__ns1__SGCDrawEmf, sizeof(_ns1__SGCDrawEmf), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SGCDrawEmf * SOAP_FMAC2 soap_instantiate__ns1__SGCDrawEmf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SGCDrawEmf(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SGCDrawEmf *p;
	size_t k = sizeof(_ns1__SGCDrawEmf);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__SGCDrawEmf, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__SGCDrawEmf);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__SGCDrawEmf, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SGCDrawEmf location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__SGCDrawEmf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SGCDrawEmf(soap, tag ? tag : "ns1:SGCDrawEmf", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SGCDrawEmf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SGCDrawEmf(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SGCDrawEmf * SOAP_FMAC4 soap_get__ns1__SGCDrawEmf(struct soap *soap, _ns1__SGCDrawEmf *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SGCDrawEmf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__FlowChartEmfResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__FlowChartEmfResponse::FlowChartEmfResult);
	/* transient soap skipped */
}

void _ns1__FlowChartEmfResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__FlowChartEmfResponse::FlowChartEmfResult);
#endif
}

int _ns1__FlowChartEmfResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__FlowChartEmfResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__FlowChartEmfResponse(struct soap *soap, const char *tag, int id, const _ns1__FlowChartEmfResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__FlowChartEmfResponse), type))
		return soap->error;
	if (a->FlowChartEmfResult)
		soap_element_result(soap, "ns1:FlowChartEmfResult");
	if (soap_out_string(soap, "ns1:FlowChartEmfResult", -1, (char*const*)&a->_ns1__FlowChartEmfResponse::FlowChartEmfResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__FlowChartEmfResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__FlowChartEmfResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__FlowChartEmfResponse * SOAP_FMAC4 soap_in__ns1__FlowChartEmfResponse(struct soap *soap, const char *tag, _ns1__FlowChartEmfResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__FlowChartEmfResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__FlowChartEmfResponse, sizeof(_ns1__FlowChartEmfResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__FlowChartEmfResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__FlowChartEmfResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FlowChartEmfResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FlowChartEmfResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:FlowChartEmfResult", (char**)&a->_ns1__FlowChartEmfResponse::FlowChartEmfResult, "xsd:string"))
				{	soap_flag_FlowChartEmfResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:FlowChartEmfResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__FlowChartEmfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__FlowChartEmfResponse, SOAP_TYPE__ns1__FlowChartEmfResponse, sizeof(_ns1__FlowChartEmfResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__FlowChartEmfResponse * SOAP_FMAC2 soap_instantiate__ns1__FlowChartEmfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__FlowChartEmfResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__FlowChartEmfResponse *p;
	size_t k = sizeof(_ns1__FlowChartEmfResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__FlowChartEmfResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__FlowChartEmfResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__FlowChartEmfResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__FlowChartEmfResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__FlowChartEmfResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__FlowChartEmfResponse(soap, tag ? tag : "ns1:FlowChartEmfResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__FlowChartEmfResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__FlowChartEmfResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__FlowChartEmfResponse * SOAP_FMAC4 soap_get__ns1__FlowChartEmfResponse(struct soap *soap, _ns1__FlowChartEmfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__FlowChartEmfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__FlowChartEmf::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__FlowChartEmf::guid);
	/* transient soap skipped */
}

void _ns1__FlowChartEmf::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__FlowChartEmf::guid);
#endif
}

int _ns1__FlowChartEmf::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__FlowChartEmf(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__FlowChartEmf(struct soap *soap, const char *tag, int id, const _ns1__FlowChartEmf *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__FlowChartEmf), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:guid", -1, (char*const*)&a->_ns1__FlowChartEmf::guid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__FlowChartEmf::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__FlowChartEmf(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__FlowChartEmf * SOAP_FMAC4 soap_in__ns1__FlowChartEmf(struct soap *soap, const char *tag, _ns1__FlowChartEmf *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__FlowChartEmf *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__FlowChartEmf, sizeof(_ns1__FlowChartEmf), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__FlowChartEmf)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__FlowChartEmf *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_guid1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:guid", (char**)&a->_ns1__FlowChartEmf::guid, "xsd:string"))
				{	soap_flag_guid1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__FlowChartEmf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__FlowChartEmf, SOAP_TYPE__ns1__FlowChartEmf, sizeof(_ns1__FlowChartEmf), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__FlowChartEmf * SOAP_FMAC2 soap_instantiate__ns1__FlowChartEmf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__FlowChartEmf(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__FlowChartEmf *p;
	size_t k = sizeof(_ns1__FlowChartEmf);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__FlowChartEmf, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__FlowChartEmf);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__FlowChartEmf, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__FlowChartEmf location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__FlowChartEmf::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__FlowChartEmf(soap, tag ? tag : "ns1:FlowChartEmf", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__FlowChartEmf::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__FlowChartEmf(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__FlowChartEmf * SOAP_FMAC4 soap_get__ns1__FlowChartEmf(struct soap *soap, _ns1__FlowChartEmf *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__FlowChartEmf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetZhouQiResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetZhouQiResponse::GetZhouQiResult);
	/* transient soap skipped */
}

void _ns1__GetZhouQiResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetZhouQiResponse::GetZhouQiResult);
#endif
}

int _ns1__GetZhouQiResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetZhouQiResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetZhouQiResponse(struct soap *soap, const char *tag, int id, const _ns1__GetZhouQiResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetZhouQiResponse), type))
		return soap->error;
	if (a->GetZhouQiResult)
		soap_element_result(soap, "ns1:GetZhouQiResult");
	if (soap_out_string(soap, "ns1:GetZhouQiResult", -1, (char*const*)&a->_ns1__GetZhouQiResponse::GetZhouQiResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetZhouQiResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetZhouQiResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetZhouQiResponse * SOAP_FMAC4 soap_in__ns1__GetZhouQiResponse(struct soap *soap, const char *tag, _ns1__GetZhouQiResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetZhouQiResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetZhouQiResponse, sizeof(_ns1__GetZhouQiResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetZhouQiResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetZhouQiResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetZhouQiResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetZhouQiResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetZhouQiResult", (char**)&a->_ns1__GetZhouQiResponse::GetZhouQiResult, "xsd:string"))
				{	soap_flag_GetZhouQiResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetZhouQiResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetZhouQiResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetZhouQiResponse, SOAP_TYPE__ns1__GetZhouQiResponse, sizeof(_ns1__GetZhouQiResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetZhouQiResponse * SOAP_FMAC2 soap_instantiate__ns1__GetZhouQiResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetZhouQiResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetZhouQiResponse *p;
	size_t k = sizeof(_ns1__GetZhouQiResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetZhouQiResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetZhouQiResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetZhouQiResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetZhouQiResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetZhouQiResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetZhouQiResponse(soap, tag ? tag : "ns1:GetZhouQiResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetZhouQiResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetZhouQiResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetZhouQiResponse * SOAP_FMAC4 soap_get__ns1__GetZhouQiResponse(struct soap *soap, _ns1__GetZhouQiResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetZhouQiResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetZhouQi::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetZhouQi::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetZhouQi::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetZhouQi(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetZhouQi(struct soap *soap, const char *tag, int id, const _ns1__GetZhouQi *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetZhouQi), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetZhouQi::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetZhouQi(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetZhouQi * SOAP_FMAC4 soap_in__ns1__GetZhouQi(struct soap *soap, const char *tag, _ns1__GetZhouQi *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetZhouQi *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetZhouQi, sizeof(_ns1__GetZhouQi), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetZhouQi)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetZhouQi *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetZhouQi *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetZhouQi, SOAP_TYPE__ns1__GetZhouQi, sizeof(_ns1__GetZhouQi), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetZhouQi * SOAP_FMAC2 soap_instantiate__ns1__GetZhouQi(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetZhouQi(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetZhouQi *p;
	size_t k = sizeof(_ns1__GetZhouQi);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetZhouQi, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetZhouQi);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetZhouQi, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetZhouQi location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetZhouQi::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetZhouQi(soap, tag ? tag : "ns1:GetZhouQi", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetZhouQi::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetZhouQi(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetZhouQi * SOAP_FMAC4 soap_get__ns1__GetZhouQi(struct soap *soap, _ns1__GetZhouQi *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetZhouQi(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__JiChaoQiResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__JiChaoQiResponse::JiChaoQiResult);
	/* transient soap skipped */
}

void _ns1__JiChaoQiResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__JiChaoQiResponse::JiChaoQiResult);
#endif
}

int _ns1__JiChaoQiResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__JiChaoQiResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__JiChaoQiResponse(struct soap *soap, const char *tag, int id, const _ns1__JiChaoQiResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__JiChaoQiResponse), type))
		return soap->error;
	if (a->JiChaoQiResult)
		soap_element_result(soap, "ns1:JiChaoQiResult");
	if (soap_out_string(soap, "ns1:JiChaoQiResult", -1, (char*const*)&a->_ns1__JiChaoQiResponse::JiChaoQiResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__JiChaoQiResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__JiChaoQiResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__JiChaoQiResponse * SOAP_FMAC4 soap_in__ns1__JiChaoQiResponse(struct soap *soap, const char *tag, _ns1__JiChaoQiResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__JiChaoQiResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__JiChaoQiResponse, sizeof(_ns1__JiChaoQiResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__JiChaoQiResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__JiChaoQiResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_JiChaoQiResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JiChaoQiResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:JiChaoQiResult", (char**)&a->_ns1__JiChaoQiResponse::JiChaoQiResult, "xsd:string"))
				{	soap_flag_JiChaoQiResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:JiChaoQiResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__JiChaoQiResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__JiChaoQiResponse, SOAP_TYPE__ns1__JiChaoQiResponse, sizeof(_ns1__JiChaoQiResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__JiChaoQiResponse * SOAP_FMAC2 soap_instantiate__ns1__JiChaoQiResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__JiChaoQiResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__JiChaoQiResponse *p;
	size_t k = sizeof(_ns1__JiChaoQiResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__JiChaoQiResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__JiChaoQiResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__JiChaoQiResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__JiChaoQiResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__JiChaoQiResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__JiChaoQiResponse(soap, tag ? tag : "ns1:JiChaoQiResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__JiChaoQiResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__JiChaoQiResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__JiChaoQiResponse * SOAP_FMAC4 soap_get__ns1__JiChaoQiResponse(struct soap *soap, _ns1__JiChaoQiResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__JiChaoQiResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__JiChaoQi::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__JiChaoQi::type);
	/* transient soap skipped */
}

void _ns1__JiChaoQi::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__JiChaoQi::type);
#endif
}

int _ns1__JiChaoQi::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__JiChaoQi(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__JiChaoQi(struct soap *soap, const char *tag, int id, const _ns1__JiChaoQi *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__JiChaoQi), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:type", -1, (char*const*)&a->_ns1__JiChaoQi::type, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__JiChaoQi::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__JiChaoQi(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__JiChaoQi * SOAP_FMAC4 soap_in__ns1__JiChaoQi(struct soap *soap, const char *tag, _ns1__JiChaoQi *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__JiChaoQi *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__JiChaoQi, sizeof(_ns1__JiChaoQi), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__JiChaoQi)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__JiChaoQi *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_type1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:type", (char**)&a->_ns1__JiChaoQi::type, "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__JiChaoQi *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__JiChaoQi, SOAP_TYPE__ns1__JiChaoQi, sizeof(_ns1__JiChaoQi), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__JiChaoQi * SOAP_FMAC2 soap_instantiate__ns1__JiChaoQi(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__JiChaoQi(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__JiChaoQi *p;
	size_t k = sizeof(_ns1__JiChaoQi);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__JiChaoQi, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__JiChaoQi);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__JiChaoQi, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__JiChaoQi location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__JiChaoQi::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__JiChaoQi(soap, tag ? tag : "ns1:JiChaoQi", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__JiChaoQi::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__JiChaoQi(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__JiChaoQi * SOAP_FMAC4 soap_get__ns1__JiChaoQi(struct soap *soap, _ns1__JiChaoQi *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__JiChaoQi(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ChaoQiResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__ChaoQiResponse::ChaoQiResult);
	/* transient soap skipped */
}

void _ns1__ChaoQiResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__ChaoQiResponse::ChaoQiResult);
#endif
}

int _ns1__ChaoQiResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ChaoQiResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ChaoQiResponse(struct soap *soap, const char *tag, int id, const _ns1__ChaoQiResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ChaoQiResponse), type))
		return soap->error;
	if (a->ChaoQiResult)
		soap_element_result(soap, "ns1:ChaoQiResult");
	if (soap_out_string(soap, "ns1:ChaoQiResult", -1, (char*const*)&a->_ns1__ChaoQiResponse::ChaoQiResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ChaoQiResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ChaoQiResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ChaoQiResponse * SOAP_FMAC4 soap_in__ns1__ChaoQiResponse(struct soap *soap, const char *tag, _ns1__ChaoQiResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ChaoQiResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ChaoQiResponse, sizeof(_ns1__ChaoQiResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ChaoQiResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ChaoQiResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ChaoQiResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ChaoQiResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:ChaoQiResult", (char**)&a->_ns1__ChaoQiResponse::ChaoQiResult, "xsd:string"))
				{	soap_flag_ChaoQiResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:ChaoQiResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ChaoQiResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ChaoQiResponse, SOAP_TYPE__ns1__ChaoQiResponse, sizeof(_ns1__ChaoQiResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ChaoQiResponse * SOAP_FMAC2 soap_instantiate__ns1__ChaoQiResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ChaoQiResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ChaoQiResponse *p;
	size_t k = sizeof(_ns1__ChaoQiResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ChaoQiResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ChaoQiResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ChaoQiResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ChaoQiResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ChaoQiResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ChaoQiResponse(soap, tag ? tag : "ns1:ChaoQiResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ChaoQiResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ChaoQiResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ChaoQiResponse * SOAP_FMAC4 soap_get__ns1__ChaoQiResponse(struct soap *soap, _ns1__ChaoQiResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ChaoQiResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ChaoQi::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__ChaoQi::type);
	/* transient soap skipped */
}

void _ns1__ChaoQi::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__ChaoQi::type);
#endif
}

int _ns1__ChaoQi::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ChaoQi(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ChaoQi(struct soap *soap, const char *tag, int id, const _ns1__ChaoQi *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ChaoQi), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:type", -1, (char*const*)&a->_ns1__ChaoQi::type, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ChaoQi::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ChaoQi(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ChaoQi * SOAP_FMAC4 soap_in__ns1__ChaoQi(struct soap *soap, const char *tag, _ns1__ChaoQi *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ChaoQi *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ChaoQi, sizeof(_ns1__ChaoQi), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ChaoQi)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ChaoQi *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_type1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:type", (char**)&a->_ns1__ChaoQi::type, "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ChaoQi *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ChaoQi, SOAP_TYPE__ns1__ChaoQi, sizeof(_ns1__ChaoQi), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ChaoQi * SOAP_FMAC2 soap_instantiate__ns1__ChaoQi(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ChaoQi(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ChaoQi *p;
	size_t k = sizeof(_ns1__ChaoQi);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ChaoQi, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ChaoQi);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ChaoQi, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ChaoQi location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ChaoQi::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ChaoQi(soap, tag ? tag : "ns1:ChaoQi", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ChaoQi::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ChaoQi(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ChaoQi * SOAP_FMAC4 soap_get__ns1__ChaoQi(struct soap *soap, _ns1__ChaoQi *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ChaoQi(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__OpenMapExeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__OpenMapExeResponse::OpenMapExeResult);
	/* transient soap skipped */
}

void _ns1__OpenMapExeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__OpenMapExeResponse::OpenMapExeResult);
#endif
}

int _ns1__OpenMapExeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OpenMapExeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OpenMapExeResponse(struct soap *soap, const char *tag, int id, const _ns1__OpenMapExeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OpenMapExeResponse), type))
		return soap->error;
	if (a->OpenMapExeResult)
		soap_element_result(soap, "ns1:OpenMapExeResult");
	if (soap_out_string(soap, "ns1:OpenMapExeResult", -1, (char*const*)&a->_ns1__OpenMapExeResponse::OpenMapExeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__OpenMapExeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__OpenMapExeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OpenMapExeResponse * SOAP_FMAC4 soap_in__ns1__OpenMapExeResponse(struct soap *soap, const char *tag, _ns1__OpenMapExeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OpenMapExeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OpenMapExeResponse, sizeof(_ns1__OpenMapExeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__OpenMapExeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__OpenMapExeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OpenMapExeResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OpenMapExeResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:OpenMapExeResult", (char**)&a->_ns1__OpenMapExeResponse::OpenMapExeResult, "xsd:string"))
				{	soap_flag_OpenMapExeResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:OpenMapExeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__OpenMapExeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OpenMapExeResponse, SOAP_TYPE__ns1__OpenMapExeResponse, sizeof(_ns1__OpenMapExeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__OpenMapExeResponse * SOAP_FMAC2 soap_instantiate__ns1__OpenMapExeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OpenMapExeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__OpenMapExeResponse *p;
	size_t k = sizeof(_ns1__OpenMapExeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__OpenMapExeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__OpenMapExeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__OpenMapExeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__OpenMapExeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__OpenMapExeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__OpenMapExeResponse(soap, tag ? tag : "ns1:OpenMapExeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OpenMapExeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OpenMapExeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OpenMapExeResponse * SOAP_FMAC4 soap_get__ns1__OpenMapExeResponse(struct soap *soap, _ns1__OpenMapExeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OpenMapExeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__OpenMapExe::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__OpenMapExe::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__OpenMapExe::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OpenMapExe(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OpenMapExe(struct soap *soap, const char *tag, int id, const _ns1__OpenMapExe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OpenMapExe), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__OpenMapExe::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__OpenMapExe(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OpenMapExe * SOAP_FMAC4 soap_in__ns1__OpenMapExe(struct soap *soap, const char *tag, _ns1__OpenMapExe *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OpenMapExe *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OpenMapExe, sizeof(_ns1__OpenMapExe), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__OpenMapExe)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__OpenMapExe *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__OpenMapExe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OpenMapExe, SOAP_TYPE__ns1__OpenMapExe, sizeof(_ns1__OpenMapExe), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__OpenMapExe * SOAP_FMAC2 soap_instantiate__ns1__OpenMapExe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OpenMapExe(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__OpenMapExe *p;
	size_t k = sizeof(_ns1__OpenMapExe);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__OpenMapExe, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__OpenMapExe);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__OpenMapExe, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__OpenMapExe location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__OpenMapExe::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__OpenMapExe(soap, tag ? tag : "ns1:OpenMapExe", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OpenMapExe::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OpenMapExe(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OpenMapExe * SOAP_FMAC4 soap_get__ns1__OpenMapExe(struct soap *soap, _ns1__OpenMapExe *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OpenMapExe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetEmfPngFileResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetEmfPngFileResponse::GetEmfPngFileResult);
	/* transient soap skipped */
}

void _ns1__GetEmfPngFileResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetEmfPngFileResponse::GetEmfPngFileResult);
#endif
}

int _ns1__GetEmfPngFileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetEmfPngFileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetEmfPngFileResponse(struct soap *soap, const char *tag, int id, const _ns1__GetEmfPngFileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetEmfPngFileResponse), type))
		return soap->error;
	if (a->GetEmfPngFileResult)
		soap_element_result(soap, "ns1:GetEmfPngFileResult");
	if (soap_out_string(soap, "ns1:GetEmfPngFileResult", -1, (char*const*)&a->_ns1__GetEmfPngFileResponse::GetEmfPngFileResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetEmfPngFileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetEmfPngFileResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetEmfPngFileResponse * SOAP_FMAC4 soap_in__ns1__GetEmfPngFileResponse(struct soap *soap, const char *tag, _ns1__GetEmfPngFileResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetEmfPngFileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetEmfPngFileResponse, sizeof(_ns1__GetEmfPngFileResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetEmfPngFileResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetEmfPngFileResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetEmfPngFileResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetEmfPngFileResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetEmfPngFileResult", (char**)&a->_ns1__GetEmfPngFileResponse::GetEmfPngFileResult, "xsd:string"))
				{	soap_flag_GetEmfPngFileResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetEmfPngFileResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetEmfPngFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetEmfPngFileResponse, SOAP_TYPE__ns1__GetEmfPngFileResponse, sizeof(_ns1__GetEmfPngFileResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetEmfPngFileResponse * SOAP_FMAC2 soap_instantiate__ns1__GetEmfPngFileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetEmfPngFileResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetEmfPngFileResponse *p;
	size_t k = sizeof(_ns1__GetEmfPngFileResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetEmfPngFileResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetEmfPngFileResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetEmfPngFileResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetEmfPngFileResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetEmfPngFileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetEmfPngFileResponse(soap, tag ? tag : "ns1:GetEmfPngFileResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetEmfPngFileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetEmfPngFileResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetEmfPngFileResponse * SOAP_FMAC4 soap_get__ns1__GetEmfPngFileResponse(struct soap *soap, _ns1__GetEmfPngFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetEmfPngFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetEmfPngFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetEmfPngFile::mapid);
	soap_default_string(soap, &this->_ns1__GetEmfPngFile::pagename);
	/* transient soap skipped */
}

void _ns1__GetEmfPngFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetEmfPngFile::mapid);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetEmfPngFile::pagename);
#endif
}

int _ns1__GetEmfPngFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetEmfPngFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetEmfPngFile(struct soap *soap, const char *tag, int id, const _ns1__GetEmfPngFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetEmfPngFile), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:mapid", -1, (char*const*)&a->_ns1__GetEmfPngFile::mapid, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:pagename", -1, (char*const*)&a->_ns1__GetEmfPngFile::pagename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetEmfPngFile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetEmfPngFile(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetEmfPngFile * SOAP_FMAC4 soap_in__ns1__GetEmfPngFile(struct soap *soap, const char *tag, _ns1__GetEmfPngFile *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetEmfPngFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetEmfPngFile, sizeof(_ns1__GetEmfPngFile), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetEmfPngFile)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetEmfPngFile *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_mapid1 = 1;
	size_t soap_flag_pagename1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mapid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:mapid", (char**)&a->_ns1__GetEmfPngFile::mapid, "xsd:string"))
				{	soap_flag_mapid1--;
					continue;
				}
			}
			if (soap_flag_pagename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:pagename", (char**)&a->_ns1__GetEmfPngFile::pagename, "xsd:string"))
				{	soap_flag_pagename1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetEmfPngFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetEmfPngFile, SOAP_TYPE__ns1__GetEmfPngFile, sizeof(_ns1__GetEmfPngFile), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetEmfPngFile * SOAP_FMAC2 soap_instantiate__ns1__GetEmfPngFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetEmfPngFile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetEmfPngFile *p;
	size_t k = sizeof(_ns1__GetEmfPngFile);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetEmfPngFile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetEmfPngFile);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetEmfPngFile, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetEmfPngFile location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetEmfPngFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetEmfPngFile(soap, tag ? tag : "ns1:GetEmfPngFile", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetEmfPngFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetEmfPngFile(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetEmfPngFile * SOAP_FMAC4 soap_get__ns1__GetEmfPngFile(struct soap *soap, _ns1__GetEmfPngFile *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetEmfPngFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetEmfPngVerResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetEmfPngVerResponse::GetEmfPngVerResult);
	/* transient soap skipped */
}

void _ns1__GetEmfPngVerResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetEmfPngVerResponse::GetEmfPngVerResult);
#endif
}

int _ns1__GetEmfPngVerResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetEmfPngVerResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetEmfPngVerResponse(struct soap *soap, const char *tag, int id, const _ns1__GetEmfPngVerResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetEmfPngVerResponse), type))
		return soap->error;
	if (a->GetEmfPngVerResult)
		soap_element_result(soap, "ns1:GetEmfPngVerResult");
	if (soap_out_string(soap, "ns1:GetEmfPngVerResult", -1, (char*const*)&a->_ns1__GetEmfPngVerResponse::GetEmfPngVerResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetEmfPngVerResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetEmfPngVerResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetEmfPngVerResponse * SOAP_FMAC4 soap_in__ns1__GetEmfPngVerResponse(struct soap *soap, const char *tag, _ns1__GetEmfPngVerResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetEmfPngVerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetEmfPngVerResponse, sizeof(_ns1__GetEmfPngVerResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetEmfPngVerResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetEmfPngVerResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetEmfPngVerResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetEmfPngVerResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetEmfPngVerResult", (char**)&a->_ns1__GetEmfPngVerResponse::GetEmfPngVerResult, "xsd:string"))
				{	soap_flag_GetEmfPngVerResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetEmfPngVerResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetEmfPngVerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetEmfPngVerResponse, SOAP_TYPE__ns1__GetEmfPngVerResponse, sizeof(_ns1__GetEmfPngVerResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetEmfPngVerResponse * SOAP_FMAC2 soap_instantiate__ns1__GetEmfPngVerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetEmfPngVerResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetEmfPngVerResponse *p;
	size_t k = sizeof(_ns1__GetEmfPngVerResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetEmfPngVerResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetEmfPngVerResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetEmfPngVerResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetEmfPngVerResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetEmfPngVerResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetEmfPngVerResponse(soap, tag ? tag : "ns1:GetEmfPngVerResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetEmfPngVerResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetEmfPngVerResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetEmfPngVerResponse * SOAP_FMAC4 soap_get__ns1__GetEmfPngVerResponse(struct soap *soap, _ns1__GetEmfPngVerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetEmfPngVerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetEmfPngVer::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetEmfPngVer::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetEmfPngVer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetEmfPngVer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetEmfPngVer(struct soap *soap, const char *tag, int id, const _ns1__GetEmfPngVer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetEmfPngVer), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetEmfPngVer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetEmfPngVer(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetEmfPngVer * SOAP_FMAC4 soap_in__ns1__GetEmfPngVer(struct soap *soap, const char *tag, _ns1__GetEmfPngVer *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetEmfPngVer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetEmfPngVer, sizeof(_ns1__GetEmfPngVer), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetEmfPngVer)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetEmfPngVer *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetEmfPngVer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetEmfPngVer, SOAP_TYPE__ns1__GetEmfPngVer, sizeof(_ns1__GetEmfPngVer), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetEmfPngVer * SOAP_FMAC2 soap_instantiate__ns1__GetEmfPngVer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetEmfPngVer(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetEmfPngVer *p;
	size_t k = sizeof(_ns1__GetEmfPngVer);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetEmfPngVer, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetEmfPngVer);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetEmfPngVer, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetEmfPngVer location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetEmfPngVer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetEmfPngVer(soap, tag ? tag : "ns1:GetEmfPngVer", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetEmfPngVer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetEmfPngVer(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetEmfPngVer * SOAP_FMAC4 soap_get__ns1__GetEmfPngVer(struct soap *soap, _ns1__GetEmfPngVer *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetEmfPngVer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__OpenProcessResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__OpenProcessResponse::OpenProcessResult);
	/* transient soap skipped */
}

void _ns1__OpenProcessResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__OpenProcessResponse::OpenProcessResult);
#endif
}

int _ns1__OpenProcessResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OpenProcessResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OpenProcessResponse(struct soap *soap, const char *tag, int id, const _ns1__OpenProcessResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OpenProcessResponse), type))
		return soap->error;
	if (a->OpenProcessResult)
		soap_element_result(soap, "ns1:OpenProcessResult");
	if (soap_out_string(soap, "ns1:OpenProcessResult", -1, (char*const*)&a->_ns1__OpenProcessResponse::OpenProcessResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__OpenProcessResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__OpenProcessResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OpenProcessResponse * SOAP_FMAC4 soap_in__ns1__OpenProcessResponse(struct soap *soap, const char *tag, _ns1__OpenProcessResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OpenProcessResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OpenProcessResponse, sizeof(_ns1__OpenProcessResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__OpenProcessResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__OpenProcessResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OpenProcessResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OpenProcessResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:OpenProcessResult", (char**)&a->_ns1__OpenProcessResponse::OpenProcessResult, "xsd:string"))
				{	soap_flag_OpenProcessResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:OpenProcessResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__OpenProcessResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OpenProcessResponse, SOAP_TYPE__ns1__OpenProcessResponse, sizeof(_ns1__OpenProcessResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__OpenProcessResponse * SOAP_FMAC2 soap_instantiate__ns1__OpenProcessResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OpenProcessResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__OpenProcessResponse *p;
	size_t k = sizeof(_ns1__OpenProcessResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__OpenProcessResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__OpenProcessResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__OpenProcessResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__OpenProcessResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__OpenProcessResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__OpenProcessResponse(soap, tag ? tag : "ns1:OpenProcessResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OpenProcessResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OpenProcessResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OpenProcessResponse * SOAP_FMAC4 soap_get__ns1__OpenProcessResponse(struct soap *soap, _ns1__OpenProcessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OpenProcessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__OpenProcess::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__OpenProcess::name);
	soap_default_string(soap, &this->_ns1__OpenProcess::param);
	/* transient soap skipped */
}

void _ns1__OpenProcess::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__OpenProcess::name);
	soap_serialize_string(soap, (char*const*)&this->_ns1__OpenProcess::param);
#endif
}

int _ns1__OpenProcess::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OpenProcess(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OpenProcess(struct soap *soap, const char *tag, int id, const _ns1__OpenProcess *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OpenProcess), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:name", -1, (char*const*)&a->_ns1__OpenProcess::name, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:param", -1, (char*const*)&a->_ns1__OpenProcess::param, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__OpenProcess::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__OpenProcess(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OpenProcess * SOAP_FMAC4 soap_in__ns1__OpenProcess(struct soap *soap, const char *tag, _ns1__OpenProcess *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OpenProcess *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OpenProcess, sizeof(_ns1__OpenProcess), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__OpenProcess)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__OpenProcess *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_name1 = 1;
	size_t soap_flag_param1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:name", (char**)&a->_ns1__OpenProcess::name, "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			}
			if (soap_flag_param1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:param", (char**)&a->_ns1__OpenProcess::param, "xsd:string"))
				{	soap_flag_param1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__OpenProcess *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OpenProcess, SOAP_TYPE__ns1__OpenProcess, sizeof(_ns1__OpenProcess), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__OpenProcess * SOAP_FMAC2 soap_instantiate__ns1__OpenProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OpenProcess(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__OpenProcess *p;
	size_t k = sizeof(_ns1__OpenProcess);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__OpenProcess, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__OpenProcess);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__OpenProcess, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__OpenProcess location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__OpenProcess::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__OpenProcess(soap, tag ? tag : "ns1:OpenProcess", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OpenProcess::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OpenProcess(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OpenProcess * SOAP_FMAC4 soap_get__ns1__OpenProcess(struct soap *soap, _ns1__OpenProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OpenProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMangeMapUpdateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetMangeMapUpdateResponse::GetMangeMapUpdateResult);
	/* transient soap skipped */
}

void _ns1__GetMangeMapUpdateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMangeMapUpdateResponse::GetMangeMapUpdateResult);
#endif
}

int _ns1__GetMangeMapUpdateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMangeMapUpdateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMangeMapUpdateResponse(struct soap *soap, const char *tag, int id, const _ns1__GetMangeMapUpdateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMangeMapUpdateResponse), type))
		return soap->error;
	if (a->GetMangeMapUpdateResult)
		soap_element_result(soap, "ns1:GetMangeMapUpdateResult");
	if (soap_out_string(soap, "ns1:GetMangeMapUpdateResult", -1, (char*const*)&a->_ns1__GetMangeMapUpdateResponse::GetMangeMapUpdateResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMangeMapUpdateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMangeMapUpdateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMangeMapUpdateResponse * SOAP_FMAC4 soap_in__ns1__GetMangeMapUpdateResponse(struct soap *soap, const char *tag, _ns1__GetMangeMapUpdateResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMangeMapUpdateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMangeMapUpdateResponse, sizeof(_ns1__GetMangeMapUpdateResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMangeMapUpdateResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMangeMapUpdateResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetMangeMapUpdateResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetMangeMapUpdateResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetMangeMapUpdateResult", (char**)&a->_ns1__GetMangeMapUpdateResponse::GetMangeMapUpdateResult, "xsd:string"))
				{	soap_flag_GetMangeMapUpdateResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetMangeMapUpdateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMangeMapUpdateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMangeMapUpdateResponse, SOAP_TYPE__ns1__GetMangeMapUpdateResponse, sizeof(_ns1__GetMangeMapUpdateResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMangeMapUpdateResponse * SOAP_FMAC2 soap_instantiate__ns1__GetMangeMapUpdateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMangeMapUpdateResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMangeMapUpdateResponse *p;
	size_t k = sizeof(_ns1__GetMangeMapUpdateResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetMangeMapUpdateResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetMangeMapUpdateResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetMangeMapUpdateResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMangeMapUpdateResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetMangeMapUpdateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMangeMapUpdateResponse(soap, tag ? tag : "ns1:GetMangeMapUpdateResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMangeMapUpdateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMangeMapUpdateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMangeMapUpdateResponse * SOAP_FMAC4 soap_get__ns1__GetMangeMapUpdateResponse(struct soap *soap, _ns1__GetMangeMapUpdateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMangeMapUpdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMangeMapUpdate::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetMangeMapUpdate::dname);
	/* transient soap skipped */
}

void _ns1__GetMangeMapUpdate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMangeMapUpdate::dname);
#endif
}

int _ns1__GetMangeMapUpdate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMangeMapUpdate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMangeMapUpdate(struct soap *soap, const char *tag, int id, const _ns1__GetMangeMapUpdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMangeMapUpdate), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:dname", -1, (char*const*)&a->_ns1__GetMangeMapUpdate::dname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMangeMapUpdate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMangeMapUpdate(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMangeMapUpdate * SOAP_FMAC4 soap_in__ns1__GetMangeMapUpdate(struct soap *soap, const char *tag, _ns1__GetMangeMapUpdate *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMangeMapUpdate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMangeMapUpdate, sizeof(_ns1__GetMangeMapUpdate), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMangeMapUpdate)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMangeMapUpdate *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dname1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dname", (char**)&a->_ns1__GetMangeMapUpdate::dname, "xsd:string"))
				{	soap_flag_dname1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMangeMapUpdate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMangeMapUpdate, SOAP_TYPE__ns1__GetMangeMapUpdate, sizeof(_ns1__GetMangeMapUpdate), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMangeMapUpdate * SOAP_FMAC2 soap_instantiate__ns1__GetMangeMapUpdate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMangeMapUpdate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMangeMapUpdate *p;
	size_t k = sizeof(_ns1__GetMangeMapUpdate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetMangeMapUpdate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetMangeMapUpdate);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetMangeMapUpdate, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMangeMapUpdate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetMangeMapUpdate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMangeMapUpdate(soap, tag ? tag : "ns1:GetMangeMapUpdate", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMangeMapUpdate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMangeMapUpdate(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMangeMapUpdate * SOAP_FMAC4 soap_get__ns1__GetMangeMapUpdate(struct soap *soap, _ns1__GetMangeMapUpdate *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMangeMapUpdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetUnitMapVerResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetUnitMapVerResponse::GetUnitMapVerResult);
	/* transient soap skipped */
}

void _ns1__GetUnitMapVerResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetUnitMapVerResponse::GetUnitMapVerResult);
#endif
}

int _ns1__GetUnitMapVerResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetUnitMapVerResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetUnitMapVerResponse(struct soap *soap, const char *tag, int id, const _ns1__GetUnitMapVerResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetUnitMapVerResponse), type))
		return soap->error;
	if (a->GetUnitMapVerResult)
		soap_element_result(soap, "ns1:GetUnitMapVerResult");
	if (soap_out_string(soap, "ns1:GetUnitMapVerResult", -1, (char*const*)&a->_ns1__GetUnitMapVerResponse::GetUnitMapVerResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetUnitMapVerResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetUnitMapVerResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetUnitMapVerResponse * SOAP_FMAC4 soap_in__ns1__GetUnitMapVerResponse(struct soap *soap, const char *tag, _ns1__GetUnitMapVerResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetUnitMapVerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetUnitMapVerResponse, sizeof(_ns1__GetUnitMapVerResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetUnitMapVerResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetUnitMapVerResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetUnitMapVerResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetUnitMapVerResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetUnitMapVerResult", (char**)&a->_ns1__GetUnitMapVerResponse::GetUnitMapVerResult, "xsd:string"))
				{	soap_flag_GetUnitMapVerResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetUnitMapVerResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetUnitMapVerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetUnitMapVerResponse, SOAP_TYPE__ns1__GetUnitMapVerResponse, sizeof(_ns1__GetUnitMapVerResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetUnitMapVerResponse * SOAP_FMAC2 soap_instantiate__ns1__GetUnitMapVerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetUnitMapVerResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetUnitMapVerResponse *p;
	size_t k = sizeof(_ns1__GetUnitMapVerResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetUnitMapVerResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetUnitMapVerResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetUnitMapVerResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetUnitMapVerResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetUnitMapVerResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetUnitMapVerResponse(soap, tag ? tag : "ns1:GetUnitMapVerResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetUnitMapVerResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetUnitMapVerResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetUnitMapVerResponse * SOAP_FMAC4 soap_get__ns1__GetUnitMapVerResponse(struct soap *soap, _ns1__GetUnitMapVerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetUnitMapVerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetUnitMapVer::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetUnitMapVer::dwname);
	soap_default_string(soap, &this->_ns1__GetUnitMapVer::unitname);
	/* transient soap skipped */
}

void _ns1__GetUnitMapVer::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetUnitMapVer::dwname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetUnitMapVer::unitname);
#endif
}

int _ns1__GetUnitMapVer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetUnitMapVer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetUnitMapVer(struct soap *soap, const char *tag, int id, const _ns1__GetUnitMapVer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetUnitMapVer), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__GetUnitMapVer::dwname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:unitname", -1, (char*const*)&a->_ns1__GetUnitMapVer::unitname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetUnitMapVer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetUnitMapVer(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetUnitMapVer * SOAP_FMAC4 soap_in__ns1__GetUnitMapVer(struct soap *soap, const char *tag, _ns1__GetUnitMapVer *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetUnitMapVer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetUnitMapVer, sizeof(_ns1__GetUnitMapVer), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetUnitMapVer)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetUnitMapVer *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dwname1 = 1;
	size_t soap_flag_unitname1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__GetUnitMapVer::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap_flag_unitname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:unitname", (char**)&a->_ns1__GetUnitMapVer::unitname, "xsd:string"))
				{	soap_flag_unitname1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetUnitMapVer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetUnitMapVer, SOAP_TYPE__ns1__GetUnitMapVer, sizeof(_ns1__GetUnitMapVer), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetUnitMapVer * SOAP_FMAC2 soap_instantiate__ns1__GetUnitMapVer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetUnitMapVer(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetUnitMapVer *p;
	size_t k = sizeof(_ns1__GetUnitMapVer);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetUnitMapVer, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetUnitMapVer);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetUnitMapVer, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetUnitMapVer location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetUnitMapVer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetUnitMapVer(soap, tag ? tag : "ns1:GetUnitMapVer", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetUnitMapVer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetUnitMapVer(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetUnitMapVer * SOAP_FMAC4 soap_get__ns1__GetUnitMapVer(struct soap *soap, _ns1__GetUnitMapVer *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetUnitMapVer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UpdateGzclMapResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdateGzclMapResponse::UpdateGzclMapResult);
	/* transient soap skipped */
}

void _ns1__UpdateGzclMapResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__UpdateGzclMapResponse::UpdateGzclMapResult);
#endif
}

int _ns1__UpdateGzclMapResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateGzclMapResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateGzclMapResponse(struct soap *soap, const char *tag, int id, const _ns1__UpdateGzclMapResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateGzclMapResponse), type))
		return soap->error;
	if (a->UpdateGzclMapResult)
		soap_element_result(soap, "ns1:UpdateGzclMapResult");
	if (soap_out_string(soap, "ns1:UpdateGzclMapResult", -1, (char*const*)&a->_ns1__UpdateGzclMapResponse::UpdateGzclMapResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateGzclMapResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateGzclMapResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateGzclMapResponse * SOAP_FMAC4 soap_in__ns1__UpdateGzclMapResponse(struct soap *soap, const char *tag, _ns1__UpdateGzclMapResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateGzclMapResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateGzclMapResponse, sizeof(_ns1__UpdateGzclMapResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__UpdateGzclMapResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__UpdateGzclMapResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UpdateGzclMapResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdateGzclMapResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:UpdateGzclMapResult", (char**)&a->_ns1__UpdateGzclMapResponse::UpdateGzclMapResult, "xsd:string"))
				{	soap_flag_UpdateGzclMapResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:UpdateGzclMapResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdateGzclMapResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateGzclMapResponse, SOAP_TYPE__ns1__UpdateGzclMapResponse, sizeof(_ns1__UpdateGzclMapResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UpdateGzclMapResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdateGzclMapResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateGzclMapResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UpdateGzclMapResponse *p;
	size_t k = sizeof(_ns1__UpdateGzclMapResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__UpdateGzclMapResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__UpdateGzclMapResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__UpdateGzclMapResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UpdateGzclMapResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__UpdateGzclMapResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__UpdateGzclMapResponse(soap, tag ? tag : "ns1:UpdateGzclMapResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateGzclMapResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateGzclMapResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateGzclMapResponse * SOAP_FMAC4 soap_get__ns1__UpdateGzclMapResponse(struct soap *soap, _ns1__UpdateGzclMapResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateGzclMapResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UpdateGzclMap::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdateGzclMap::xml);
	/* transient soap skipped */
}

void _ns1__UpdateGzclMap::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__UpdateGzclMap::xml);
#endif
}

int _ns1__UpdateGzclMap::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateGzclMap(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateGzclMap(struct soap *soap, const char *tag, int id, const _ns1__UpdateGzclMap *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateGzclMap), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xml", -1, (char*const*)&a->_ns1__UpdateGzclMap::xml, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateGzclMap::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateGzclMap(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateGzclMap * SOAP_FMAC4 soap_in__ns1__UpdateGzclMap(struct soap *soap, const char *tag, _ns1__UpdateGzclMap *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateGzclMap *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateGzclMap, sizeof(_ns1__UpdateGzclMap), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__UpdateGzclMap)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__UpdateGzclMap *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_xml1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xml1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:xml", (char**)&a->_ns1__UpdateGzclMap::xml, "xsd:string"))
				{	soap_flag_xml1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdateGzclMap *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateGzclMap, SOAP_TYPE__ns1__UpdateGzclMap, sizeof(_ns1__UpdateGzclMap), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UpdateGzclMap * SOAP_FMAC2 soap_instantiate__ns1__UpdateGzclMap(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateGzclMap(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UpdateGzclMap *p;
	size_t k = sizeof(_ns1__UpdateGzclMap);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__UpdateGzclMap, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__UpdateGzclMap);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__UpdateGzclMap, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UpdateGzclMap location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__UpdateGzclMap::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__UpdateGzclMap(soap, tag ? tag : "ns1:UpdateGzclMap", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateGzclMap::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateGzclMap(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateGzclMap * SOAP_FMAC4 soap_get__ns1__UpdateGzclMap(struct soap *soap, _ns1__UpdateGzclMap *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateGzclMap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMapListTimeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetMapListTimeResponse::GetMapListTimeResult);
	/* transient soap skipped */
}

void _ns1__GetMapListTimeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMapListTimeResponse::GetMapListTimeResult);
#endif
}

int _ns1__GetMapListTimeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMapListTimeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMapListTimeResponse(struct soap *soap, const char *tag, int id, const _ns1__GetMapListTimeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMapListTimeResponse), type))
		return soap->error;
	if (a->GetMapListTimeResult)
		soap_element_result(soap, "ns1:GetMapListTimeResult");
	if (soap_out_string(soap, "ns1:GetMapListTimeResult", -1, (char*const*)&a->_ns1__GetMapListTimeResponse::GetMapListTimeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMapListTimeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMapListTimeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMapListTimeResponse * SOAP_FMAC4 soap_in__ns1__GetMapListTimeResponse(struct soap *soap, const char *tag, _ns1__GetMapListTimeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMapListTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMapListTimeResponse, sizeof(_ns1__GetMapListTimeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMapListTimeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMapListTimeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetMapListTimeResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetMapListTimeResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetMapListTimeResult", (char**)&a->_ns1__GetMapListTimeResponse::GetMapListTimeResult, "xsd:string"))
				{	soap_flag_GetMapListTimeResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetMapListTimeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMapListTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMapListTimeResponse, SOAP_TYPE__ns1__GetMapListTimeResponse, sizeof(_ns1__GetMapListTimeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMapListTimeResponse * SOAP_FMAC2 soap_instantiate__ns1__GetMapListTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMapListTimeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMapListTimeResponse *p;
	size_t k = sizeof(_ns1__GetMapListTimeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetMapListTimeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetMapListTimeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetMapListTimeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMapListTimeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetMapListTimeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMapListTimeResponse(soap, tag ? tag : "ns1:GetMapListTimeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMapListTimeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMapListTimeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMapListTimeResponse * SOAP_FMAC4 soap_get__ns1__GetMapListTimeResponse(struct soap *soap, _ns1__GetMapListTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMapListTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMapListTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetMapListTime::uptime);
	soap_default_string(soap, &this->_ns1__GetMapListTime::dwname);
	soap_default_string(soap, &this->_ns1__GetMapListTime::filename);
	/* transient soap skipped */
}

void _ns1__GetMapListTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMapListTime::uptime);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMapListTime::dwname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMapListTime::filename);
#endif
}

int _ns1__GetMapListTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMapListTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMapListTime(struct soap *soap, const char *tag, int id, const _ns1__GetMapListTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMapListTime), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:uptime", -1, (char*const*)&a->_ns1__GetMapListTime::uptime, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__GetMapListTime::dwname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, (char*const*)&a->_ns1__GetMapListTime::filename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMapListTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMapListTime(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMapListTime * SOAP_FMAC4 soap_in__ns1__GetMapListTime(struct soap *soap, const char *tag, _ns1__GetMapListTime *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMapListTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMapListTime, sizeof(_ns1__GetMapListTime), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMapListTime)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMapListTime *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_uptime1 = 1;
	size_t soap_flag_dwname1 = 1;
	size_t soap_flag_filename1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uptime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:uptime", (char**)&a->_ns1__GetMapListTime::uptime, "xsd:string"))
				{	soap_flag_uptime1--;
					continue;
				}
			}
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__GetMapListTime::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:filename", (char**)&a->_ns1__GetMapListTime::filename, "xsd:string"))
				{	soap_flag_filename1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMapListTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMapListTime, SOAP_TYPE__ns1__GetMapListTime, sizeof(_ns1__GetMapListTime), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMapListTime * SOAP_FMAC2 soap_instantiate__ns1__GetMapListTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMapListTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMapListTime *p;
	size_t k = sizeof(_ns1__GetMapListTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetMapListTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetMapListTime);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetMapListTime, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMapListTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetMapListTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMapListTime(soap, tag ? tag : "ns1:GetMapListTime", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMapListTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMapListTime(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMapListTime * SOAP_FMAC4 soap_get__ns1__GetMapListTime(struct soap *soap, _ns1__GetMapListTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMapListTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ServerLevelResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__ServerLevelResponse::ServerLevelResult);
	/* transient soap skipped */
}

void _ns1__ServerLevelResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__ServerLevelResponse::ServerLevelResult);
#endif
}

int _ns1__ServerLevelResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ServerLevelResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ServerLevelResponse(struct soap *soap, const char *tag, int id, const _ns1__ServerLevelResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ServerLevelResponse), type))
		return soap->error;
	if (a->ServerLevelResult)
		soap_element_result(soap, "ns1:ServerLevelResult");
	if (soap_out_string(soap, "ns1:ServerLevelResult", -1, (char*const*)&a->_ns1__ServerLevelResponse::ServerLevelResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ServerLevelResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ServerLevelResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ServerLevelResponse * SOAP_FMAC4 soap_in__ns1__ServerLevelResponse(struct soap *soap, const char *tag, _ns1__ServerLevelResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ServerLevelResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ServerLevelResponse, sizeof(_ns1__ServerLevelResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ServerLevelResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ServerLevelResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ServerLevelResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ServerLevelResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:ServerLevelResult", (char**)&a->_ns1__ServerLevelResponse::ServerLevelResult, "xsd:string"))
				{	soap_flag_ServerLevelResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:ServerLevelResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ServerLevelResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ServerLevelResponse, SOAP_TYPE__ns1__ServerLevelResponse, sizeof(_ns1__ServerLevelResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ServerLevelResponse * SOAP_FMAC2 soap_instantiate__ns1__ServerLevelResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ServerLevelResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ServerLevelResponse *p;
	size_t k = sizeof(_ns1__ServerLevelResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ServerLevelResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ServerLevelResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ServerLevelResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ServerLevelResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ServerLevelResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ServerLevelResponse(soap, tag ? tag : "ns1:ServerLevelResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ServerLevelResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ServerLevelResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ServerLevelResponse * SOAP_FMAC4 soap_get__ns1__ServerLevelResponse(struct soap *soap, _ns1__ServerLevelResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ServerLevelResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ServerLevel::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__ServerLevel::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__ServerLevel::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ServerLevel(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ServerLevel(struct soap *soap, const char *tag, int id, const _ns1__ServerLevel *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ServerLevel), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ServerLevel::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ServerLevel(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ServerLevel * SOAP_FMAC4 soap_in__ns1__ServerLevel(struct soap *soap, const char *tag, _ns1__ServerLevel *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ServerLevel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ServerLevel, sizeof(_ns1__ServerLevel), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ServerLevel)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ServerLevel *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ServerLevel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ServerLevel, SOAP_TYPE__ns1__ServerLevel, sizeof(_ns1__ServerLevel), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ServerLevel * SOAP_FMAC2 soap_instantiate__ns1__ServerLevel(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ServerLevel(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ServerLevel *p;
	size_t k = sizeof(_ns1__ServerLevel);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ServerLevel, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ServerLevel);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ServerLevel, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ServerLevel location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ServerLevel::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ServerLevel(soap, tag ? tag : "ns1:ServerLevel", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ServerLevel::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ServerLevel(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ServerLevel * SOAP_FMAC4 soap_get__ns1__ServerLevel(struct soap *soap, _ns1__ServerLevel *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ServerLevel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetTableDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetTableDataResponse::GetTableDataResult);
	/* transient soap skipped */
}

void _ns1__GetTableDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetTableDataResponse::GetTableDataResult);
#endif
}

int _ns1__GetTableDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetTableDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetTableDataResponse(struct soap *soap, const char *tag, int id, const _ns1__GetTableDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetTableDataResponse), type))
		return soap->error;
	if (a->GetTableDataResult)
		soap_element_result(soap, "ns1:GetTableDataResult");
	if (soap_out_string(soap, "ns1:GetTableDataResult", -1, (char*const*)&a->_ns1__GetTableDataResponse::GetTableDataResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetTableDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetTableDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetTableDataResponse * SOAP_FMAC4 soap_in__ns1__GetTableDataResponse(struct soap *soap, const char *tag, _ns1__GetTableDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetTableDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetTableDataResponse, sizeof(_ns1__GetTableDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetTableDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetTableDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetTableDataResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetTableDataResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetTableDataResult", (char**)&a->_ns1__GetTableDataResponse::GetTableDataResult, "xsd:string"))
				{	soap_flag_GetTableDataResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetTableDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetTableDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetTableDataResponse, SOAP_TYPE__ns1__GetTableDataResponse, sizeof(_ns1__GetTableDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetTableDataResponse * SOAP_FMAC2 soap_instantiate__ns1__GetTableDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetTableDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetTableDataResponse *p;
	size_t k = sizeof(_ns1__GetTableDataResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetTableDataResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetTableDataResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetTableDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetTableDataResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetTableDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetTableDataResponse(soap, tag ? tag : "ns1:GetTableDataResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetTableDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetTableDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetTableDataResponse * SOAP_FMAC4 soap_get__ns1__GetTableDataResponse(struct soap *soap, _ns1__GetTableDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetTableDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetTableData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetTableData::tabname);
	soap_default_string(soap, &this->_ns1__GetTableData::filename);
	/* transient soap skipped */
}

void _ns1__GetTableData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetTableData::tabname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetTableData::filename);
#endif
}

int _ns1__GetTableData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetTableData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetTableData(struct soap *soap, const char *tag, int id, const _ns1__GetTableData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetTableData), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:tabname", -1, (char*const*)&a->_ns1__GetTableData::tabname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, (char*const*)&a->_ns1__GetTableData::filename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetTableData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetTableData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetTableData * SOAP_FMAC4 soap_in__ns1__GetTableData(struct soap *soap, const char *tag, _ns1__GetTableData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetTableData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetTableData, sizeof(_ns1__GetTableData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetTableData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetTableData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_tabname1 = 1;
	size_t soap_flag_filename1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tabname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:tabname", (char**)&a->_ns1__GetTableData::tabname, "xsd:string"))
				{	soap_flag_tabname1--;
					continue;
				}
			}
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:filename", (char**)&a->_ns1__GetTableData::filename, "xsd:string"))
				{	soap_flag_filename1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetTableData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetTableData, SOAP_TYPE__ns1__GetTableData, sizeof(_ns1__GetTableData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetTableData * SOAP_FMAC2 soap_instantiate__ns1__GetTableData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetTableData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetTableData *p;
	size_t k = sizeof(_ns1__GetTableData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetTableData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetTableData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetTableData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetTableData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetTableData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetTableData(soap, tag ? tag : "ns1:GetTableData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetTableData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetTableData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetTableData * SOAP_FMAC4 soap_get__ns1__GetTableData(struct soap *soap, _ns1__GetTableData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetTableData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMapResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetMapResponse::GetMapResult);
	/* transient soap skipped */
}

void _ns1__GetMapResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMapResponse::GetMapResult);
#endif
}

int _ns1__GetMapResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMapResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMapResponse(struct soap *soap, const char *tag, int id, const _ns1__GetMapResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMapResponse), type))
		return soap->error;
	if (a->GetMapResult)
		soap_element_result(soap, "ns1:GetMapResult");
	if (soap_out_string(soap, "ns1:GetMapResult", -1, (char*const*)&a->_ns1__GetMapResponse::GetMapResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMapResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMapResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMapResponse * SOAP_FMAC4 soap_in__ns1__GetMapResponse(struct soap *soap, const char *tag, _ns1__GetMapResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMapResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMapResponse, sizeof(_ns1__GetMapResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMapResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMapResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetMapResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetMapResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetMapResult", (char**)&a->_ns1__GetMapResponse::GetMapResult, "xsd:string"))
				{	soap_flag_GetMapResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetMapResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMapResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMapResponse, SOAP_TYPE__ns1__GetMapResponse, sizeof(_ns1__GetMapResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMapResponse * SOAP_FMAC2 soap_instantiate__ns1__GetMapResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMapResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMapResponse *p;
	size_t k = sizeof(_ns1__GetMapResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetMapResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetMapResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetMapResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMapResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetMapResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMapResponse(soap, tag ? tag : "ns1:GetMapResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMapResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMapResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMapResponse * SOAP_FMAC4 soap_get__ns1__GetMapResponse(struct soap *soap, _ns1__GetMapResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMapResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMap::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetMap::filename);
	/* transient soap skipped */
}

void _ns1__GetMap::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMap::filename);
#endif
}

int _ns1__GetMap::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMap(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMap(struct soap *soap, const char *tag, int id, const _ns1__GetMap *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMap), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, (char*const*)&a->_ns1__GetMap::filename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMap::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMap(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMap * SOAP_FMAC4 soap_in__ns1__GetMap(struct soap *soap, const char *tag, _ns1__GetMap *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMap *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMap, sizeof(_ns1__GetMap), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMap)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMap *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_filename1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:filename", (char**)&a->_ns1__GetMap::filename, "xsd:string"))
				{	soap_flag_filename1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMap *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMap, SOAP_TYPE__ns1__GetMap, sizeof(_ns1__GetMap), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMap * SOAP_FMAC2 soap_instantiate__ns1__GetMap(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMap(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMap *p;
	size_t k = sizeof(_ns1__GetMap);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetMap, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetMap);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetMap, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMap location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetMap::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMap(soap, tag ? tag : "ns1:GetMap", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMap::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMap(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMap * SOAP_FMAC4 soap_get__ns1__GetMap(struct soap *soap, _ns1__GetMap *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CheckMapVerResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__CheckMapVerResponse::CheckMapVerResult);
	/* transient soap skipped */
}

void _ns1__CheckMapVerResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__CheckMapVerResponse::CheckMapVerResult);
#endif
}

int _ns1__CheckMapVerResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CheckMapVerResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CheckMapVerResponse(struct soap *soap, const char *tag, int id, const _ns1__CheckMapVerResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CheckMapVerResponse), type))
		return soap->error;
	if (a->CheckMapVerResult)
		soap_element_result(soap, "ns1:CheckMapVerResult");
	if (soap_out_string(soap, "ns1:CheckMapVerResult", -1, (char*const*)&a->_ns1__CheckMapVerResponse::CheckMapVerResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CheckMapVerResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CheckMapVerResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CheckMapVerResponse * SOAP_FMAC4 soap_in__ns1__CheckMapVerResponse(struct soap *soap, const char *tag, _ns1__CheckMapVerResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CheckMapVerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CheckMapVerResponse, sizeof(_ns1__CheckMapVerResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CheckMapVerResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CheckMapVerResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CheckMapVerResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CheckMapVerResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:CheckMapVerResult", (char**)&a->_ns1__CheckMapVerResponse::CheckMapVerResult, "xsd:string"))
				{	soap_flag_CheckMapVerResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:CheckMapVerResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CheckMapVerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CheckMapVerResponse, SOAP_TYPE__ns1__CheckMapVerResponse, sizeof(_ns1__CheckMapVerResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CheckMapVerResponse * SOAP_FMAC2 soap_instantiate__ns1__CheckMapVerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CheckMapVerResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CheckMapVerResponse *p;
	size_t k = sizeof(_ns1__CheckMapVerResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__CheckMapVerResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__CheckMapVerResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__CheckMapVerResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CheckMapVerResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__CheckMapVerResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CheckMapVerResponse(soap, tag ? tag : "ns1:CheckMapVerResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CheckMapVerResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CheckMapVerResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CheckMapVerResponse * SOAP_FMAC4 soap_get__ns1__CheckMapVerResponse(struct soap *soap, _ns1__CheckMapVerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CheckMapVerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CheckMapVer::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__CheckMapVer::ver);
	/* transient soap skipped */
}

void _ns1__CheckMapVer::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__CheckMapVer::ver);
#endif
}

int _ns1__CheckMapVer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CheckMapVer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CheckMapVer(struct soap *soap, const char *tag, int id, const _ns1__CheckMapVer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CheckMapVer), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:ver", -1, (char*const*)&a->_ns1__CheckMapVer::ver, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CheckMapVer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CheckMapVer(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CheckMapVer * SOAP_FMAC4 soap_in__ns1__CheckMapVer(struct soap *soap, const char *tag, _ns1__CheckMapVer *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CheckMapVer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CheckMapVer, sizeof(_ns1__CheckMapVer), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CheckMapVer)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CheckMapVer *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ver1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ver1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:ver", (char**)&a->_ns1__CheckMapVer::ver, "xsd:string"))
				{	soap_flag_ver1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CheckMapVer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CheckMapVer, SOAP_TYPE__ns1__CheckMapVer, sizeof(_ns1__CheckMapVer), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CheckMapVer * SOAP_FMAC2 soap_instantiate__ns1__CheckMapVer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CheckMapVer(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CheckMapVer *p;
	size_t k = sizeof(_ns1__CheckMapVer);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__CheckMapVer, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__CheckMapVer);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__CheckMapVer, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CheckMapVer location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__CheckMapVer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CheckMapVer(soap, tag ? tag : "ns1:CheckMapVer", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CheckMapVer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CheckMapVer(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CheckMapVer * SOAP_FMAC4 soap_get__ns1__CheckMapVer(struct soap *soap, _ns1__CheckMapVer *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CheckMapVer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMangeXbResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetMangeXbResponse::GetMangeXbResult);
	/* transient soap skipped */
}

void _ns1__GetMangeXbResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMangeXbResponse::GetMangeXbResult);
#endif
}

int _ns1__GetMangeXbResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMangeXbResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMangeXbResponse(struct soap *soap, const char *tag, int id, const _ns1__GetMangeXbResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMangeXbResponse), type))
		return soap->error;
	if (a->GetMangeXbResult)
		soap_element_result(soap, "ns1:GetMangeXbResult");
	if (soap_out_string(soap, "ns1:GetMangeXbResult", -1, (char*const*)&a->_ns1__GetMangeXbResponse::GetMangeXbResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMangeXbResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMangeXbResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMangeXbResponse * SOAP_FMAC4 soap_in__ns1__GetMangeXbResponse(struct soap *soap, const char *tag, _ns1__GetMangeXbResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMangeXbResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMangeXbResponse, sizeof(_ns1__GetMangeXbResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMangeXbResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMangeXbResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetMangeXbResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetMangeXbResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetMangeXbResult", (char**)&a->_ns1__GetMangeXbResponse::GetMangeXbResult, "xsd:string"))
				{	soap_flag_GetMangeXbResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetMangeXbResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMangeXbResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMangeXbResponse, SOAP_TYPE__ns1__GetMangeXbResponse, sizeof(_ns1__GetMangeXbResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMangeXbResponse * SOAP_FMAC2 soap_instantiate__ns1__GetMangeXbResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMangeXbResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMangeXbResponse *p;
	size_t k = sizeof(_ns1__GetMangeXbResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetMangeXbResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetMangeXbResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetMangeXbResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMangeXbResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetMangeXbResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMangeXbResponse(soap, tag ? tag : "ns1:GetMangeXbResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMangeXbResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMangeXbResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMangeXbResponse * SOAP_FMAC4 soap_get__ns1__GetMangeXbResponse(struct soap *soap, _ns1__GetMangeXbResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMangeXbResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMangeXb::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetMangeXb::dwname);
	soap_default_string(soap, &this->_ns1__GetMangeXb::filename);
	/* transient soap skipped */
}

void _ns1__GetMangeXb::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMangeXb::dwname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMangeXb::filename);
#endif
}

int _ns1__GetMangeXb::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMangeXb(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMangeXb(struct soap *soap, const char *tag, int id, const _ns1__GetMangeXb *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMangeXb), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__GetMangeXb::dwname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, (char*const*)&a->_ns1__GetMangeXb::filename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMangeXb::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMangeXb(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMangeXb * SOAP_FMAC4 soap_in__ns1__GetMangeXb(struct soap *soap, const char *tag, _ns1__GetMangeXb *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMangeXb *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMangeXb, sizeof(_ns1__GetMangeXb), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMangeXb)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMangeXb *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dwname1 = 1;
	size_t soap_flag_filename1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__GetMangeXb::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:filename", (char**)&a->_ns1__GetMangeXb::filename, "xsd:string"))
				{	soap_flag_filename1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMangeXb *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMangeXb, SOAP_TYPE__ns1__GetMangeXb, sizeof(_ns1__GetMangeXb), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMangeXb * SOAP_FMAC2 soap_instantiate__ns1__GetMangeXb(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMangeXb(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMangeXb *p;
	size_t k = sizeof(_ns1__GetMangeXb);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetMangeXb, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetMangeXb);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetMangeXb, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMangeXb location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetMangeXb::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMangeXb(soap, tag ? tag : "ns1:GetMangeXb", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMangeXb::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMangeXb(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMangeXb * SOAP_FMAC4 soap_get__ns1__GetMangeXb(struct soap *soap, _ns1__GetMangeXb *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMangeXb(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMangeUnitResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetMangeUnitResponse::GetMangeUnitResult);
	/* transient soap skipped */
}

void _ns1__GetMangeUnitResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMangeUnitResponse::GetMangeUnitResult);
#endif
}

int _ns1__GetMangeUnitResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMangeUnitResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMangeUnitResponse(struct soap *soap, const char *tag, int id, const _ns1__GetMangeUnitResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMangeUnitResponse), type))
		return soap->error;
	if (a->GetMangeUnitResult)
		soap_element_result(soap, "ns1:GetMangeUnitResult");
	if (soap_out_string(soap, "ns1:GetMangeUnitResult", -1, (char*const*)&a->_ns1__GetMangeUnitResponse::GetMangeUnitResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMangeUnitResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMangeUnitResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMangeUnitResponse * SOAP_FMAC4 soap_in__ns1__GetMangeUnitResponse(struct soap *soap, const char *tag, _ns1__GetMangeUnitResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMangeUnitResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMangeUnitResponse, sizeof(_ns1__GetMangeUnitResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMangeUnitResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMangeUnitResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetMangeUnitResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetMangeUnitResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetMangeUnitResult", (char**)&a->_ns1__GetMangeUnitResponse::GetMangeUnitResult, "xsd:string"))
				{	soap_flag_GetMangeUnitResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetMangeUnitResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMangeUnitResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMangeUnitResponse, SOAP_TYPE__ns1__GetMangeUnitResponse, sizeof(_ns1__GetMangeUnitResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMangeUnitResponse * SOAP_FMAC2 soap_instantiate__ns1__GetMangeUnitResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMangeUnitResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMangeUnitResponse *p;
	size_t k = sizeof(_ns1__GetMangeUnitResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetMangeUnitResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetMangeUnitResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetMangeUnitResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMangeUnitResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetMangeUnitResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMangeUnitResponse(soap, tag ? tag : "ns1:GetMangeUnitResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMangeUnitResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMangeUnitResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMangeUnitResponse * SOAP_FMAC4 soap_get__ns1__GetMangeUnitResponse(struct soap *soap, _ns1__GetMangeUnitResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMangeUnitResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMangeUnit::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetMangeUnit::dwname);
	soap_default_string(soap, &this->_ns1__GetMangeUnit::filename);
	/* transient soap skipped */
}

void _ns1__GetMangeUnit::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMangeUnit::dwname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMangeUnit::filename);
#endif
}

int _ns1__GetMangeUnit::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMangeUnit(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMangeUnit(struct soap *soap, const char *tag, int id, const _ns1__GetMangeUnit *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMangeUnit), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__GetMangeUnit::dwname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, (char*const*)&a->_ns1__GetMangeUnit::filename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMangeUnit::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMangeUnit(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMangeUnit * SOAP_FMAC4 soap_in__ns1__GetMangeUnit(struct soap *soap, const char *tag, _ns1__GetMangeUnit *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMangeUnit *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMangeUnit, sizeof(_ns1__GetMangeUnit), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMangeUnit)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMangeUnit *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dwname1 = 1;
	size_t soap_flag_filename1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__GetMangeUnit::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:filename", (char**)&a->_ns1__GetMangeUnit::filename, "xsd:string"))
				{	soap_flag_filename1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMangeUnit *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMangeUnit, SOAP_TYPE__ns1__GetMangeUnit, sizeof(_ns1__GetMangeUnit), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMangeUnit * SOAP_FMAC2 soap_instantiate__ns1__GetMangeUnit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMangeUnit(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMangeUnit *p;
	size_t k = sizeof(_ns1__GetMangeUnit);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetMangeUnit, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetMangeUnit);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetMangeUnit, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMangeUnit location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetMangeUnit::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMangeUnit(soap, tag ? tag : "ns1:GetMangeUnit", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMangeUnit::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMangeUnit(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMangeUnit * SOAP_FMAC4 soap_get__ns1__GetMangeUnit(struct soap *soap, _ns1__GetMangeUnit *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMangeUnit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMaListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetMaListResponse::GetMaListResult);
	/* transient soap skipped */
}

void _ns1__GetMaListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMaListResponse::GetMaListResult);
#endif
}

int _ns1__GetMaListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMaListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMaListResponse(struct soap *soap, const char *tag, int id, const _ns1__GetMaListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMaListResponse), type))
		return soap->error;
	if (a->GetMaListResult)
		soap_element_result(soap, "ns1:GetMaListResult");
	if (soap_out_string(soap, "ns1:GetMaListResult", -1, (char*const*)&a->_ns1__GetMaListResponse::GetMaListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMaListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMaListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMaListResponse * SOAP_FMAC4 soap_in__ns1__GetMaListResponse(struct soap *soap, const char *tag, _ns1__GetMaListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMaListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMaListResponse, sizeof(_ns1__GetMaListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMaListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMaListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetMaListResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetMaListResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetMaListResult", (char**)&a->_ns1__GetMaListResponse::GetMaListResult, "xsd:string"))
				{	soap_flag_GetMaListResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetMaListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMaListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMaListResponse, SOAP_TYPE__ns1__GetMaListResponse, sizeof(_ns1__GetMaListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMaListResponse * SOAP_FMAC2 soap_instantiate__ns1__GetMaListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMaListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMaListResponse *p;
	size_t k = sizeof(_ns1__GetMaListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetMaListResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetMaListResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetMaListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMaListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetMaListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMaListResponse(soap, tag ? tag : "ns1:GetMaListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMaListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMaListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMaListResponse * SOAP_FMAC4 soap_get__ns1__GetMaListResponse(struct soap *soap, _ns1__GetMaListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMaListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMaList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetMaList::Lh);
	soap_default_string(soap, &this->_ns1__GetMaList::mapid);
	soap_default_string(soap, &this->_ns1__GetMaList::mflag);
	soap_default_string(soap, &this->_ns1__GetMaList::filename);
	/* transient soap skipped */
}

void _ns1__GetMaList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMaList::Lh);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMaList::mapid);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMaList::mflag);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMaList::filename);
#endif
}

int _ns1__GetMaList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMaList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMaList(struct soap *soap, const char *tag, int id, const _ns1__GetMaList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMaList), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Lh", -1, (char*const*)&a->_ns1__GetMaList::Lh, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:mapid", -1, (char*const*)&a->_ns1__GetMaList::mapid, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:mflag", -1, (char*const*)&a->_ns1__GetMaList::mflag, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, (char*const*)&a->_ns1__GetMaList::filename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMaList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMaList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMaList * SOAP_FMAC4 soap_in__ns1__GetMaList(struct soap *soap, const char *tag, _ns1__GetMaList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMaList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMaList, sizeof(_ns1__GetMaList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMaList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMaList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Lh1 = 1;
	size_t soap_flag_mapid1 = 1;
	size_t soap_flag_mflag1 = 1;
	size_t soap_flag_filename1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Lh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:Lh", (char**)&a->_ns1__GetMaList::Lh, "xsd:string"))
				{	soap_flag_Lh1--;
					continue;
				}
			}
			if (soap_flag_mapid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:mapid", (char**)&a->_ns1__GetMaList::mapid, "xsd:string"))
				{	soap_flag_mapid1--;
					continue;
				}
			}
			if (soap_flag_mflag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:mflag", (char**)&a->_ns1__GetMaList::mflag, "xsd:string"))
				{	soap_flag_mflag1--;
					continue;
				}
			}
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:filename", (char**)&a->_ns1__GetMaList::filename, "xsd:string"))
				{	soap_flag_filename1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMaList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMaList, SOAP_TYPE__ns1__GetMaList, sizeof(_ns1__GetMaList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMaList * SOAP_FMAC2 soap_instantiate__ns1__GetMaList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMaList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMaList *p;
	size_t k = sizeof(_ns1__GetMaList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetMaList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetMaList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetMaList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMaList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetMaList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMaList(soap, tag ? tag : "ns1:GetMaList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMaList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMaList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMaList * SOAP_FMAC4 soap_get__ns1__GetMaList(struct soap *soap, _ns1__GetMaList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMaList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMapDeviceDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetMapDeviceDataResponse::GetMapDeviceDataResult);
	/* transient soap skipped */
}

void _ns1__GetMapDeviceDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMapDeviceDataResponse::GetMapDeviceDataResult);
#endif
}

int _ns1__GetMapDeviceDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMapDeviceDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMapDeviceDataResponse(struct soap *soap, const char *tag, int id, const _ns1__GetMapDeviceDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMapDeviceDataResponse), type))
		return soap->error;
	if (a->GetMapDeviceDataResult)
		soap_element_result(soap, "ns1:GetMapDeviceDataResult");
	if (soap_out_string(soap, "ns1:GetMapDeviceDataResult", -1, (char*const*)&a->_ns1__GetMapDeviceDataResponse::GetMapDeviceDataResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMapDeviceDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMapDeviceDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMapDeviceDataResponse * SOAP_FMAC4 soap_in__ns1__GetMapDeviceDataResponse(struct soap *soap, const char *tag, _ns1__GetMapDeviceDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMapDeviceDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMapDeviceDataResponse, sizeof(_ns1__GetMapDeviceDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMapDeviceDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMapDeviceDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetMapDeviceDataResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetMapDeviceDataResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetMapDeviceDataResult", (char**)&a->_ns1__GetMapDeviceDataResponse::GetMapDeviceDataResult, "xsd:string"))
				{	soap_flag_GetMapDeviceDataResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetMapDeviceDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMapDeviceDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMapDeviceDataResponse, SOAP_TYPE__ns1__GetMapDeviceDataResponse, sizeof(_ns1__GetMapDeviceDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMapDeviceDataResponse * SOAP_FMAC2 soap_instantiate__ns1__GetMapDeviceDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMapDeviceDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMapDeviceDataResponse *p;
	size_t k = sizeof(_ns1__GetMapDeviceDataResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetMapDeviceDataResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetMapDeviceDataResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetMapDeviceDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMapDeviceDataResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetMapDeviceDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMapDeviceDataResponse(soap, tag ? tag : "ns1:GetMapDeviceDataResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMapDeviceDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMapDeviceDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMapDeviceDataResponse * SOAP_FMAC4 soap_get__ns1__GetMapDeviceDataResponse(struct soap *soap, _ns1__GetMapDeviceDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMapDeviceDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMapDeviceData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetMapDeviceData::tabname);
	soap_default_string(soap, &this->_ns1__GetMapDeviceData::Lh);
	soap_default_string(soap, &this->_ns1__GetMapDeviceData::mapid);
	soap_default_string(soap, &this->_ns1__GetMapDeviceData::filename);
	/* transient soap skipped */
}

void _ns1__GetMapDeviceData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMapDeviceData::tabname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMapDeviceData::Lh);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMapDeviceData::mapid);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMapDeviceData::filename);
#endif
}

int _ns1__GetMapDeviceData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMapDeviceData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMapDeviceData(struct soap *soap, const char *tag, int id, const _ns1__GetMapDeviceData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMapDeviceData), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:tabname", -1, (char*const*)&a->_ns1__GetMapDeviceData::tabname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Lh", -1, (char*const*)&a->_ns1__GetMapDeviceData::Lh, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:mapid", -1, (char*const*)&a->_ns1__GetMapDeviceData::mapid, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, (char*const*)&a->_ns1__GetMapDeviceData::filename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMapDeviceData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMapDeviceData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMapDeviceData * SOAP_FMAC4 soap_in__ns1__GetMapDeviceData(struct soap *soap, const char *tag, _ns1__GetMapDeviceData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMapDeviceData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMapDeviceData, sizeof(_ns1__GetMapDeviceData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMapDeviceData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMapDeviceData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_tabname1 = 1;
	size_t soap_flag_Lh1 = 1;
	size_t soap_flag_mapid1 = 1;
	size_t soap_flag_filename1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tabname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:tabname", (char**)&a->_ns1__GetMapDeviceData::tabname, "xsd:string"))
				{	soap_flag_tabname1--;
					continue;
				}
			}
			if (soap_flag_Lh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:Lh", (char**)&a->_ns1__GetMapDeviceData::Lh, "xsd:string"))
				{	soap_flag_Lh1--;
					continue;
				}
			}
			if (soap_flag_mapid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:mapid", (char**)&a->_ns1__GetMapDeviceData::mapid, "xsd:string"))
				{	soap_flag_mapid1--;
					continue;
				}
			}
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:filename", (char**)&a->_ns1__GetMapDeviceData::filename, "xsd:string"))
				{	soap_flag_filename1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMapDeviceData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMapDeviceData, SOAP_TYPE__ns1__GetMapDeviceData, sizeof(_ns1__GetMapDeviceData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMapDeviceData * SOAP_FMAC2 soap_instantiate__ns1__GetMapDeviceData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMapDeviceData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMapDeviceData *p;
	size_t k = sizeof(_ns1__GetMapDeviceData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetMapDeviceData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetMapDeviceData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetMapDeviceData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMapDeviceData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetMapDeviceData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMapDeviceData(soap, tag ? tag : "ns1:GetMapDeviceData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMapDeviceData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMapDeviceData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMapDeviceData * SOAP_FMAC4 soap_get__ns1__GetMapDeviceData(struct soap *soap, _ns1__GetMapDeviceData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMapDeviceData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMapTabNameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetMapTabNameResponse::GetMapTabNameResult);
	/* transient soap skipped */
}

void _ns1__GetMapTabNameResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMapTabNameResponse::GetMapTabNameResult);
#endif
}

int _ns1__GetMapTabNameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMapTabNameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMapTabNameResponse(struct soap *soap, const char *tag, int id, const _ns1__GetMapTabNameResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMapTabNameResponse), type))
		return soap->error;
	if (a->GetMapTabNameResult)
		soap_element_result(soap, "ns1:GetMapTabNameResult");
	if (soap_out_string(soap, "ns1:GetMapTabNameResult", -1, (char*const*)&a->_ns1__GetMapTabNameResponse::GetMapTabNameResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMapTabNameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMapTabNameResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMapTabNameResponse * SOAP_FMAC4 soap_in__ns1__GetMapTabNameResponse(struct soap *soap, const char *tag, _ns1__GetMapTabNameResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMapTabNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMapTabNameResponse, sizeof(_ns1__GetMapTabNameResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMapTabNameResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMapTabNameResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetMapTabNameResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetMapTabNameResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetMapTabNameResult", (char**)&a->_ns1__GetMapTabNameResponse::GetMapTabNameResult, "xsd:string"))
				{	soap_flag_GetMapTabNameResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetMapTabNameResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMapTabNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMapTabNameResponse, SOAP_TYPE__ns1__GetMapTabNameResponse, sizeof(_ns1__GetMapTabNameResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMapTabNameResponse * SOAP_FMAC2 soap_instantiate__ns1__GetMapTabNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMapTabNameResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMapTabNameResponse *p;
	size_t k = sizeof(_ns1__GetMapTabNameResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetMapTabNameResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetMapTabNameResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetMapTabNameResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMapTabNameResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetMapTabNameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMapTabNameResponse(soap, tag ? tag : "ns1:GetMapTabNameResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMapTabNameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMapTabNameResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMapTabNameResponse * SOAP_FMAC4 soap_get__ns1__GetMapTabNameResponse(struct soap *soap, _ns1__GetMapTabNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMapTabNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMapTabName::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetMapTabName::maptype);
	soap_default_string(soap, &this->_ns1__GetMapTabName::filename);
	/* transient soap skipped */
}

void _ns1__GetMapTabName::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMapTabName::maptype);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMapTabName::filename);
#endif
}

int _ns1__GetMapTabName::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMapTabName(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMapTabName(struct soap *soap, const char *tag, int id, const _ns1__GetMapTabName *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMapTabName), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:maptype", -1, (char*const*)&a->_ns1__GetMapTabName::maptype, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, (char*const*)&a->_ns1__GetMapTabName::filename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMapTabName::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMapTabName(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMapTabName * SOAP_FMAC4 soap_in__ns1__GetMapTabName(struct soap *soap, const char *tag, _ns1__GetMapTabName *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMapTabName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMapTabName, sizeof(_ns1__GetMapTabName), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMapTabName)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMapTabName *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_maptype1 = 1;
	size_t soap_flag_filename1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_maptype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:maptype", (char**)&a->_ns1__GetMapTabName::maptype, "xsd:string"))
				{	soap_flag_maptype1--;
					continue;
				}
			}
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:filename", (char**)&a->_ns1__GetMapTabName::filename, "xsd:string"))
				{	soap_flag_filename1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMapTabName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMapTabName, SOAP_TYPE__ns1__GetMapTabName, sizeof(_ns1__GetMapTabName), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMapTabName * SOAP_FMAC2 soap_instantiate__ns1__GetMapTabName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMapTabName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMapTabName *p;
	size_t k = sizeof(_ns1__GetMapTabName);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetMapTabName, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetMapTabName);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetMapTabName, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMapTabName location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetMapTabName::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMapTabName(soap, tag ? tag : "ns1:GetMapTabName", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMapTabName::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMapTabName(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMapTabName * SOAP_FMAC4 soap_get__ns1__GetMapTabName(struct soap *soap, _ns1__GetMapTabName *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMapTabName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMapUpdateTimeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetMapUpdateTimeResponse::GetMapUpdateTimeResult);
	/* transient soap skipped */
}

void _ns1__GetMapUpdateTimeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMapUpdateTimeResponse::GetMapUpdateTimeResult);
#endif
}

int _ns1__GetMapUpdateTimeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMapUpdateTimeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMapUpdateTimeResponse(struct soap *soap, const char *tag, int id, const _ns1__GetMapUpdateTimeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMapUpdateTimeResponse), type))
		return soap->error;
	if (a->GetMapUpdateTimeResult)
		soap_element_result(soap, "ns1:GetMapUpdateTimeResult");
	if (soap_out_string(soap, "ns1:GetMapUpdateTimeResult", -1, (char*const*)&a->_ns1__GetMapUpdateTimeResponse::GetMapUpdateTimeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMapUpdateTimeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMapUpdateTimeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMapUpdateTimeResponse * SOAP_FMAC4 soap_in__ns1__GetMapUpdateTimeResponse(struct soap *soap, const char *tag, _ns1__GetMapUpdateTimeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMapUpdateTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMapUpdateTimeResponse, sizeof(_ns1__GetMapUpdateTimeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMapUpdateTimeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMapUpdateTimeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetMapUpdateTimeResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetMapUpdateTimeResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetMapUpdateTimeResult", (char**)&a->_ns1__GetMapUpdateTimeResponse::GetMapUpdateTimeResult, "xsd:string"))
				{	soap_flag_GetMapUpdateTimeResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetMapUpdateTimeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMapUpdateTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMapUpdateTimeResponse, SOAP_TYPE__ns1__GetMapUpdateTimeResponse, sizeof(_ns1__GetMapUpdateTimeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMapUpdateTimeResponse * SOAP_FMAC2 soap_instantiate__ns1__GetMapUpdateTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMapUpdateTimeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMapUpdateTimeResponse *p;
	size_t k = sizeof(_ns1__GetMapUpdateTimeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetMapUpdateTimeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetMapUpdateTimeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetMapUpdateTimeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMapUpdateTimeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetMapUpdateTimeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMapUpdateTimeResponse(soap, tag ? tag : "ns1:GetMapUpdateTimeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMapUpdateTimeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMapUpdateTimeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMapUpdateTimeResponse * SOAP_FMAC4 soap_get__ns1__GetMapUpdateTimeResponse(struct soap *soap, _ns1__GetMapUpdateTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMapUpdateTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMapUpdateTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetMapUpdateTime::uptime);
	soap_default_string(soap, &this->_ns1__GetMapUpdateTime::dwname);
	soap_default_string(soap, &this->_ns1__GetMapUpdateTime::filename);
	/* transient soap skipped */
}

void _ns1__GetMapUpdateTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMapUpdateTime::uptime);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMapUpdateTime::dwname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMapUpdateTime::filename);
#endif
}

int _ns1__GetMapUpdateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMapUpdateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMapUpdateTime(struct soap *soap, const char *tag, int id, const _ns1__GetMapUpdateTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMapUpdateTime), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:uptime", -1, (char*const*)&a->_ns1__GetMapUpdateTime::uptime, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__GetMapUpdateTime::dwname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, (char*const*)&a->_ns1__GetMapUpdateTime::filename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMapUpdateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMapUpdateTime(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMapUpdateTime * SOAP_FMAC4 soap_in__ns1__GetMapUpdateTime(struct soap *soap, const char *tag, _ns1__GetMapUpdateTime *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMapUpdateTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMapUpdateTime, sizeof(_ns1__GetMapUpdateTime), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMapUpdateTime)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMapUpdateTime *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_uptime1 = 1;
	size_t soap_flag_dwname1 = 1;
	size_t soap_flag_filename1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uptime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:uptime", (char**)&a->_ns1__GetMapUpdateTime::uptime, "xsd:string"))
				{	soap_flag_uptime1--;
					continue;
				}
			}
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__GetMapUpdateTime::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:filename", (char**)&a->_ns1__GetMapUpdateTime::filename, "xsd:string"))
				{	soap_flag_filename1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMapUpdateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMapUpdateTime, SOAP_TYPE__ns1__GetMapUpdateTime, sizeof(_ns1__GetMapUpdateTime), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMapUpdateTime * SOAP_FMAC2 soap_instantiate__ns1__GetMapUpdateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMapUpdateTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMapUpdateTime *p;
	size_t k = sizeof(_ns1__GetMapUpdateTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetMapUpdateTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetMapUpdateTime);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetMapUpdateTime, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMapUpdateTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetMapUpdateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMapUpdateTime(soap, tag ? tag : "ns1:GetMapUpdateTime", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMapUpdateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMapUpdateTime(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMapUpdateTime * SOAP_FMAC4 soap_get__ns1__GetMapUpdateTime(struct soap *soap, _ns1__GetMapUpdateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMapUpdateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__WriteFileResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__WriteFileResponse::WriteFileResult);
	/* transient soap skipped */
}

void _ns1__WriteFileResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__WriteFileResponse::WriteFileResult);
#endif
}

int _ns1__WriteFileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__WriteFileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__WriteFileResponse(struct soap *soap, const char *tag, int id, const _ns1__WriteFileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__WriteFileResponse), type))
		return soap->error;
	if (a->WriteFileResult)
		soap_element_result(soap, "ns1:WriteFileResult");
	if (soap_out_string(soap, "ns1:WriteFileResult", -1, (char*const*)&a->_ns1__WriteFileResponse::WriteFileResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__WriteFileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__WriteFileResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__WriteFileResponse * SOAP_FMAC4 soap_in__ns1__WriteFileResponse(struct soap *soap, const char *tag, _ns1__WriteFileResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__WriteFileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__WriteFileResponse, sizeof(_ns1__WriteFileResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__WriteFileResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__WriteFileResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_WriteFileResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WriteFileResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:WriteFileResult", (char**)&a->_ns1__WriteFileResponse::WriteFileResult, "xsd:string"))
				{	soap_flag_WriteFileResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:WriteFileResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__WriteFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__WriteFileResponse, SOAP_TYPE__ns1__WriteFileResponse, sizeof(_ns1__WriteFileResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__WriteFileResponse * SOAP_FMAC2 soap_instantiate__ns1__WriteFileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__WriteFileResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__WriteFileResponse *p;
	size_t k = sizeof(_ns1__WriteFileResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__WriteFileResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__WriteFileResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__WriteFileResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__WriteFileResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__WriteFileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__WriteFileResponse(soap, tag ? tag : "ns1:WriteFileResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__WriteFileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__WriteFileResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__WriteFileResponse * SOAP_FMAC4 soap_get__ns1__WriteFileResponse(struct soap *soap, _ns1__WriteFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__WriteFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__WriteFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__WriteFile::msg);
	soap_default_string(soap, &this->_ns1__WriteFile::filename);
	/* transient soap skipped */
}

void _ns1__WriteFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__WriteFile::msg);
	soap_serialize_string(soap, (char*const*)&this->_ns1__WriteFile::filename);
#endif
}

int _ns1__WriteFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__WriteFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__WriteFile(struct soap *soap, const char *tag, int id, const _ns1__WriteFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__WriteFile), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:msg", -1, (char*const*)&a->_ns1__WriteFile::msg, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, (char*const*)&a->_ns1__WriteFile::filename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__WriteFile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__WriteFile(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__WriteFile * SOAP_FMAC4 soap_in__ns1__WriteFile(struct soap *soap, const char *tag, _ns1__WriteFile *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__WriteFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__WriteFile, sizeof(_ns1__WriteFile), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__WriteFile)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__WriteFile *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_msg1 = 1;
	size_t soap_flag_filename1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_msg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:msg", (char**)&a->_ns1__WriteFile::msg, "xsd:string"))
				{	soap_flag_msg1--;
					continue;
				}
			}
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:filename", (char**)&a->_ns1__WriteFile::filename, "xsd:string"))
				{	soap_flag_filename1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__WriteFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__WriteFile, SOAP_TYPE__ns1__WriteFile, sizeof(_ns1__WriteFile), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__WriteFile * SOAP_FMAC2 soap_instantiate__ns1__WriteFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__WriteFile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__WriteFile *p;
	size_t k = sizeof(_ns1__WriteFile);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__WriteFile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__WriteFile);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__WriteFile, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__WriteFile location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__WriteFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__WriteFile(soap, tag ? tag : "ns1:WriteFile", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__WriteFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__WriteFile(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__WriteFile * SOAP_FMAC4 soap_get__ns1__WriteFile(struct soap *soap, _ns1__WriteFile *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__WriteFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DownLoadFileResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__DownLoadFileResponse::DownLoadFileResult);
	/* transient soap skipped */
}

void _ns1__DownLoadFileResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__DownLoadFileResponse::DownLoadFileResult);
#endif
}

int _ns1__DownLoadFileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DownLoadFileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DownLoadFileResponse(struct soap *soap, const char *tag, int id, const _ns1__DownLoadFileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DownLoadFileResponse), type))
		return soap->error;
	if (a->DownLoadFileResult)
		soap_element_result(soap, "ns1:DownLoadFileResult");
	if (soap_out_string(soap, "ns1:DownLoadFileResult", -1, (char*const*)&a->_ns1__DownLoadFileResponse::DownLoadFileResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DownLoadFileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DownLoadFileResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DownLoadFileResponse * SOAP_FMAC4 soap_in__ns1__DownLoadFileResponse(struct soap *soap, const char *tag, _ns1__DownLoadFileResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DownLoadFileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DownLoadFileResponse, sizeof(_ns1__DownLoadFileResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__DownLoadFileResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__DownLoadFileResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DownLoadFileResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DownLoadFileResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:DownLoadFileResult", (char**)&a->_ns1__DownLoadFileResponse::DownLoadFileResult, "xsd:string"))
				{	soap_flag_DownLoadFileResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:DownLoadFileResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DownLoadFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DownLoadFileResponse, SOAP_TYPE__ns1__DownLoadFileResponse, sizeof(_ns1__DownLoadFileResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DownLoadFileResponse * SOAP_FMAC2 soap_instantiate__ns1__DownLoadFileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DownLoadFileResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DownLoadFileResponse *p;
	size_t k = sizeof(_ns1__DownLoadFileResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__DownLoadFileResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__DownLoadFileResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__DownLoadFileResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DownLoadFileResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__DownLoadFileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__DownLoadFileResponse(soap, tag ? tag : "ns1:DownLoadFileResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DownLoadFileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DownLoadFileResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DownLoadFileResponse * SOAP_FMAC4 soap_get__ns1__DownLoadFileResponse(struct soap *soap, _ns1__DownLoadFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DownLoadFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DownLoadFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__DownLoadFile::dwname);
	soap_default_string(soap, &this->_ns1__DownLoadFile::filename);
	soap_default_string(soap, &this->_ns1__DownLoadFile::dir);
	/* transient soap skipped */
}

void _ns1__DownLoadFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__DownLoadFile::dwname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__DownLoadFile::filename);
	soap_serialize_string(soap, (char*const*)&this->_ns1__DownLoadFile::dir);
#endif
}

int _ns1__DownLoadFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DownLoadFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DownLoadFile(struct soap *soap, const char *tag, int id, const _ns1__DownLoadFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DownLoadFile), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__DownLoadFile::dwname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, (char*const*)&a->_ns1__DownLoadFile::filename, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:dir", -1, (char*const*)&a->_ns1__DownLoadFile::dir, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DownLoadFile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DownLoadFile(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DownLoadFile * SOAP_FMAC4 soap_in__ns1__DownLoadFile(struct soap *soap, const char *tag, _ns1__DownLoadFile *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DownLoadFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DownLoadFile, sizeof(_ns1__DownLoadFile), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__DownLoadFile)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__DownLoadFile *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dwname1 = 1;
	size_t soap_flag_filename1 = 1;
	size_t soap_flag_dir1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__DownLoadFile::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:filename", (char**)&a->_ns1__DownLoadFile::filename, "xsd:string"))
				{	soap_flag_filename1--;
					continue;
				}
			}
			if (soap_flag_dir1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dir", (char**)&a->_ns1__DownLoadFile::dir, "xsd:string"))
				{	soap_flag_dir1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DownLoadFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DownLoadFile, SOAP_TYPE__ns1__DownLoadFile, sizeof(_ns1__DownLoadFile), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DownLoadFile * SOAP_FMAC2 soap_instantiate__ns1__DownLoadFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DownLoadFile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DownLoadFile *p;
	size_t k = sizeof(_ns1__DownLoadFile);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__DownLoadFile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__DownLoadFile);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__DownLoadFile, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DownLoadFile location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__DownLoadFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__DownLoadFile(soap, tag ? tag : "ns1:DownLoadFile", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DownLoadFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DownLoadFile(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DownLoadFile * SOAP_FMAC4 soap_get__ns1__DownLoadFile(struct soap *soap, _ns1__DownLoadFile *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DownLoadFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ExecuteSqlForFileResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__ExecuteSqlForFileResponse::ExecuteSqlForFileResult);
	/* transient soap skipped */
}

void _ns1__ExecuteSqlForFileResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__ExecuteSqlForFileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ExecuteSqlForFileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ExecuteSqlForFileResponse(struct soap *soap, const char *tag, int id, const _ns1__ExecuteSqlForFileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ExecuteSqlForFileResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:ExecuteSqlForFileResult");
	if (soap_out_int(soap, "ns1:ExecuteSqlForFileResult", -1, &a->_ns1__ExecuteSqlForFileResponse::ExecuteSqlForFileResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ExecuteSqlForFileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ExecuteSqlForFileResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ExecuteSqlForFileResponse * SOAP_FMAC4 soap_in__ns1__ExecuteSqlForFileResponse(struct soap *soap, const char *tag, _ns1__ExecuteSqlForFileResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ExecuteSqlForFileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ExecuteSqlForFileResponse, sizeof(_ns1__ExecuteSqlForFileResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ExecuteSqlForFileResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ExecuteSqlForFileResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ExecuteSqlForFileResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ExecuteSqlForFileResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:ExecuteSqlForFileResult", &a->_ns1__ExecuteSqlForFileResponse::ExecuteSqlForFileResult, "xsd:int"))
				{	soap_flag_ExecuteSqlForFileResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:ExecuteSqlForFileResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ExecuteSqlForFileResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__ExecuteSqlForFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ExecuteSqlForFileResponse, SOAP_TYPE__ns1__ExecuteSqlForFileResponse, sizeof(_ns1__ExecuteSqlForFileResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ExecuteSqlForFileResponse * SOAP_FMAC2 soap_instantiate__ns1__ExecuteSqlForFileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ExecuteSqlForFileResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ExecuteSqlForFileResponse *p;
	size_t k = sizeof(_ns1__ExecuteSqlForFileResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ExecuteSqlForFileResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ExecuteSqlForFileResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ExecuteSqlForFileResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ExecuteSqlForFileResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ExecuteSqlForFileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ExecuteSqlForFileResponse(soap, tag ? tag : "ns1:ExecuteSqlForFileResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ExecuteSqlForFileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ExecuteSqlForFileResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ExecuteSqlForFileResponse * SOAP_FMAC4 soap_get__ns1__ExecuteSqlForFileResponse(struct soap *soap, _ns1__ExecuteSqlForFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ExecuteSqlForFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ExecuteSqlForFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__ExecuteSqlForFile::xml);
	soap_default_string(soap, &this->_ns1__ExecuteSqlForFile::filename);
	soap_default_string(soap, &this->_ns1__ExecuteSqlForFile::fieldValue);
	soap_default_string(soap, &this->_ns1__ExecuteSqlForFile::dwname);
	soap_default_string(soap, &this->_ns1__ExecuteSqlForFile::dirname);
	/* transient soap skipped */
}

void _ns1__ExecuteSqlForFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__ExecuteSqlForFile::xml);
	soap_serialize_string(soap, (char*const*)&this->_ns1__ExecuteSqlForFile::filename);
	soap_serialize_string(soap, (char*const*)&this->_ns1__ExecuteSqlForFile::fieldValue);
	soap_serialize_string(soap, (char*const*)&this->_ns1__ExecuteSqlForFile::dwname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__ExecuteSqlForFile::dirname);
#endif
}

int _ns1__ExecuteSqlForFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ExecuteSqlForFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ExecuteSqlForFile(struct soap *soap, const char *tag, int id, const _ns1__ExecuteSqlForFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ExecuteSqlForFile), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xml", -1, (char*const*)&a->_ns1__ExecuteSqlForFile::xml, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, (char*const*)&a->_ns1__ExecuteSqlForFile::filename, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:fieldValue", -1, (char*const*)&a->_ns1__ExecuteSqlForFile::fieldValue, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__ExecuteSqlForFile::dwname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:dirname", -1, (char*const*)&a->_ns1__ExecuteSqlForFile::dirname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ExecuteSqlForFile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ExecuteSqlForFile(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ExecuteSqlForFile * SOAP_FMAC4 soap_in__ns1__ExecuteSqlForFile(struct soap *soap, const char *tag, _ns1__ExecuteSqlForFile *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ExecuteSqlForFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ExecuteSqlForFile, sizeof(_ns1__ExecuteSqlForFile), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ExecuteSqlForFile)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ExecuteSqlForFile *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_xml1 = 1;
	size_t soap_flag_filename1 = 1;
	size_t soap_flag_fieldValue1 = 1;
	size_t soap_flag_dwname1 = 1;
	size_t soap_flag_dirname1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xml1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:xml", (char**)&a->_ns1__ExecuteSqlForFile::xml, "xsd:string"))
				{	soap_flag_xml1--;
					continue;
				}
			}
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:filename", (char**)&a->_ns1__ExecuteSqlForFile::filename, "xsd:string"))
				{	soap_flag_filename1--;
					continue;
				}
			}
			if (soap_flag_fieldValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:fieldValue", (char**)&a->_ns1__ExecuteSqlForFile::fieldValue, "xsd:string"))
				{	soap_flag_fieldValue1--;
					continue;
				}
			}
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__ExecuteSqlForFile::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap_flag_dirname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dirname", (char**)&a->_ns1__ExecuteSqlForFile::dirname, "xsd:string"))
				{	soap_flag_dirname1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ExecuteSqlForFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ExecuteSqlForFile, SOAP_TYPE__ns1__ExecuteSqlForFile, sizeof(_ns1__ExecuteSqlForFile), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ExecuteSqlForFile * SOAP_FMAC2 soap_instantiate__ns1__ExecuteSqlForFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ExecuteSqlForFile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ExecuteSqlForFile *p;
	size_t k = sizeof(_ns1__ExecuteSqlForFile);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ExecuteSqlForFile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ExecuteSqlForFile);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ExecuteSqlForFile, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ExecuteSqlForFile location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ExecuteSqlForFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ExecuteSqlForFile(soap, tag ? tag : "ns1:ExecuteSqlForFile", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ExecuteSqlForFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ExecuteSqlForFile(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ExecuteSqlForFile * SOAP_FMAC4 soap_get__ns1__ExecuteSqlForFile(struct soap *soap, _ns1__ExecuteSqlForFile *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ExecuteSqlForFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetFieldInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetFieldInfoResponse::GetFieldInfoResult);
	/* transient soap skipped */
}

void _ns1__GetFieldInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetFieldInfoResponse::GetFieldInfoResult);
#endif
}

int _ns1__GetFieldInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetFieldInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetFieldInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetFieldInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetFieldInfoResponse), type))
		return soap->error;
	if (a->GetFieldInfoResult)
		soap_element_result(soap, "ns1:GetFieldInfoResult");
	if (soap_out_string(soap, "ns1:GetFieldInfoResult", -1, (char*const*)&a->_ns1__GetFieldInfoResponse::GetFieldInfoResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetFieldInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetFieldInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetFieldInfoResponse * SOAP_FMAC4 soap_in__ns1__GetFieldInfoResponse(struct soap *soap, const char *tag, _ns1__GetFieldInfoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetFieldInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetFieldInfoResponse, sizeof(_ns1__GetFieldInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetFieldInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetFieldInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetFieldInfoResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetFieldInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetFieldInfoResult", (char**)&a->_ns1__GetFieldInfoResponse::GetFieldInfoResult, "xsd:string"))
				{	soap_flag_GetFieldInfoResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetFieldInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetFieldInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetFieldInfoResponse, SOAP_TYPE__ns1__GetFieldInfoResponse, sizeof(_ns1__GetFieldInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetFieldInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__GetFieldInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetFieldInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetFieldInfoResponse *p;
	size_t k = sizeof(_ns1__GetFieldInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetFieldInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetFieldInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetFieldInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetFieldInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetFieldInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetFieldInfoResponse(soap, tag ? tag : "ns1:GetFieldInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetFieldInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetFieldInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetFieldInfoResponse * SOAP_FMAC4 soap_get__ns1__GetFieldInfoResponse(struct soap *soap, _ns1__GetFieldInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetFieldInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetFieldInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetFieldInfo::tabname);
	/* transient soap skipped */
}

void _ns1__GetFieldInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetFieldInfo::tabname);
#endif
}

int _ns1__GetFieldInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetFieldInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetFieldInfo(struct soap *soap, const char *tag, int id, const _ns1__GetFieldInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetFieldInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:tabname", -1, (char*const*)&a->_ns1__GetFieldInfo::tabname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetFieldInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetFieldInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetFieldInfo * SOAP_FMAC4 soap_in__ns1__GetFieldInfo(struct soap *soap, const char *tag, _ns1__GetFieldInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetFieldInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetFieldInfo, sizeof(_ns1__GetFieldInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetFieldInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetFieldInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_tabname1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tabname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:tabname", (char**)&a->_ns1__GetFieldInfo::tabname, "xsd:string"))
				{	soap_flag_tabname1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetFieldInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetFieldInfo, SOAP_TYPE__ns1__GetFieldInfo, sizeof(_ns1__GetFieldInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetFieldInfo * SOAP_FMAC2 soap_instantiate__ns1__GetFieldInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetFieldInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetFieldInfo *p;
	size_t k = sizeof(_ns1__GetFieldInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetFieldInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetFieldInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetFieldInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetFieldInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetFieldInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetFieldInfo(soap, tag ? tag : "ns1:GetFieldInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetFieldInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetFieldInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetFieldInfo * SOAP_FMAC4 soap_get__ns1__GetFieldInfo(struct soap *soap, _ns1__GetFieldInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetFieldInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__IsOracleTableResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__IsOracleTableResponse::IsOracleTableResult);
	/* transient soap skipped */
}

void _ns1__IsOracleTableResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__IsOracleTableResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__IsOracleTableResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__IsOracleTableResponse(struct soap *soap, const char *tag, int id, const _ns1__IsOracleTableResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__IsOracleTableResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:IsOracleTableResult");
	if (soap_out_int(soap, "ns1:IsOracleTableResult", -1, &a->_ns1__IsOracleTableResponse::IsOracleTableResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__IsOracleTableResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__IsOracleTableResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__IsOracleTableResponse * SOAP_FMAC4 soap_in__ns1__IsOracleTableResponse(struct soap *soap, const char *tag, _ns1__IsOracleTableResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__IsOracleTableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__IsOracleTableResponse, sizeof(_ns1__IsOracleTableResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__IsOracleTableResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__IsOracleTableResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_IsOracleTableResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IsOracleTableResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:IsOracleTableResult", &a->_ns1__IsOracleTableResponse::IsOracleTableResult, "xsd:int"))
				{	soap_flag_IsOracleTableResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:IsOracleTableResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IsOracleTableResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__IsOracleTableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__IsOracleTableResponse, SOAP_TYPE__ns1__IsOracleTableResponse, sizeof(_ns1__IsOracleTableResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__IsOracleTableResponse * SOAP_FMAC2 soap_instantiate__ns1__IsOracleTableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__IsOracleTableResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__IsOracleTableResponse *p;
	size_t k = sizeof(_ns1__IsOracleTableResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__IsOracleTableResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__IsOracleTableResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__IsOracleTableResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__IsOracleTableResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__IsOracleTableResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__IsOracleTableResponse(soap, tag ? tag : "ns1:IsOracleTableResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__IsOracleTableResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__IsOracleTableResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__IsOracleTableResponse * SOAP_FMAC4 soap_get__ns1__IsOracleTableResponse(struct soap *soap, _ns1__IsOracleTableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__IsOracleTableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__IsOracleTable::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__IsOracleTable::tabname);
	/* transient soap skipped */
}

void _ns1__IsOracleTable::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__IsOracleTable::tabname);
#endif
}

int _ns1__IsOracleTable::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__IsOracleTable(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__IsOracleTable(struct soap *soap, const char *tag, int id, const _ns1__IsOracleTable *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__IsOracleTable), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:tabname", -1, (char*const*)&a->_ns1__IsOracleTable::tabname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__IsOracleTable::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__IsOracleTable(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__IsOracleTable * SOAP_FMAC4 soap_in__ns1__IsOracleTable(struct soap *soap, const char *tag, _ns1__IsOracleTable *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__IsOracleTable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__IsOracleTable, sizeof(_ns1__IsOracleTable), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__IsOracleTable)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__IsOracleTable *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_tabname1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tabname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:tabname", (char**)&a->_ns1__IsOracleTable::tabname, "xsd:string"))
				{	soap_flag_tabname1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__IsOracleTable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__IsOracleTable, SOAP_TYPE__ns1__IsOracleTable, sizeof(_ns1__IsOracleTable), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__IsOracleTable * SOAP_FMAC2 soap_instantiate__ns1__IsOracleTable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__IsOracleTable(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__IsOracleTable *p;
	size_t k = sizeof(_ns1__IsOracleTable);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__IsOracleTable, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__IsOracleTable);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__IsOracleTable, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__IsOracleTable location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__IsOracleTable::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__IsOracleTable(soap, tag ? tag : "ns1:IsOracleTable", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__IsOracleTable::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__IsOracleTable(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__IsOracleTable * SOAP_FMAC4 soap_get__ns1__IsOracleTable(struct soap *soap, _ns1__IsOracleTable *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__IsOracleTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetTabListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetTabListResponse::GetTabListResult);
	/* transient soap skipped */
}

void _ns1__GetTabListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetTabListResponse::GetTabListResult);
#endif
}

int _ns1__GetTabListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetTabListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetTabListResponse(struct soap *soap, const char *tag, int id, const _ns1__GetTabListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetTabListResponse), type))
		return soap->error;
	if (a->GetTabListResult)
		soap_element_result(soap, "ns1:GetTabListResult");
	if (soap_out_string(soap, "ns1:GetTabListResult", -1, (char*const*)&a->_ns1__GetTabListResponse::GetTabListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetTabListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetTabListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetTabListResponse * SOAP_FMAC4 soap_in__ns1__GetTabListResponse(struct soap *soap, const char *tag, _ns1__GetTabListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetTabListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetTabListResponse, sizeof(_ns1__GetTabListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetTabListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetTabListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetTabListResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetTabListResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetTabListResult", (char**)&a->_ns1__GetTabListResponse::GetTabListResult, "xsd:string"))
				{	soap_flag_GetTabListResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetTabListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetTabListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetTabListResponse, SOAP_TYPE__ns1__GetTabListResponse, sizeof(_ns1__GetTabListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetTabListResponse * SOAP_FMAC2 soap_instantiate__ns1__GetTabListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetTabListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetTabListResponse *p;
	size_t k = sizeof(_ns1__GetTabListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetTabListResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetTabListResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetTabListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetTabListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetTabListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetTabListResponse(soap, tag ? tag : "ns1:GetTabListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetTabListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetTabListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetTabListResponse * SOAP_FMAC4 soap_get__ns1__GetTabListResponse(struct soap *soap, _ns1__GetTabListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetTabListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetTabList::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetTabList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetTabList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetTabList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetTabList(struct soap *soap, const char *tag, int id, const _ns1__GetTabList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetTabList), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetTabList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetTabList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetTabList * SOAP_FMAC4 soap_in__ns1__GetTabList(struct soap *soap, const char *tag, _ns1__GetTabList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetTabList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetTabList, sizeof(_ns1__GetTabList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetTabList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetTabList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetTabList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetTabList, SOAP_TYPE__ns1__GetTabList, sizeof(_ns1__GetTabList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetTabList * SOAP_FMAC2 soap_instantiate__ns1__GetTabList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetTabList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetTabList *p;
	size_t k = sizeof(_ns1__GetTabList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetTabList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetTabList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetTabList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetTabList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetTabList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetTabList(soap, tag ? tag : "ns1:GetTabList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetTabList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetTabList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetTabList * SOAP_FMAC4 soap_get__ns1__GetTabList(struct soap *soap, _ns1__GetTabList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetTabList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DownCQDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__DownCQDataResponse::DownCQDataResult);
	/* transient soap skipped */
}

void _ns1__DownCQDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__DownCQDataResponse::DownCQDataResult);
#endif
}

int _ns1__DownCQDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DownCQDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DownCQDataResponse(struct soap *soap, const char *tag, int id, const _ns1__DownCQDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DownCQDataResponse), type))
		return soap->error;
	if (a->DownCQDataResult)
		soap_element_result(soap, "ns1:DownCQDataResult");
	if (soap_out_string(soap, "ns1:DownCQDataResult", -1, (char*const*)&a->_ns1__DownCQDataResponse::DownCQDataResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DownCQDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DownCQDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DownCQDataResponse * SOAP_FMAC4 soap_in__ns1__DownCQDataResponse(struct soap *soap, const char *tag, _ns1__DownCQDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DownCQDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DownCQDataResponse, sizeof(_ns1__DownCQDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__DownCQDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__DownCQDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DownCQDataResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DownCQDataResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:DownCQDataResult", (char**)&a->_ns1__DownCQDataResponse::DownCQDataResult, "xsd:string"))
				{	soap_flag_DownCQDataResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:DownCQDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DownCQDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DownCQDataResponse, SOAP_TYPE__ns1__DownCQDataResponse, sizeof(_ns1__DownCQDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DownCQDataResponse * SOAP_FMAC2 soap_instantiate__ns1__DownCQDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DownCQDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DownCQDataResponse *p;
	size_t k = sizeof(_ns1__DownCQDataResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__DownCQDataResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__DownCQDataResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__DownCQDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DownCQDataResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__DownCQDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__DownCQDataResponse(soap, tag ? tag : "ns1:DownCQDataResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DownCQDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DownCQDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DownCQDataResponse * SOAP_FMAC4 soap_get__ns1__DownCQDataResponse(struct soap *soap, _ns1__DownCQDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DownCQDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DownCQData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__DownCQData::dwname);
	soap_default_int(soap, &this->_ns1__DownCQData::orglevel);
	soap_default_string(soap, &this->_ns1__DownCQData::tabname);
	soap_default_string(soap, &this->_ns1__DownCQData::time);
	soap_default_string(soap, &this->_ns1__DownCQData::filename);
	/* transient soap skipped */
}

void _ns1__DownCQData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__DownCQData::dwname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__DownCQData::tabname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__DownCQData::time);
	soap_serialize_string(soap, (char*const*)&this->_ns1__DownCQData::filename);
#endif
}

int _ns1__DownCQData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DownCQData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DownCQData(struct soap *soap, const char *tag, int id, const _ns1__DownCQData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DownCQData), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__DownCQData::dwname, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:orglevel", -1, &a->_ns1__DownCQData::orglevel, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:tabname", -1, (char*const*)&a->_ns1__DownCQData::tabname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:time", -1, (char*const*)&a->_ns1__DownCQData::time, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, (char*const*)&a->_ns1__DownCQData::filename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DownCQData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DownCQData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DownCQData * SOAP_FMAC4 soap_in__ns1__DownCQData(struct soap *soap, const char *tag, _ns1__DownCQData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DownCQData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DownCQData, sizeof(_ns1__DownCQData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__DownCQData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__DownCQData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dwname1 = 1;
	size_t soap_flag_orglevel1 = 1;
	size_t soap_flag_tabname1 = 1;
	size_t soap_flag_time1 = 1;
	size_t soap_flag_filename1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__DownCQData::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap_flag_orglevel1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:orglevel", &a->_ns1__DownCQData::orglevel, "xsd:int"))
				{	soap_flag_orglevel1--;
					continue;
				}
			}
			if (soap_flag_tabname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:tabname", (char**)&a->_ns1__DownCQData::tabname, "xsd:string"))
				{	soap_flag_tabname1--;
					continue;
				}
			}
			if (soap_flag_time1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:time", (char**)&a->_ns1__DownCQData::time, "xsd:string"))
				{	soap_flag_time1--;
					continue;
				}
			}
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:filename", (char**)&a->_ns1__DownCQData::filename, "xsd:string"))
				{	soap_flag_filename1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_orglevel1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__DownCQData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DownCQData, SOAP_TYPE__ns1__DownCQData, sizeof(_ns1__DownCQData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DownCQData * SOAP_FMAC2 soap_instantiate__ns1__DownCQData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DownCQData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DownCQData *p;
	size_t k = sizeof(_ns1__DownCQData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__DownCQData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__DownCQData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__DownCQData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DownCQData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__DownCQData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__DownCQData(soap, tag ? tag : "ns1:DownCQData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DownCQData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DownCQData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DownCQData * SOAP_FMAC4 soap_get__ns1__DownCQData(struct soap *soap, _ns1__DownCQData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DownCQData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__AlterTableResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AlterTableResponse::AlterTableResult);
	/* transient soap skipped */
}

void _ns1__AlterTableResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__AlterTableResponse::AlterTableResult);
#endif
}

int _ns1__AlterTableResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AlterTableResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AlterTableResponse(struct soap *soap, const char *tag, int id, const _ns1__AlterTableResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AlterTableResponse), type))
		return soap->error;
	if (a->AlterTableResult)
		soap_element_result(soap, "ns1:AlterTableResult");
	if (soap_out_string(soap, "ns1:AlterTableResult", -1, (char*const*)&a->_ns1__AlterTableResponse::AlterTableResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__AlterTableResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AlterTableResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AlterTableResponse * SOAP_FMAC4 soap_in__ns1__AlterTableResponse(struct soap *soap, const char *tag, _ns1__AlterTableResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AlterTableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AlterTableResponse, sizeof(_ns1__AlterTableResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__AlterTableResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__AlterTableResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AlterTableResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AlterTableResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:AlterTableResult", (char**)&a->_ns1__AlterTableResponse::AlterTableResult, "xsd:string"))
				{	soap_flag_AlterTableResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:AlterTableResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AlterTableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AlterTableResponse, SOAP_TYPE__ns1__AlterTableResponse, sizeof(_ns1__AlterTableResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__AlterTableResponse * SOAP_FMAC2 soap_instantiate__ns1__AlterTableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AlterTableResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__AlterTableResponse *p;
	size_t k = sizeof(_ns1__AlterTableResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__AlterTableResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__AlterTableResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__AlterTableResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__AlterTableResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__AlterTableResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__AlterTableResponse(soap, tag ? tag : "ns1:AlterTableResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AlterTableResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AlterTableResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AlterTableResponse * SOAP_FMAC4 soap_get__ns1__AlterTableResponse(struct soap *soap, _ns1__AlterTableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AlterTableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__AlterTable::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AlterTable::fieldname);
	soap_default_string(soap, &this->_ns1__AlterTable::tabname);
	soap_default_string(soap, &this->_ns1__AlterTable::ftype);
	soap_default_string(soap, &this->_ns1__AlterTable::option);
	/* transient soap skipped */
}

void _ns1__AlterTable::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__AlterTable::fieldname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__AlterTable::tabname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__AlterTable::ftype);
	soap_serialize_string(soap, (char*const*)&this->_ns1__AlterTable::option);
#endif
}

int _ns1__AlterTable::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AlterTable(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AlterTable(struct soap *soap, const char *tag, int id, const _ns1__AlterTable *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AlterTable), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:fieldname", -1, (char*const*)&a->_ns1__AlterTable::fieldname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:tabname", -1, (char*const*)&a->_ns1__AlterTable::tabname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:ftype", -1, (char*const*)&a->_ns1__AlterTable::ftype, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:option", -1, (char*const*)&a->_ns1__AlterTable::option, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__AlterTable::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AlterTable(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AlterTable * SOAP_FMAC4 soap_in__ns1__AlterTable(struct soap *soap, const char *tag, _ns1__AlterTable *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AlterTable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AlterTable, sizeof(_ns1__AlterTable), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__AlterTable)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__AlterTable *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_fieldname1 = 1;
	size_t soap_flag_tabname1 = 1;
	size_t soap_flag_ftype1 = 1;
	size_t soap_flag_option1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fieldname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:fieldname", (char**)&a->_ns1__AlterTable::fieldname, "xsd:string"))
				{	soap_flag_fieldname1--;
					continue;
				}
			}
			if (soap_flag_tabname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:tabname", (char**)&a->_ns1__AlterTable::tabname, "xsd:string"))
				{	soap_flag_tabname1--;
					continue;
				}
			}
			if (soap_flag_ftype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:ftype", (char**)&a->_ns1__AlterTable::ftype, "xsd:string"))
				{	soap_flag_ftype1--;
					continue;
				}
			}
			if (soap_flag_option1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:option", (char**)&a->_ns1__AlterTable::option, "xsd:string"))
				{	soap_flag_option1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AlterTable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AlterTable, SOAP_TYPE__ns1__AlterTable, sizeof(_ns1__AlterTable), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__AlterTable * SOAP_FMAC2 soap_instantiate__ns1__AlterTable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AlterTable(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__AlterTable *p;
	size_t k = sizeof(_ns1__AlterTable);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__AlterTable, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__AlterTable);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__AlterTable, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__AlterTable location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__AlterTable::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__AlterTable(soap, tag ? tag : "ns1:AlterTable", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AlterTable::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AlterTable(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AlterTable * SOAP_FMAC4 soap_get__ns1__AlterTable(struct soap *soap, _ns1__AlterTable *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AlterTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetFileNewResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetFileNewResponse::GetFileNewResult);
	/* transient soap skipped */
}

void _ns1__GetFileNewResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetFileNewResponse::GetFileNewResult);
#endif
}

int _ns1__GetFileNewResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetFileNewResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetFileNewResponse(struct soap *soap, const char *tag, int id, const _ns1__GetFileNewResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetFileNewResponse), type))
		return soap->error;
	if (a->GetFileNewResult)
		soap_element_result(soap, "ns1:GetFileNewResult");
	if (soap_out_string(soap, "ns1:GetFileNewResult", -1, (char*const*)&a->_ns1__GetFileNewResponse::GetFileNewResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetFileNewResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetFileNewResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetFileNewResponse * SOAP_FMAC4 soap_in__ns1__GetFileNewResponse(struct soap *soap, const char *tag, _ns1__GetFileNewResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetFileNewResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetFileNewResponse, sizeof(_ns1__GetFileNewResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetFileNewResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetFileNewResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetFileNewResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetFileNewResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetFileNewResult", (char**)&a->_ns1__GetFileNewResponse::GetFileNewResult, "xsd:string"))
				{	soap_flag_GetFileNewResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetFileNewResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetFileNewResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetFileNewResponse, SOAP_TYPE__ns1__GetFileNewResponse, sizeof(_ns1__GetFileNewResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetFileNewResponse * SOAP_FMAC2 soap_instantiate__ns1__GetFileNewResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetFileNewResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetFileNewResponse *p;
	size_t k = sizeof(_ns1__GetFileNewResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetFileNewResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetFileNewResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetFileNewResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetFileNewResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetFileNewResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetFileNewResponse(soap, tag ? tag : "ns1:GetFileNewResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetFileNewResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetFileNewResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetFileNewResponse * SOAP_FMAC4 soap_get__ns1__GetFileNewResponse(struct soap *soap, _ns1__GetFileNewResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetFileNewResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetFileNew::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetFileNew::lstB = NULL;
	soap_default_string(soap, &this->_ns1__GetFileNew::filename);
	/* transient soap skipped */
}

void _ns1__GetFileNew::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfBase64Binary(soap, &this->_ns1__GetFileNew::lstB);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetFileNew::filename);
#endif
}

int _ns1__GetFileNew::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetFileNew(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetFileNew(struct soap *soap, const char *tag, int id, const _ns1__GetFileNew *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetFileNew), type))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfBase64Binary(soap, "ns1:lstB", -1, &a->_ns1__GetFileNew::lstB, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, (char*const*)&a->_ns1__GetFileNew::filename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetFileNew::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetFileNew(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetFileNew * SOAP_FMAC4 soap_in__ns1__GetFileNew(struct soap *soap, const char *tag, _ns1__GetFileNew *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetFileNew *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetFileNew, sizeof(_ns1__GetFileNew), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetFileNew)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetFileNew *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_lstB1 = 1;
	size_t soap_flag_filename1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lstB1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfBase64Binary(soap, "ns1:lstB", &a->_ns1__GetFileNew::lstB, "ns1:ArrayOfBase64Binary"))
				{	soap_flag_lstB1--;
					continue;
				}
			}
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:filename", (char**)&a->_ns1__GetFileNew::filename, "xsd:string"))
				{	soap_flag_filename1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetFileNew *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetFileNew, SOAP_TYPE__ns1__GetFileNew, sizeof(_ns1__GetFileNew), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetFileNew * SOAP_FMAC2 soap_instantiate__ns1__GetFileNew(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetFileNew(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetFileNew *p;
	size_t k = sizeof(_ns1__GetFileNew);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetFileNew, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetFileNew);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetFileNew, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetFileNew location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetFileNew::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetFileNew(soap, tag ? tag : "ns1:GetFileNew", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetFileNew::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetFileNew(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetFileNew * SOAP_FMAC4 soap_get__ns1__GetFileNew(struct soap *soap, _ns1__GetFileNew *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetFileNew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DownMapfileResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__DownMapfileResponse::DownMapfileResult);
	/* transient soap skipped */
}

void _ns1__DownMapfileResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__DownMapfileResponse::DownMapfileResult);
#endif
}

int _ns1__DownMapfileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DownMapfileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DownMapfileResponse(struct soap *soap, const char *tag, int id, const _ns1__DownMapfileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DownMapfileResponse), type))
		return soap->error;
	if (a->DownMapfileResult)
		soap_element_result(soap, "ns1:DownMapfileResult");
	if (soap_out_string(soap, "ns1:DownMapfileResult", -1, (char*const*)&a->_ns1__DownMapfileResponse::DownMapfileResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DownMapfileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DownMapfileResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DownMapfileResponse * SOAP_FMAC4 soap_in__ns1__DownMapfileResponse(struct soap *soap, const char *tag, _ns1__DownMapfileResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DownMapfileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DownMapfileResponse, sizeof(_ns1__DownMapfileResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__DownMapfileResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__DownMapfileResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DownMapfileResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DownMapfileResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:DownMapfileResult", (char**)&a->_ns1__DownMapfileResponse::DownMapfileResult, "xsd:string"))
				{	soap_flag_DownMapfileResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:DownMapfileResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DownMapfileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DownMapfileResponse, SOAP_TYPE__ns1__DownMapfileResponse, sizeof(_ns1__DownMapfileResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DownMapfileResponse * SOAP_FMAC2 soap_instantiate__ns1__DownMapfileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DownMapfileResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DownMapfileResponse *p;
	size_t k = sizeof(_ns1__DownMapfileResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__DownMapfileResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__DownMapfileResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__DownMapfileResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DownMapfileResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__DownMapfileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__DownMapfileResponse(soap, tag ? tag : "ns1:DownMapfileResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DownMapfileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DownMapfileResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DownMapfileResponse * SOAP_FMAC4 soap_get__ns1__DownMapfileResponse(struct soap *soap, _ns1__DownMapfileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DownMapfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DownMapfile::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__DownMapfile::filename);
	/* transient soap skipped */
}

void _ns1__DownMapfile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__DownMapfile::filename);
#endif
}

int _ns1__DownMapfile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DownMapfile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DownMapfile(struct soap *soap, const char *tag, int id, const _ns1__DownMapfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DownMapfile), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, (char*const*)&a->_ns1__DownMapfile::filename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DownMapfile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DownMapfile(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DownMapfile * SOAP_FMAC4 soap_in__ns1__DownMapfile(struct soap *soap, const char *tag, _ns1__DownMapfile *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DownMapfile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DownMapfile, sizeof(_ns1__DownMapfile), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__DownMapfile)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__DownMapfile *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_filename1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:filename", (char**)&a->_ns1__DownMapfile::filename, "xsd:string"))
				{	soap_flag_filename1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DownMapfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DownMapfile, SOAP_TYPE__ns1__DownMapfile, sizeof(_ns1__DownMapfile), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DownMapfile * SOAP_FMAC2 soap_instantiate__ns1__DownMapfile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DownMapfile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DownMapfile *p;
	size_t k = sizeof(_ns1__DownMapfile);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__DownMapfile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__DownMapfile);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__DownMapfile, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DownMapfile location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__DownMapfile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__DownMapfile(soap, tag ? tag : "ns1:DownMapfile", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DownMapfile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DownMapfile(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DownMapfile * SOAP_FMAC4 soap_get__ns1__DownMapfile(struct soap *soap, _ns1__DownMapfile *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DownMapfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetDownFileInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetDownFileInfoResponse::GetDownFileInfoResult);
	/* transient soap skipped */
}

void _ns1__GetDownFileInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDownFileInfoResponse::GetDownFileInfoResult);
#endif
}

int _ns1__GetDownFileInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDownFileInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDownFileInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetDownFileInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDownFileInfoResponse), type))
		return soap->error;
	if (a->GetDownFileInfoResult)
		soap_element_result(soap, "ns1:GetDownFileInfoResult");
	if (soap_out_string(soap, "ns1:GetDownFileInfoResult", -1, (char*const*)&a->_ns1__GetDownFileInfoResponse::GetDownFileInfoResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDownFileInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDownFileInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDownFileInfoResponse * SOAP_FMAC4 soap_in__ns1__GetDownFileInfoResponse(struct soap *soap, const char *tag, _ns1__GetDownFileInfoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDownFileInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDownFileInfoResponse, sizeof(_ns1__GetDownFileInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetDownFileInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetDownFileInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetDownFileInfoResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetDownFileInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetDownFileInfoResult", (char**)&a->_ns1__GetDownFileInfoResponse::GetDownFileInfoResult, "xsd:string"))
				{	soap_flag_GetDownFileInfoResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetDownFileInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDownFileInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDownFileInfoResponse, SOAP_TYPE__ns1__GetDownFileInfoResponse, sizeof(_ns1__GetDownFileInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetDownFileInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__GetDownFileInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDownFileInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetDownFileInfoResponse *p;
	size_t k = sizeof(_ns1__GetDownFileInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetDownFileInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetDownFileInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetDownFileInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetDownFileInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetDownFileInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetDownFileInfoResponse(soap, tag ? tag : "ns1:GetDownFileInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDownFileInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDownFileInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDownFileInfoResponse * SOAP_FMAC4 soap_get__ns1__GetDownFileInfoResponse(struct soap *soap, _ns1__GetDownFileInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDownFileInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetDownFileInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetDownFileInfo::fname);
	/* transient soap skipped */
}

void _ns1__GetDownFileInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDownFileInfo::fname);
#endif
}

int _ns1__GetDownFileInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDownFileInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDownFileInfo(struct soap *soap, const char *tag, int id, const _ns1__GetDownFileInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDownFileInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:fname", -1, (char*const*)&a->_ns1__GetDownFileInfo::fname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDownFileInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDownFileInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDownFileInfo * SOAP_FMAC4 soap_in__ns1__GetDownFileInfo(struct soap *soap, const char *tag, _ns1__GetDownFileInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDownFileInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDownFileInfo, sizeof(_ns1__GetDownFileInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetDownFileInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetDownFileInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_fname1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:fname", (char**)&a->_ns1__GetDownFileInfo::fname, "xsd:string"))
				{	soap_flag_fname1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDownFileInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDownFileInfo, SOAP_TYPE__ns1__GetDownFileInfo, sizeof(_ns1__GetDownFileInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetDownFileInfo * SOAP_FMAC2 soap_instantiate__ns1__GetDownFileInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDownFileInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetDownFileInfo *p;
	size_t k = sizeof(_ns1__GetDownFileInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetDownFileInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetDownFileInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetDownFileInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetDownFileInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetDownFileInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetDownFileInfo(soap, tag ? tag : "ns1:GetDownFileInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDownFileInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDownFileInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDownFileInfo * SOAP_FMAC4 soap_get__ns1__GetDownFileInfo(struct soap *soap, _ns1__GetDownFileInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDownFileInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetGxDeviceDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetGxDeviceDataResponse::GetGxDeviceDataResult);
	/* transient soap skipped */
}

void _ns1__GetGxDeviceDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetGxDeviceDataResponse::GetGxDeviceDataResult);
#endif
}

int _ns1__GetGxDeviceDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetGxDeviceDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetGxDeviceDataResponse(struct soap *soap, const char *tag, int id, const _ns1__GetGxDeviceDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetGxDeviceDataResponse), type))
		return soap->error;
	if (a->GetGxDeviceDataResult)
		soap_element_result(soap, "ns1:GetGxDeviceDataResult");
	if (soap_out_string(soap, "ns1:GetGxDeviceDataResult", -1, (char*const*)&a->_ns1__GetGxDeviceDataResponse::GetGxDeviceDataResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetGxDeviceDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetGxDeviceDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetGxDeviceDataResponse * SOAP_FMAC4 soap_in__ns1__GetGxDeviceDataResponse(struct soap *soap, const char *tag, _ns1__GetGxDeviceDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetGxDeviceDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetGxDeviceDataResponse, sizeof(_ns1__GetGxDeviceDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetGxDeviceDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetGxDeviceDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetGxDeviceDataResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetGxDeviceDataResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetGxDeviceDataResult", (char**)&a->_ns1__GetGxDeviceDataResponse::GetGxDeviceDataResult, "xsd:string"))
				{	soap_flag_GetGxDeviceDataResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetGxDeviceDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetGxDeviceDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetGxDeviceDataResponse, SOAP_TYPE__ns1__GetGxDeviceDataResponse, sizeof(_ns1__GetGxDeviceDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetGxDeviceDataResponse * SOAP_FMAC2 soap_instantiate__ns1__GetGxDeviceDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetGxDeviceDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetGxDeviceDataResponse *p;
	size_t k = sizeof(_ns1__GetGxDeviceDataResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetGxDeviceDataResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetGxDeviceDataResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetGxDeviceDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetGxDeviceDataResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetGxDeviceDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetGxDeviceDataResponse(soap, tag ? tag : "ns1:GetGxDeviceDataResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetGxDeviceDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetGxDeviceDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetGxDeviceDataResponse * SOAP_FMAC4 soap_get__ns1__GetGxDeviceDataResponse(struct soap *soap, _ns1__GetGxDeviceDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetGxDeviceDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetGxDeviceData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetGxDeviceData::typeid_);
	soap_default_string(soap, &this->_ns1__GetGxDeviceData::xb);
	soap_default_string(soap, &this->_ns1__GetGxDeviceData::station);
	/* transient soap skipped */
}

void _ns1__GetGxDeviceData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetGxDeviceData::typeid_);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetGxDeviceData::xb);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetGxDeviceData::station);
#endif
}

int _ns1__GetGxDeviceData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetGxDeviceData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetGxDeviceData(struct soap *soap, const char *tag, int id, const _ns1__GetGxDeviceData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetGxDeviceData), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:typeid", -1, (char*const*)&a->_ns1__GetGxDeviceData::typeid_, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:xb", -1, (char*const*)&a->_ns1__GetGxDeviceData::xb, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:station", -1, (char*const*)&a->_ns1__GetGxDeviceData::station, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetGxDeviceData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetGxDeviceData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetGxDeviceData * SOAP_FMAC4 soap_in__ns1__GetGxDeviceData(struct soap *soap, const char *tag, _ns1__GetGxDeviceData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetGxDeviceData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetGxDeviceData, sizeof(_ns1__GetGxDeviceData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetGxDeviceData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetGxDeviceData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_typeid_1 = 1;
	size_t soap_flag_xb1 = 1;
	size_t soap_flag_station1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_typeid_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:typeid", (char**)&a->_ns1__GetGxDeviceData::typeid_, "xsd:string"))
				{	soap_flag_typeid_1--;
					continue;
				}
			}
			if (soap_flag_xb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:xb", (char**)&a->_ns1__GetGxDeviceData::xb, "xsd:string"))
				{	soap_flag_xb1--;
					continue;
				}
			}
			if (soap_flag_station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:station", (char**)&a->_ns1__GetGxDeviceData::station, "xsd:string"))
				{	soap_flag_station1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetGxDeviceData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetGxDeviceData, SOAP_TYPE__ns1__GetGxDeviceData, sizeof(_ns1__GetGxDeviceData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetGxDeviceData * SOAP_FMAC2 soap_instantiate__ns1__GetGxDeviceData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetGxDeviceData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetGxDeviceData *p;
	size_t k = sizeof(_ns1__GetGxDeviceData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetGxDeviceData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetGxDeviceData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetGxDeviceData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetGxDeviceData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetGxDeviceData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetGxDeviceData(soap, tag ? tag : "ns1:GetGxDeviceData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetGxDeviceData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetGxDeviceData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetGxDeviceData * SOAP_FMAC4 soap_get__ns1__GetGxDeviceData(struct soap *soap, _ns1__GetGxDeviceData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetGxDeviceData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMapDeviceTypeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetMapDeviceTypeResponse::GetMapDeviceTypeResult);
	/* transient soap skipped */
}

void _ns1__GetMapDeviceTypeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetMapDeviceTypeResponse::GetMapDeviceTypeResult);
#endif
}

int _ns1__GetMapDeviceTypeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMapDeviceTypeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMapDeviceTypeResponse(struct soap *soap, const char *tag, int id, const _ns1__GetMapDeviceTypeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMapDeviceTypeResponse), type))
		return soap->error;
	if (a->GetMapDeviceTypeResult)
		soap_element_result(soap, "ns1:GetMapDeviceTypeResult");
	if (soap_out_string(soap, "ns1:GetMapDeviceTypeResult", -1, (char*const*)&a->_ns1__GetMapDeviceTypeResponse::GetMapDeviceTypeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMapDeviceTypeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMapDeviceTypeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMapDeviceTypeResponse * SOAP_FMAC4 soap_in__ns1__GetMapDeviceTypeResponse(struct soap *soap, const char *tag, _ns1__GetMapDeviceTypeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMapDeviceTypeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMapDeviceTypeResponse, sizeof(_ns1__GetMapDeviceTypeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMapDeviceTypeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMapDeviceTypeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetMapDeviceTypeResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetMapDeviceTypeResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetMapDeviceTypeResult", (char**)&a->_ns1__GetMapDeviceTypeResponse::GetMapDeviceTypeResult, "xsd:string"))
				{	soap_flag_GetMapDeviceTypeResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetMapDeviceTypeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMapDeviceTypeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMapDeviceTypeResponse, SOAP_TYPE__ns1__GetMapDeviceTypeResponse, sizeof(_ns1__GetMapDeviceTypeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMapDeviceTypeResponse * SOAP_FMAC2 soap_instantiate__ns1__GetMapDeviceTypeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMapDeviceTypeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMapDeviceTypeResponse *p;
	size_t k = sizeof(_ns1__GetMapDeviceTypeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetMapDeviceTypeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetMapDeviceTypeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetMapDeviceTypeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMapDeviceTypeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetMapDeviceTypeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMapDeviceTypeResponse(soap, tag ? tag : "ns1:GetMapDeviceTypeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMapDeviceTypeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMapDeviceTypeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMapDeviceTypeResponse * SOAP_FMAC4 soap_get__ns1__GetMapDeviceTypeResponse(struct soap *soap, _ns1__GetMapDeviceTypeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMapDeviceTypeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetMapDeviceType::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetMapDeviceType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetMapDeviceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetMapDeviceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetMapDeviceType(struct soap *soap, const char *tag, int id, const _ns1__GetMapDeviceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetMapDeviceType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetMapDeviceType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetMapDeviceType(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetMapDeviceType * SOAP_FMAC4 soap_in__ns1__GetMapDeviceType(struct soap *soap, const char *tag, _ns1__GetMapDeviceType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetMapDeviceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetMapDeviceType, sizeof(_ns1__GetMapDeviceType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetMapDeviceType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetMapDeviceType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetMapDeviceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetMapDeviceType, SOAP_TYPE__ns1__GetMapDeviceType, sizeof(_ns1__GetMapDeviceType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetMapDeviceType * SOAP_FMAC2 soap_instantiate__ns1__GetMapDeviceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetMapDeviceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetMapDeviceType *p;
	size_t k = sizeof(_ns1__GetMapDeviceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetMapDeviceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetMapDeviceType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetMapDeviceType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetMapDeviceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetMapDeviceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetMapDeviceType(soap, tag ? tag : "ns1:GetMapDeviceType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetMapDeviceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetMapDeviceType(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetMapDeviceType * SOAP_FMAC4 soap_get__ns1__GetMapDeviceType(struct soap *soap, _ns1__GetMapDeviceType *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetMapDeviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetXbStationListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetXbStationListResponse::GetXbStationListResult);
	/* transient soap skipped */
}

void _ns1__GetXbStationListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetXbStationListResponse::GetXbStationListResult);
#endif
}

int _ns1__GetXbStationListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetXbStationListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetXbStationListResponse(struct soap *soap, const char *tag, int id, const _ns1__GetXbStationListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetXbStationListResponse), type))
		return soap->error;
	if (a->GetXbStationListResult)
		soap_element_result(soap, "ns1:GetXbStationListResult");
	if (soap_out_string(soap, "ns1:GetXbStationListResult", -1, (char*const*)&a->_ns1__GetXbStationListResponse::GetXbStationListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetXbStationListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetXbStationListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetXbStationListResponse * SOAP_FMAC4 soap_in__ns1__GetXbStationListResponse(struct soap *soap, const char *tag, _ns1__GetXbStationListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetXbStationListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetXbStationListResponse, sizeof(_ns1__GetXbStationListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetXbStationListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetXbStationListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetXbStationListResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetXbStationListResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetXbStationListResult", (char**)&a->_ns1__GetXbStationListResponse::GetXbStationListResult, "xsd:string"))
				{	soap_flag_GetXbStationListResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetXbStationListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetXbStationListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetXbStationListResponse, SOAP_TYPE__ns1__GetXbStationListResponse, sizeof(_ns1__GetXbStationListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetXbStationListResponse * SOAP_FMAC2 soap_instantiate__ns1__GetXbStationListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetXbStationListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetXbStationListResponse *p;
	size_t k = sizeof(_ns1__GetXbStationListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetXbStationListResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetXbStationListResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetXbStationListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetXbStationListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetXbStationListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetXbStationListResponse(soap, tag ? tag : "ns1:GetXbStationListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetXbStationListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetXbStationListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetXbStationListResponse * SOAP_FMAC4 soap_get__ns1__GetXbStationListResponse(struct soap *soap, _ns1__GetXbStationListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetXbStationListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetXbStationList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetXbStationList::xb);
	soap_default_string(soap, &this->_ns1__GetXbStationList::unit);
	/* transient soap skipped */
}

void _ns1__GetXbStationList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetXbStationList::xb);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetXbStationList::unit);
#endif
}

int _ns1__GetXbStationList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetXbStationList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetXbStationList(struct soap *soap, const char *tag, int id, const _ns1__GetXbStationList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetXbStationList), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xb", -1, (char*const*)&a->_ns1__GetXbStationList::xb, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:unit", -1, (char*const*)&a->_ns1__GetXbStationList::unit, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetXbStationList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetXbStationList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetXbStationList * SOAP_FMAC4 soap_in__ns1__GetXbStationList(struct soap *soap, const char *tag, _ns1__GetXbStationList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetXbStationList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetXbStationList, sizeof(_ns1__GetXbStationList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetXbStationList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetXbStationList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_xb1 = 1;
	size_t soap_flag_unit1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:xb", (char**)&a->_ns1__GetXbStationList::xb, "xsd:string"))
				{	soap_flag_xb1--;
					continue;
				}
			}
			if (soap_flag_unit1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:unit", (char**)&a->_ns1__GetXbStationList::unit, "xsd:string"))
				{	soap_flag_unit1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetXbStationList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetXbStationList, SOAP_TYPE__ns1__GetXbStationList, sizeof(_ns1__GetXbStationList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetXbStationList * SOAP_FMAC2 soap_instantiate__ns1__GetXbStationList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetXbStationList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetXbStationList *p;
	size_t k = sizeof(_ns1__GetXbStationList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetXbStationList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetXbStationList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetXbStationList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetXbStationList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetXbStationList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetXbStationList(soap, tag ? tag : "ns1:GetXbStationList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetXbStationList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetXbStationList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetXbStationList * SOAP_FMAC4 soap_get__ns1__GetXbStationList(struct soap *soap, _ns1__GetXbStationList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetXbStationList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetXbListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetXbListResponse::GetXbListResult);
	/* transient soap skipped */
}

void _ns1__GetXbListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetXbListResponse::GetXbListResult);
#endif
}

int _ns1__GetXbListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetXbListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetXbListResponse(struct soap *soap, const char *tag, int id, const _ns1__GetXbListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetXbListResponse), type))
		return soap->error;
	if (a->GetXbListResult)
		soap_element_result(soap, "ns1:GetXbListResult");
	if (soap_out_string(soap, "ns1:GetXbListResult", -1, (char*const*)&a->_ns1__GetXbListResponse::GetXbListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetXbListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetXbListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetXbListResponse * SOAP_FMAC4 soap_in__ns1__GetXbListResponse(struct soap *soap, const char *tag, _ns1__GetXbListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetXbListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetXbListResponse, sizeof(_ns1__GetXbListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetXbListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetXbListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetXbListResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetXbListResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetXbListResult", (char**)&a->_ns1__GetXbListResponse::GetXbListResult, "xsd:string"))
				{	soap_flag_GetXbListResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetXbListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetXbListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetXbListResponse, SOAP_TYPE__ns1__GetXbListResponse, sizeof(_ns1__GetXbListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetXbListResponse * SOAP_FMAC2 soap_instantiate__ns1__GetXbListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetXbListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetXbListResponse *p;
	size_t k = sizeof(_ns1__GetXbListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetXbListResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetXbListResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetXbListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetXbListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetXbListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetXbListResponse(soap, tag ? tag : "ns1:GetXbListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetXbListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetXbListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetXbListResponse * SOAP_FMAC4 soap_get__ns1__GetXbListResponse(struct soap *soap, _ns1__GetXbListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetXbListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetXbList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetXbList::unit);
	/* transient soap skipped */
}

void _ns1__GetXbList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetXbList::unit);
#endif
}

int _ns1__GetXbList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetXbList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetXbList(struct soap *soap, const char *tag, int id, const _ns1__GetXbList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetXbList), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:unit", -1, (char*const*)&a->_ns1__GetXbList::unit, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetXbList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetXbList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetXbList * SOAP_FMAC4 soap_in__ns1__GetXbList(struct soap *soap, const char *tag, _ns1__GetXbList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetXbList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetXbList, sizeof(_ns1__GetXbList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetXbList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetXbList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_unit1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_unit1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:unit", (char**)&a->_ns1__GetXbList::unit, "xsd:string"))
				{	soap_flag_unit1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetXbList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetXbList, SOAP_TYPE__ns1__GetXbList, sizeof(_ns1__GetXbList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetXbList * SOAP_FMAC2 soap_instantiate__ns1__GetXbList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetXbList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetXbList *p;
	size_t k = sizeof(_ns1__GetXbList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetXbList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetXbList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetXbList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetXbList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetXbList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetXbList(soap, tag ? tag : "ns1:GetXbList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetXbList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetXbList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetXbList * SOAP_FMAC4 soap_get__ns1__GetXbList(struct soap *soap, _ns1__GetXbList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetXbList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetFileSizeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->_ns1__GetFileSizeResponse::GetFileSizeResult);
	/* transient soap skipped */
}

void _ns1__GetFileSizeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetFileSizeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetFileSizeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetFileSizeResponse(struct soap *soap, const char *tag, int id, const _ns1__GetFileSizeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetFileSizeResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:GetFileSizeResult");
	if (soap_out_LONG64(soap, "ns1:GetFileSizeResult", -1, &a->_ns1__GetFileSizeResponse::GetFileSizeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetFileSizeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetFileSizeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetFileSizeResponse * SOAP_FMAC4 soap_in__ns1__GetFileSizeResponse(struct soap *soap, const char *tag, _ns1__GetFileSizeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetFileSizeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetFileSizeResponse, sizeof(_ns1__GetFileSizeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetFileSizeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetFileSizeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetFileSizeResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetFileSizeResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns1:GetFileSizeResult", &a->_ns1__GetFileSizeResponse::GetFileSizeResult, "xsd:long"))
				{	soap_flag_GetFileSizeResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetFileSizeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetFileSizeResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetFileSizeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetFileSizeResponse, SOAP_TYPE__ns1__GetFileSizeResponse, sizeof(_ns1__GetFileSizeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetFileSizeResponse * SOAP_FMAC2 soap_instantiate__ns1__GetFileSizeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetFileSizeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetFileSizeResponse *p;
	size_t k = sizeof(_ns1__GetFileSizeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetFileSizeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetFileSizeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetFileSizeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetFileSizeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetFileSizeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetFileSizeResponse(soap, tag ? tag : "ns1:GetFileSizeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetFileSizeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetFileSizeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetFileSizeResponse * SOAP_FMAC4 soap_get__ns1__GetFileSizeResponse(struct soap *soap, _ns1__GetFileSizeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetFileSizeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetFileSize::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetFileSize::filename);
	/* transient soap skipped */
}

void _ns1__GetFileSize::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetFileSize::filename);
#endif
}

int _ns1__GetFileSize::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetFileSize(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetFileSize(struct soap *soap, const char *tag, int id, const _ns1__GetFileSize *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetFileSize), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, (char*const*)&a->_ns1__GetFileSize::filename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetFileSize::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetFileSize(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetFileSize * SOAP_FMAC4 soap_in__ns1__GetFileSize(struct soap *soap, const char *tag, _ns1__GetFileSize *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetFileSize *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetFileSize, sizeof(_ns1__GetFileSize), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetFileSize)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetFileSize *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_filename1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:filename", (char**)&a->_ns1__GetFileSize::filename, "xsd:string"))
				{	soap_flag_filename1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetFileSize *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetFileSize, SOAP_TYPE__ns1__GetFileSize, sizeof(_ns1__GetFileSize), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetFileSize * SOAP_FMAC2 soap_instantiate__ns1__GetFileSize(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetFileSize(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetFileSize *p;
	size_t k = sizeof(_ns1__GetFileSize);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetFileSize, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetFileSize);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetFileSize, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetFileSize location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetFileSize::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetFileSize(soap, tag ? tag : "ns1:GetFileSize", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetFileSize::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetFileSize(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetFileSize * SOAP_FMAC4 soap_get__ns1__GetFileSize(struct soap *soap, _ns1__GetFileSize *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetFileSize(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetUnitPersonInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetUnitPersonInfoResponse::GetUnitPersonInfoResult);
	/* transient soap skipped */
}

void _ns1__GetUnitPersonInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetUnitPersonInfoResponse::GetUnitPersonInfoResult);
#endif
}

int _ns1__GetUnitPersonInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetUnitPersonInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetUnitPersonInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetUnitPersonInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetUnitPersonInfoResponse), type))
		return soap->error;
	if (a->GetUnitPersonInfoResult)
		soap_element_result(soap, "ns1:GetUnitPersonInfoResult");
	if (soap_out_string(soap, "ns1:GetUnitPersonInfoResult", -1, (char*const*)&a->_ns1__GetUnitPersonInfoResponse::GetUnitPersonInfoResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetUnitPersonInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetUnitPersonInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetUnitPersonInfoResponse * SOAP_FMAC4 soap_in__ns1__GetUnitPersonInfoResponse(struct soap *soap, const char *tag, _ns1__GetUnitPersonInfoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetUnitPersonInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetUnitPersonInfoResponse, sizeof(_ns1__GetUnitPersonInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetUnitPersonInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetUnitPersonInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetUnitPersonInfoResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetUnitPersonInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetUnitPersonInfoResult", (char**)&a->_ns1__GetUnitPersonInfoResponse::GetUnitPersonInfoResult, "xsd:string"))
				{	soap_flag_GetUnitPersonInfoResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetUnitPersonInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetUnitPersonInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetUnitPersonInfoResponse, SOAP_TYPE__ns1__GetUnitPersonInfoResponse, sizeof(_ns1__GetUnitPersonInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetUnitPersonInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__GetUnitPersonInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetUnitPersonInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetUnitPersonInfoResponse *p;
	size_t k = sizeof(_ns1__GetUnitPersonInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetUnitPersonInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetUnitPersonInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetUnitPersonInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetUnitPersonInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetUnitPersonInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetUnitPersonInfoResponse(soap, tag ? tag : "ns1:GetUnitPersonInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetUnitPersonInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetUnitPersonInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetUnitPersonInfoResponse * SOAP_FMAC4 soap_get__ns1__GetUnitPersonInfoResponse(struct soap *soap, _ns1__GetUnitPersonInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetUnitPersonInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetUnitPersonInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetUnitPersonInfo::dwname);
	soap_default_int(soap, &this->_ns1__GetUnitPersonInfo::unitid);
	soap_default_int(soap, &this->_ns1__GetUnitPersonInfo::personid);
	/* transient soap skipped */
}

void _ns1__GetUnitPersonInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetUnitPersonInfo::dwname);
#endif
}

int _ns1__GetUnitPersonInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetUnitPersonInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetUnitPersonInfo(struct soap *soap, const char *tag, int id, const _ns1__GetUnitPersonInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetUnitPersonInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__GetUnitPersonInfo::dwname, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:unitid", -1, &a->_ns1__GetUnitPersonInfo::unitid, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:personid", -1, &a->_ns1__GetUnitPersonInfo::personid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetUnitPersonInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetUnitPersonInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetUnitPersonInfo * SOAP_FMAC4 soap_in__ns1__GetUnitPersonInfo(struct soap *soap, const char *tag, _ns1__GetUnitPersonInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetUnitPersonInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetUnitPersonInfo, sizeof(_ns1__GetUnitPersonInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetUnitPersonInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetUnitPersonInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dwname1 = 1;
	size_t soap_flag_unitid1 = 1;
	size_t soap_flag_personid1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__GetUnitPersonInfo::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap_flag_unitid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:unitid", &a->_ns1__GetUnitPersonInfo::unitid, "xsd:int"))
				{	soap_flag_unitid1--;
					continue;
				}
			}
			if (soap_flag_personid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:personid", &a->_ns1__GetUnitPersonInfo::personid, "xsd:int"))
				{	soap_flag_personid1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_unitid1 > 0 || soap_flag_personid1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetUnitPersonInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetUnitPersonInfo, SOAP_TYPE__ns1__GetUnitPersonInfo, sizeof(_ns1__GetUnitPersonInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetUnitPersonInfo * SOAP_FMAC2 soap_instantiate__ns1__GetUnitPersonInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetUnitPersonInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetUnitPersonInfo *p;
	size_t k = sizeof(_ns1__GetUnitPersonInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetUnitPersonInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetUnitPersonInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetUnitPersonInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetUnitPersonInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetUnitPersonInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetUnitPersonInfo(soap, tag ? tag : "ns1:GetUnitPersonInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetUnitPersonInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetUnitPersonInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetUnitPersonInfo * SOAP_FMAC4 soap_get__ns1__GetUnitPersonInfo(struct soap *soap, _ns1__GetUnitPersonInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetUnitPersonInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetUnitStructResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetUnitStructResponse::GetUnitStructResult);
	/* transient soap skipped */
}

void _ns1__GetUnitStructResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetUnitStructResponse::GetUnitStructResult);
#endif
}

int _ns1__GetUnitStructResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetUnitStructResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetUnitStructResponse(struct soap *soap, const char *tag, int id, const _ns1__GetUnitStructResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetUnitStructResponse), type))
		return soap->error;
	if (a->GetUnitStructResult)
		soap_element_result(soap, "ns1:GetUnitStructResult");
	if (soap_out_string(soap, "ns1:GetUnitStructResult", -1, (char*const*)&a->_ns1__GetUnitStructResponse::GetUnitStructResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetUnitStructResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetUnitStructResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetUnitStructResponse * SOAP_FMAC4 soap_in__ns1__GetUnitStructResponse(struct soap *soap, const char *tag, _ns1__GetUnitStructResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetUnitStructResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetUnitStructResponse, sizeof(_ns1__GetUnitStructResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetUnitStructResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetUnitStructResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetUnitStructResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetUnitStructResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetUnitStructResult", (char**)&a->_ns1__GetUnitStructResponse::GetUnitStructResult, "xsd:string"))
				{	soap_flag_GetUnitStructResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetUnitStructResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetUnitStructResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetUnitStructResponse, SOAP_TYPE__ns1__GetUnitStructResponse, sizeof(_ns1__GetUnitStructResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetUnitStructResponse * SOAP_FMAC2 soap_instantiate__ns1__GetUnitStructResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetUnitStructResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetUnitStructResponse *p;
	size_t k = sizeof(_ns1__GetUnitStructResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetUnitStructResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetUnitStructResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetUnitStructResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetUnitStructResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetUnitStructResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetUnitStructResponse(soap, tag ? tag : "ns1:GetUnitStructResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetUnitStructResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetUnitStructResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetUnitStructResponse * SOAP_FMAC4 soap_get__ns1__GetUnitStructResponse(struct soap *soap, _ns1__GetUnitStructResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetUnitStructResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetUnitStruct::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetUnitStruct::dwname);
	soap_default_int(soap, &this->_ns1__GetUnitStruct::level);
	/* transient soap skipped */
}

void _ns1__GetUnitStruct::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetUnitStruct::dwname);
#endif
}

int _ns1__GetUnitStruct::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetUnitStruct(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetUnitStruct(struct soap *soap, const char *tag, int id, const _ns1__GetUnitStruct *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetUnitStruct), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__GetUnitStruct::dwname, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:level", -1, &a->_ns1__GetUnitStruct::level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetUnitStruct::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetUnitStruct(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetUnitStruct * SOAP_FMAC4 soap_in__ns1__GetUnitStruct(struct soap *soap, const char *tag, _ns1__GetUnitStruct *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetUnitStruct *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetUnitStruct, sizeof(_ns1__GetUnitStruct), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetUnitStruct)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetUnitStruct *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dwname1 = 1;
	size_t soap_flag_level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__GetUnitStruct::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap_flag_level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:level", &a->_ns1__GetUnitStruct::level, "xsd:int"))
				{	soap_flag_level1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_level1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetUnitStruct *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetUnitStruct, SOAP_TYPE__ns1__GetUnitStruct, sizeof(_ns1__GetUnitStruct), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetUnitStruct * SOAP_FMAC2 soap_instantiate__ns1__GetUnitStruct(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetUnitStruct(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetUnitStruct *p;
	size_t k = sizeof(_ns1__GetUnitStruct);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetUnitStruct, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetUnitStruct);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetUnitStruct, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetUnitStruct location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetUnitStruct::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetUnitStruct(soap, tag ? tag : "ns1:GetUnitStruct", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetUnitStruct::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetUnitStruct(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetUnitStruct * SOAP_FMAC4 soap_get__ns1__GetUnitStruct(struct soap *soap, _ns1__GetUnitStruct *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetUnitStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetUnitStationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetUnitStationResponse::GetUnitStationResult);
	/* transient soap skipped */
}

void _ns1__GetUnitStationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetUnitStationResponse::GetUnitStationResult);
#endif
}

int _ns1__GetUnitStationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetUnitStationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetUnitStationResponse(struct soap *soap, const char *tag, int id, const _ns1__GetUnitStationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetUnitStationResponse), type))
		return soap->error;
	if (a->GetUnitStationResult)
		soap_element_result(soap, "ns1:GetUnitStationResult");
	if (soap_out_string(soap, "ns1:GetUnitStationResult", -1, (char*const*)&a->_ns1__GetUnitStationResponse::GetUnitStationResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetUnitStationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetUnitStationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetUnitStationResponse * SOAP_FMAC4 soap_in__ns1__GetUnitStationResponse(struct soap *soap, const char *tag, _ns1__GetUnitStationResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetUnitStationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetUnitStationResponse, sizeof(_ns1__GetUnitStationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetUnitStationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetUnitStationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetUnitStationResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetUnitStationResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetUnitStationResult", (char**)&a->_ns1__GetUnitStationResponse::GetUnitStationResult, "xsd:string"))
				{	soap_flag_GetUnitStationResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetUnitStationResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetUnitStationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetUnitStationResponse, SOAP_TYPE__ns1__GetUnitStationResponse, sizeof(_ns1__GetUnitStationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetUnitStationResponse * SOAP_FMAC2 soap_instantiate__ns1__GetUnitStationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetUnitStationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetUnitStationResponse *p;
	size_t k = sizeof(_ns1__GetUnitStationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetUnitStationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetUnitStationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetUnitStationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetUnitStationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetUnitStationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetUnitStationResponse(soap, tag ? tag : "ns1:GetUnitStationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetUnitStationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetUnitStationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetUnitStationResponse * SOAP_FMAC4 soap_get__ns1__GetUnitStationResponse(struct soap *soap, _ns1__GetUnitStationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetUnitStationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetUnitStation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetUnitStation::dwname);
	soap_default_int(soap, &this->_ns1__GetUnitStation::level);
	/* transient soap skipped */
}

void _ns1__GetUnitStation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetUnitStation::dwname);
#endif
}

int _ns1__GetUnitStation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetUnitStation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetUnitStation(struct soap *soap, const char *tag, int id, const _ns1__GetUnitStation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetUnitStation), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__GetUnitStation::dwname, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:level", -1, &a->_ns1__GetUnitStation::level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetUnitStation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetUnitStation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetUnitStation * SOAP_FMAC4 soap_in__ns1__GetUnitStation(struct soap *soap, const char *tag, _ns1__GetUnitStation *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetUnitStation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetUnitStation, sizeof(_ns1__GetUnitStation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetUnitStation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetUnitStation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dwname1 = 1;
	size_t soap_flag_level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__GetUnitStation::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap_flag_level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:level", &a->_ns1__GetUnitStation::level, "xsd:int"))
				{	soap_flag_level1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_level1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetUnitStation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetUnitStation, SOAP_TYPE__ns1__GetUnitStation, sizeof(_ns1__GetUnitStation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetUnitStation * SOAP_FMAC2 soap_instantiate__ns1__GetUnitStation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetUnitStation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetUnitStation *p;
	size_t k = sizeof(_ns1__GetUnitStation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetUnitStation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetUnitStation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetUnitStation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetUnitStation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetUnitStation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetUnitStation(soap, tag ? tag : "ns1:GetUnitStation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetUnitStation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetUnitStation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetUnitStation * SOAP_FMAC4 soap_get__ns1__GetUnitStation(struct soap *soap, _ns1__GetUnitStation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetUnitStation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetDwListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetDwListResponse::GetDwListResult);
	/* transient soap skipped */
}

void _ns1__GetDwListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDwListResponse::GetDwListResult);
#endif
}

int _ns1__GetDwListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDwListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDwListResponse(struct soap *soap, const char *tag, int id, const _ns1__GetDwListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDwListResponse), type))
		return soap->error;
	if (a->GetDwListResult)
		soap_element_result(soap, "ns1:GetDwListResult");
	if (soap_out_string(soap, "ns1:GetDwListResult", -1, (char*const*)&a->_ns1__GetDwListResponse::GetDwListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDwListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDwListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDwListResponse * SOAP_FMAC4 soap_in__ns1__GetDwListResponse(struct soap *soap, const char *tag, _ns1__GetDwListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDwListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDwListResponse, sizeof(_ns1__GetDwListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetDwListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetDwListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetDwListResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetDwListResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetDwListResult", (char**)&a->_ns1__GetDwListResponse::GetDwListResult, "xsd:string"))
				{	soap_flag_GetDwListResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetDwListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDwListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDwListResponse, SOAP_TYPE__ns1__GetDwListResponse, sizeof(_ns1__GetDwListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetDwListResponse * SOAP_FMAC2 soap_instantiate__ns1__GetDwListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDwListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetDwListResponse *p;
	size_t k = sizeof(_ns1__GetDwListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetDwListResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetDwListResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetDwListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetDwListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetDwListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetDwListResponse(soap, tag ? tag : "ns1:GetDwListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDwListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDwListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDwListResponse * SOAP_FMAC4 soap_get__ns1__GetDwListResponse(struct soap *soap, _ns1__GetDwListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDwListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetDwList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetDwList::dwname);
	/* transient soap skipped */
}

void _ns1__GetDwList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDwList::dwname);
#endif
}

int _ns1__GetDwList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDwList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDwList(struct soap *soap, const char *tag, int id, const _ns1__GetDwList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDwList), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__GetDwList::dwname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDwList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDwList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDwList * SOAP_FMAC4 soap_in__ns1__GetDwList(struct soap *soap, const char *tag, _ns1__GetDwList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDwList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDwList, sizeof(_ns1__GetDwList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetDwList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetDwList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dwname1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__GetDwList::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDwList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDwList, SOAP_TYPE__ns1__GetDwList, sizeof(_ns1__GetDwList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetDwList * SOAP_FMAC2 soap_instantiate__ns1__GetDwList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDwList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetDwList *p;
	size_t k = sizeof(_ns1__GetDwList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetDwList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetDwList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetDwList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetDwList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetDwList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetDwList(soap, tag ? tag : "ns1:GetDwList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDwList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDwList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDwList * SOAP_FMAC4 soap_get__ns1__GetDwList(struct soap *soap, _ns1__GetDwList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDwList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetOpenFireInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetOpenFireInfoResponse::GetOpenFireInfoResult);
	/* transient soap skipped */
}

void _ns1__GetOpenFireInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetOpenFireInfoResponse::GetOpenFireInfoResult);
#endif
}

int _ns1__GetOpenFireInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetOpenFireInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetOpenFireInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetOpenFireInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetOpenFireInfoResponse), type))
		return soap->error;
	if (a->GetOpenFireInfoResult)
		soap_element_result(soap, "ns1:GetOpenFireInfoResult");
	if (soap_out_string(soap, "ns1:GetOpenFireInfoResult", -1, (char*const*)&a->_ns1__GetOpenFireInfoResponse::GetOpenFireInfoResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetOpenFireInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetOpenFireInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetOpenFireInfoResponse * SOAP_FMAC4 soap_in__ns1__GetOpenFireInfoResponse(struct soap *soap, const char *tag, _ns1__GetOpenFireInfoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetOpenFireInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetOpenFireInfoResponse, sizeof(_ns1__GetOpenFireInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetOpenFireInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetOpenFireInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetOpenFireInfoResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetOpenFireInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetOpenFireInfoResult", (char**)&a->_ns1__GetOpenFireInfoResponse::GetOpenFireInfoResult, "xsd:string"))
				{	soap_flag_GetOpenFireInfoResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetOpenFireInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetOpenFireInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetOpenFireInfoResponse, SOAP_TYPE__ns1__GetOpenFireInfoResponse, sizeof(_ns1__GetOpenFireInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetOpenFireInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__GetOpenFireInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetOpenFireInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetOpenFireInfoResponse *p;
	size_t k = sizeof(_ns1__GetOpenFireInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetOpenFireInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetOpenFireInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetOpenFireInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetOpenFireInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetOpenFireInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetOpenFireInfoResponse(soap, tag ? tag : "ns1:GetOpenFireInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetOpenFireInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetOpenFireInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetOpenFireInfoResponse * SOAP_FMAC4 soap_get__ns1__GetOpenFireInfoResponse(struct soap *soap, _ns1__GetOpenFireInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetOpenFireInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetOpenFireInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetOpenFireInfo::dwnam);
	soap_default_string(soap, &this->_ns1__GetOpenFireInfo::unit);
	/* transient soap skipped */
}

void _ns1__GetOpenFireInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetOpenFireInfo::dwnam);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetOpenFireInfo::unit);
#endif
}

int _ns1__GetOpenFireInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetOpenFireInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetOpenFireInfo(struct soap *soap, const char *tag, int id, const _ns1__GetOpenFireInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetOpenFireInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwnam", -1, (char*const*)&a->_ns1__GetOpenFireInfo::dwnam, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:unit", -1, (char*const*)&a->_ns1__GetOpenFireInfo::unit, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetOpenFireInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetOpenFireInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetOpenFireInfo * SOAP_FMAC4 soap_in__ns1__GetOpenFireInfo(struct soap *soap, const char *tag, _ns1__GetOpenFireInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetOpenFireInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetOpenFireInfo, sizeof(_ns1__GetOpenFireInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetOpenFireInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetOpenFireInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dwnam1 = 1;
	size_t soap_flag_unit1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dwnam1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwnam", (char**)&a->_ns1__GetOpenFireInfo::dwnam, "xsd:string"))
				{	soap_flag_dwnam1--;
					continue;
				}
			}
			if (soap_flag_unit1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:unit", (char**)&a->_ns1__GetOpenFireInfo::unit, "xsd:string"))
				{	soap_flag_unit1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetOpenFireInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetOpenFireInfo, SOAP_TYPE__ns1__GetOpenFireInfo, sizeof(_ns1__GetOpenFireInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetOpenFireInfo * SOAP_FMAC2 soap_instantiate__ns1__GetOpenFireInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetOpenFireInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetOpenFireInfo *p;
	size_t k = sizeof(_ns1__GetOpenFireInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetOpenFireInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetOpenFireInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetOpenFireInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetOpenFireInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetOpenFireInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetOpenFireInfo(soap, tag ? tag : "ns1:GetOpenFireInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetOpenFireInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetOpenFireInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetOpenFireInfo * SOAP_FMAC4 soap_get__ns1__GetOpenFireInfo(struct soap *soap, _ns1__GetOpenFireInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetOpenFireInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__MobDownLoadDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__MobDownLoadDataResponse::MobDownLoadDataResult);
	/* transient soap skipped */
}

void _ns1__MobDownLoadDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__MobDownLoadDataResponse::MobDownLoadDataResult);
#endif
}

int _ns1__MobDownLoadDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__MobDownLoadDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__MobDownLoadDataResponse(struct soap *soap, const char *tag, int id, const _ns1__MobDownLoadDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__MobDownLoadDataResponse), type))
		return soap->error;
	if (a->MobDownLoadDataResult)
		soap_element_result(soap, "ns1:MobDownLoadDataResult");
	if (soap_out_string(soap, "ns1:MobDownLoadDataResult", -1, (char*const*)&a->_ns1__MobDownLoadDataResponse::MobDownLoadDataResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__MobDownLoadDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__MobDownLoadDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__MobDownLoadDataResponse * SOAP_FMAC4 soap_in__ns1__MobDownLoadDataResponse(struct soap *soap, const char *tag, _ns1__MobDownLoadDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__MobDownLoadDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__MobDownLoadDataResponse, sizeof(_ns1__MobDownLoadDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__MobDownLoadDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__MobDownLoadDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MobDownLoadDataResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MobDownLoadDataResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:MobDownLoadDataResult", (char**)&a->_ns1__MobDownLoadDataResponse::MobDownLoadDataResult, "xsd:string"))
				{	soap_flag_MobDownLoadDataResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:MobDownLoadDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__MobDownLoadDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__MobDownLoadDataResponse, SOAP_TYPE__ns1__MobDownLoadDataResponse, sizeof(_ns1__MobDownLoadDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__MobDownLoadDataResponse * SOAP_FMAC2 soap_instantiate__ns1__MobDownLoadDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__MobDownLoadDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__MobDownLoadDataResponse *p;
	size_t k = sizeof(_ns1__MobDownLoadDataResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__MobDownLoadDataResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__MobDownLoadDataResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__MobDownLoadDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__MobDownLoadDataResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__MobDownLoadDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__MobDownLoadDataResponse(soap, tag ? tag : "ns1:MobDownLoadDataResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__MobDownLoadDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__MobDownLoadDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__MobDownLoadDataResponse * SOAP_FMAC4 soap_get__ns1__MobDownLoadDataResponse(struct soap *soap, _ns1__MobDownLoadDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__MobDownLoadDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__MobDownLoadData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__MobDownLoadData::dwname);
	soap_default_string(soap, &this->_ns1__MobDownLoadData::unitname);
	soap_default_string(soap, &this->_ns1__MobDownLoadData::tabname);
	soap_default_string(soap, &this->_ns1__MobDownLoadData::sytime);
	soap_default_int(soap, &this->_ns1__MobDownLoadData::level);
	soap_default_string(soap, &this->_ns1__MobDownLoadData::stfield);
	soap_default_string(soap, &this->_ns1__MobDownLoadData::filename);
	/* transient soap skipped */
}

void _ns1__MobDownLoadData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__MobDownLoadData::dwname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__MobDownLoadData::unitname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__MobDownLoadData::tabname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__MobDownLoadData::sytime);
	soap_serialize_string(soap, (char*const*)&this->_ns1__MobDownLoadData::stfield);
	soap_serialize_string(soap, (char*const*)&this->_ns1__MobDownLoadData::filename);
#endif
}

int _ns1__MobDownLoadData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__MobDownLoadData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__MobDownLoadData(struct soap *soap, const char *tag, int id, const _ns1__MobDownLoadData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__MobDownLoadData), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__MobDownLoadData::dwname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:unitname", -1, (char*const*)&a->_ns1__MobDownLoadData::unitname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:tabname", -1, (char*const*)&a->_ns1__MobDownLoadData::tabname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:sytime", -1, (char*const*)&a->_ns1__MobDownLoadData::sytime, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:level", -1, &a->_ns1__MobDownLoadData::level, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:stfield", -1, (char*const*)&a->_ns1__MobDownLoadData::stfield, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, (char*const*)&a->_ns1__MobDownLoadData::filename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__MobDownLoadData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__MobDownLoadData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__MobDownLoadData * SOAP_FMAC4 soap_in__ns1__MobDownLoadData(struct soap *soap, const char *tag, _ns1__MobDownLoadData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__MobDownLoadData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__MobDownLoadData, sizeof(_ns1__MobDownLoadData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__MobDownLoadData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__MobDownLoadData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dwname1 = 1;
	size_t soap_flag_unitname1 = 1;
	size_t soap_flag_tabname1 = 1;
	size_t soap_flag_sytime1 = 1;
	size_t soap_flag_level1 = 1;
	size_t soap_flag_stfield1 = 1;
	size_t soap_flag_filename1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__MobDownLoadData::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap_flag_unitname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:unitname", (char**)&a->_ns1__MobDownLoadData::unitname, "xsd:string"))
				{	soap_flag_unitname1--;
					continue;
				}
			}
			if (soap_flag_tabname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:tabname", (char**)&a->_ns1__MobDownLoadData::tabname, "xsd:string"))
				{	soap_flag_tabname1--;
					continue;
				}
			}
			if (soap_flag_sytime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:sytime", (char**)&a->_ns1__MobDownLoadData::sytime, "xsd:string"))
				{	soap_flag_sytime1--;
					continue;
				}
			}
			if (soap_flag_level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:level", &a->_ns1__MobDownLoadData::level, "xsd:int"))
				{	soap_flag_level1--;
					continue;
				}
			}
			if (soap_flag_stfield1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:stfield", (char**)&a->_ns1__MobDownLoadData::stfield, "xsd:string"))
				{	soap_flag_stfield1--;
					continue;
				}
			}
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:filename", (char**)&a->_ns1__MobDownLoadData::filename, "xsd:string"))
				{	soap_flag_filename1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_level1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__MobDownLoadData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__MobDownLoadData, SOAP_TYPE__ns1__MobDownLoadData, sizeof(_ns1__MobDownLoadData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__MobDownLoadData * SOAP_FMAC2 soap_instantiate__ns1__MobDownLoadData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__MobDownLoadData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__MobDownLoadData *p;
	size_t k = sizeof(_ns1__MobDownLoadData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__MobDownLoadData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__MobDownLoadData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__MobDownLoadData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__MobDownLoadData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__MobDownLoadData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__MobDownLoadData(soap, tag ? tag : "ns1:MobDownLoadData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__MobDownLoadData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__MobDownLoadData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__MobDownLoadData * SOAP_FMAC4 soap_get__ns1__MobDownLoadData(struct soap *soap, _ns1__MobDownLoadData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__MobDownLoadData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DownLoadMobGPSDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__DownLoadMobGPSDataResponse::DownLoadMobGPSDataResult);
	/* transient soap skipped */
}

void _ns1__DownLoadMobGPSDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__DownLoadMobGPSDataResponse::DownLoadMobGPSDataResult);
#endif
}

int _ns1__DownLoadMobGPSDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DownLoadMobGPSDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DownLoadMobGPSDataResponse(struct soap *soap, const char *tag, int id, const _ns1__DownLoadMobGPSDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DownLoadMobGPSDataResponse), type))
		return soap->error;
	if (a->DownLoadMobGPSDataResult)
		soap_element_result(soap, "ns1:DownLoadMobGPSDataResult");
	if (soap_out_string(soap, "ns1:DownLoadMobGPSDataResult", -1, (char*const*)&a->_ns1__DownLoadMobGPSDataResponse::DownLoadMobGPSDataResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DownLoadMobGPSDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DownLoadMobGPSDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DownLoadMobGPSDataResponse * SOAP_FMAC4 soap_in__ns1__DownLoadMobGPSDataResponse(struct soap *soap, const char *tag, _ns1__DownLoadMobGPSDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DownLoadMobGPSDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DownLoadMobGPSDataResponse, sizeof(_ns1__DownLoadMobGPSDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__DownLoadMobGPSDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__DownLoadMobGPSDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DownLoadMobGPSDataResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DownLoadMobGPSDataResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:DownLoadMobGPSDataResult", (char**)&a->_ns1__DownLoadMobGPSDataResponse::DownLoadMobGPSDataResult, "xsd:string"))
				{	soap_flag_DownLoadMobGPSDataResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:DownLoadMobGPSDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DownLoadMobGPSDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DownLoadMobGPSDataResponse, SOAP_TYPE__ns1__DownLoadMobGPSDataResponse, sizeof(_ns1__DownLoadMobGPSDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DownLoadMobGPSDataResponse * SOAP_FMAC2 soap_instantiate__ns1__DownLoadMobGPSDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DownLoadMobGPSDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DownLoadMobGPSDataResponse *p;
	size_t k = sizeof(_ns1__DownLoadMobGPSDataResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__DownLoadMobGPSDataResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__DownLoadMobGPSDataResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__DownLoadMobGPSDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DownLoadMobGPSDataResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__DownLoadMobGPSDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__DownLoadMobGPSDataResponse(soap, tag ? tag : "ns1:DownLoadMobGPSDataResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DownLoadMobGPSDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DownLoadMobGPSDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DownLoadMobGPSDataResponse * SOAP_FMAC4 soap_get__ns1__DownLoadMobGPSDataResponse(struct soap *soap, _ns1__DownLoadMobGPSDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DownLoadMobGPSDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DownLoadMobGPSData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__DownLoadMobGPSData::dwname);
	soap_default_string(soap, &this->_ns1__DownLoadMobGPSData::tabname);
	soap_default_string(soap, &this->_ns1__DownLoadMobGPSData::sytime);
	soap_default_int(soap, &this->_ns1__DownLoadMobGPSData::level);
	/* transient soap skipped */
}

void _ns1__DownLoadMobGPSData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__DownLoadMobGPSData::dwname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__DownLoadMobGPSData::tabname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__DownLoadMobGPSData::sytime);
#endif
}

int _ns1__DownLoadMobGPSData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DownLoadMobGPSData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DownLoadMobGPSData(struct soap *soap, const char *tag, int id, const _ns1__DownLoadMobGPSData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DownLoadMobGPSData), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__DownLoadMobGPSData::dwname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:tabname", -1, (char*const*)&a->_ns1__DownLoadMobGPSData::tabname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:sytime", -1, (char*const*)&a->_ns1__DownLoadMobGPSData::sytime, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:level", -1, &a->_ns1__DownLoadMobGPSData::level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DownLoadMobGPSData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DownLoadMobGPSData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DownLoadMobGPSData * SOAP_FMAC4 soap_in__ns1__DownLoadMobGPSData(struct soap *soap, const char *tag, _ns1__DownLoadMobGPSData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DownLoadMobGPSData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DownLoadMobGPSData, sizeof(_ns1__DownLoadMobGPSData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__DownLoadMobGPSData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__DownLoadMobGPSData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dwname1 = 1;
	size_t soap_flag_tabname1 = 1;
	size_t soap_flag_sytime1 = 1;
	size_t soap_flag_level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__DownLoadMobGPSData::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap_flag_tabname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:tabname", (char**)&a->_ns1__DownLoadMobGPSData::tabname, "xsd:string"))
				{	soap_flag_tabname1--;
					continue;
				}
			}
			if (soap_flag_sytime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:sytime", (char**)&a->_ns1__DownLoadMobGPSData::sytime, "xsd:string"))
				{	soap_flag_sytime1--;
					continue;
				}
			}
			if (soap_flag_level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:level", &a->_ns1__DownLoadMobGPSData::level, "xsd:int"))
				{	soap_flag_level1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_level1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__DownLoadMobGPSData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DownLoadMobGPSData, SOAP_TYPE__ns1__DownLoadMobGPSData, sizeof(_ns1__DownLoadMobGPSData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DownLoadMobGPSData * SOAP_FMAC2 soap_instantiate__ns1__DownLoadMobGPSData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DownLoadMobGPSData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DownLoadMobGPSData *p;
	size_t k = sizeof(_ns1__DownLoadMobGPSData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__DownLoadMobGPSData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__DownLoadMobGPSData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__DownLoadMobGPSData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DownLoadMobGPSData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__DownLoadMobGPSData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__DownLoadMobGPSData(soap, tag ? tag : "ns1:DownLoadMobGPSData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DownLoadMobGPSData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DownLoadMobGPSData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DownLoadMobGPSData * SOAP_FMAC4 soap_get__ns1__DownLoadMobGPSData(struct soap *soap, _ns1__DownLoadMobGPSData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DownLoadMobGPSData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetDcsDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetDcsDataResponse::GetDcsDataResult);
	/* transient soap skipped */
}

void _ns1__GetDcsDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDcsDataResponse::GetDcsDataResult);
#endif
}

int _ns1__GetDcsDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDcsDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDcsDataResponse(struct soap *soap, const char *tag, int id, const _ns1__GetDcsDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDcsDataResponse), type))
		return soap->error;
	if (a->GetDcsDataResult)
		soap_element_result(soap, "ns1:GetDcsDataResult");
	if (soap_out_string(soap, "ns1:GetDcsDataResult", -1, (char*const*)&a->_ns1__GetDcsDataResponse::GetDcsDataResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDcsDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDcsDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDcsDataResponse * SOAP_FMAC4 soap_in__ns1__GetDcsDataResponse(struct soap *soap, const char *tag, _ns1__GetDcsDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDcsDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDcsDataResponse, sizeof(_ns1__GetDcsDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetDcsDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetDcsDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetDcsDataResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetDcsDataResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetDcsDataResult", (char**)&a->_ns1__GetDcsDataResponse::GetDcsDataResult, "xsd:string"))
				{	soap_flag_GetDcsDataResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetDcsDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDcsDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDcsDataResponse, SOAP_TYPE__ns1__GetDcsDataResponse, sizeof(_ns1__GetDcsDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetDcsDataResponse * SOAP_FMAC2 soap_instantiate__ns1__GetDcsDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDcsDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetDcsDataResponse *p;
	size_t k = sizeof(_ns1__GetDcsDataResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetDcsDataResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetDcsDataResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetDcsDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetDcsDataResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetDcsDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetDcsDataResponse(soap, tag ? tag : "ns1:GetDcsDataResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDcsDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDcsDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDcsDataResponse * SOAP_FMAC4 soap_get__ns1__GetDcsDataResponse(struct soap *soap, _ns1__GetDcsDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDcsDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetDcsData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetDcsData::xb);
	soap_default_string(soap, &this->_ns1__GetDcsData::station);
	soap_default_string(soap, &this->_ns1__GetDcsData::iconname);
	soap_default_string(soap, &this->_ns1__GetDcsData::filename);
	/* transient soap skipped */
}

void _ns1__GetDcsData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDcsData::xb);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDcsData::station);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDcsData::iconname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDcsData::filename);
#endif
}

int _ns1__GetDcsData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDcsData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDcsData(struct soap *soap, const char *tag, int id, const _ns1__GetDcsData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDcsData), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xb", -1, (char*const*)&a->_ns1__GetDcsData::xb, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:station", -1, (char*const*)&a->_ns1__GetDcsData::station, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:iconname", -1, (char*const*)&a->_ns1__GetDcsData::iconname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, (char*const*)&a->_ns1__GetDcsData::filename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDcsData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDcsData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDcsData * SOAP_FMAC4 soap_in__ns1__GetDcsData(struct soap *soap, const char *tag, _ns1__GetDcsData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDcsData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDcsData, sizeof(_ns1__GetDcsData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetDcsData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetDcsData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_xb1 = 1;
	size_t soap_flag_station1 = 1;
	size_t soap_flag_iconname1 = 1;
	size_t soap_flag_filename1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:xb", (char**)&a->_ns1__GetDcsData::xb, "xsd:string"))
				{	soap_flag_xb1--;
					continue;
				}
			}
			if (soap_flag_station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:station", (char**)&a->_ns1__GetDcsData::station, "xsd:string"))
				{	soap_flag_station1--;
					continue;
				}
			}
			if (soap_flag_iconname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:iconname", (char**)&a->_ns1__GetDcsData::iconname, "xsd:string"))
				{	soap_flag_iconname1--;
					continue;
				}
			}
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:filename", (char**)&a->_ns1__GetDcsData::filename, "xsd:string"))
				{	soap_flag_filename1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDcsData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDcsData, SOAP_TYPE__ns1__GetDcsData, sizeof(_ns1__GetDcsData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetDcsData * SOAP_FMAC2 soap_instantiate__ns1__GetDcsData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDcsData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetDcsData *p;
	size_t k = sizeof(_ns1__GetDcsData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetDcsData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetDcsData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetDcsData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetDcsData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetDcsData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetDcsData(soap, tag ? tag : "ns1:GetDcsData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDcsData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDcsData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDcsData * SOAP_FMAC4 soap_get__ns1__GetDcsData(struct soap *soap, _ns1__GetDcsData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDcsData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetBgImgResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetBgImgResponse::GetBgImgResult);
	/* transient soap skipped */
}

void _ns1__GetBgImgResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetBgImgResponse::GetBgImgResult);
#endif
}

int _ns1__GetBgImgResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetBgImgResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetBgImgResponse(struct soap *soap, const char *tag, int id, const _ns1__GetBgImgResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetBgImgResponse), type))
		return soap->error;
	if (a->GetBgImgResult)
		soap_element_result(soap, "ns1:GetBgImgResult");
	if (soap_out_string(soap, "ns1:GetBgImgResult", -1, (char*const*)&a->_ns1__GetBgImgResponse::GetBgImgResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetBgImgResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetBgImgResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetBgImgResponse * SOAP_FMAC4 soap_in__ns1__GetBgImgResponse(struct soap *soap, const char *tag, _ns1__GetBgImgResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetBgImgResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetBgImgResponse, sizeof(_ns1__GetBgImgResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetBgImgResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetBgImgResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetBgImgResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetBgImgResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetBgImgResult", (char**)&a->_ns1__GetBgImgResponse::GetBgImgResult, "xsd:string"))
				{	soap_flag_GetBgImgResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetBgImgResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetBgImgResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetBgImgResponse, SOAP_TYPE__ns1__GetBgImgResponse, sizeof(_ns1__GetBgImgResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetBgImgResponse * SOAP_FMAC2 soap_instantiate__ns1__GetBgImgResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetBgImgResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetBgImgResponse *p;
	size_t k = sizeof(_ns1__GetBgImgResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetBgImgResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetBgImgResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetBgImgResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetBgImgResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetBgImgResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetBgImgResponse(soap, tag ? tag : "ns1:GetBgImgResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetBgImgResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetBgImgResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetBgImgResponse * SOAP_FMAC4 soap_get__ns1__GetBgImgResponse(struct soap *soap, _ns1__GetBgImgResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetBgImgResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetBgImg::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetBgImg::pguid);
	/* transient soap skipped */
}

void _ns1__GetBgImg::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetBgImg::pguid);
#endif
}

int _ns1__GetBgImg::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetBgImg(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetBgImg(struct soap *soap, const char *tag, int id, const _ns1__GetBgImg *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetBgImg), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:pguid", -1, (char*const*)&a->_ns1__GetBgImg::pguid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetBgImg::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetBgImg(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetBgImg * SOAP_FMAC4 soap_in__ns1__GetBgImg(struct soap *soap, const char *tag, _ns1__GetBgImg *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetBgImg *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetBgImg, sizeof(_ns1__GetBgImg), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetBgImg)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetBgImg *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_pguid1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pguid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:pguid", (char**)&a->_ns1__GetBgImg::pguid, "xsd:string"))
				{	soap_flag_pguid1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetBgImg *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetBgImg, SOAP_TYPE__ns1__GetBgImg, sizeof(_ns1__GetBgImg), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetBgImg * SOAP_FMAC2 soap_instantiate__ns1__GetBgImg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetBgImg(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetBgImg *p;
	size_t k = sizeof(_ns1__GetBgImg);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetBgImg, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetBgImg);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetBgImg, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetBgImg location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetBgImg::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetBgImg(soap, tag ? tag : "ns1:GetBgImg", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetBgImg::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetBgImg(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetBgImg * SOAP_FMAC4 soap_get__ns1__GetBgImg(struct soap *soap, _ns1__GetBgImg *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetBgImg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetDevPicResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetDevPicResponse::GetDevPicResult);
	/* transient soap skipped */
}

void _ns1__GetDevPicResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDevPicResponse::GetDevPicResult);
#endif
}

int _ns1__GetDevPicResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDevPicResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDevPicResponse(struct soap *soap, const char *tag, int id, const _ns1__GetDevPicResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDevPicResponse), type))
		return soap->error;
	if (a->GetDevPicResult)
		soap_element_result(soap, "ns1:GetDevPicResult");
	if (soap_out_string(soap, "ns1:GetDevPicResult", -1, (char*const*)&a->_ns1__GetDevPicResponse::GetDevPicResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDevPicResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDevPicResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDevPicResponse * SOAP_FMAC4 soap_in__ns1__GetDevPicResponse(struct soap *soap, const char *tag, _ns1__GetDevPicResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDevPicResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDevPicResponse, sizeof(_ns1__GetDevPicResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetDevPicResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetDevPicResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetDevPicResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetDevPicResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetDevPicResult", (char**)&a->_ns1__GetDevPicResponse::GetDevPicResult, "xsd:string"))
				{	soap_flag_GetDevPicResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetDevPicResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDevPicResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDevPicResponse, SOAP_TYPE__ns1__GetDevPicResponse, sizeof(_ns1__GetDevPicResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetDevPicResponse * SOAP_FMAC2 soap_instantiate__ns1__GetDevPicResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDevPicResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetDevPicResponse *p;
	size_t k = sizeof(_ns1__GetDevPicResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetDevPicResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetDevPicResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetDevPicResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetDevPicResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetDevPicResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetDevPicResponse(soap, tag ? tag : "ns1:GetDevPicResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDevPicResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDevPicResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDevPicResponse * SOAP_FMAC4 soap_get__ns1__GetDevPicResponse(struct soap *soap, _ns1__GetDevPicResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDevPicResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetDevPic::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetDevPic::dwname);
	soap_default_string(soap, &this->_ns1__GetDevPic::xb);
	soap_default_string(soap, &this->_ns1__GetDevPic::station);
	soap_default_string(soap, &this->_ns1__GetDevPic::iconname);
	soap_default_string(soap, &this->_ns1__GetDevPic::type);
	soap_default_bool(soap, &this->_ns1__GetDevPic::sflag);
	soap_default_string(soap, &this->_ns1__GetDevPic::s1);
	soap_default_string(soap, &this->_ns1__GetDevPic::s2);
	/* transient soap skipped */
}

void _ns1__GetDevPic::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDevPic::dwname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDevPic::xb);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDevPic::station);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDevPic::iconname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDevPic::type);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDevPic::s1);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDevPic::s2);
#endif
}

int _ns1__GetDevPic::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDevPic(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDevPic(struct soap *soap, const char *tag, int id, const _ns1__GetDevPic *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDevPic), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__GetDevPic::dwname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:xb", -1, (char*const*)&a->_ns1__GetDevPic::xb, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:station", -1, (char*const*)&a->_ns1__GetDevPic::station, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:iconname", -1, (char*const*)&a->_ns1__GetDevPic::iconname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:type", -1, (char*const*)&a->_ns1__GetDevPic::type, ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:sflag", -1, &a->_ns1__GetDevPic::sflag, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:s1", -1, (char*const*)&a->_ns1__GetDevPic::s1, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:s2", -1, (char*const*)&a->_ns1__GetDevPic::s2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDevPic::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDevPic(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDevPic * SOAP_FMAC4 soap_in__ns1__GetDevPic(struct soap *soap, const char *tag, _ns1__GetDevPic *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDevPic *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDevPic, sizeof(_ns1__GetDevPic), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetDevPic)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetDevPic *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dwname1 = 1;
	size_t soap_flag_xb1 = 1;
	size_t soap_flag_station1 = 1;
	size_t soap_flag_iconname1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_sflag1 = 1;
	size_t soap_flag_s11 = 1;
	size_t soap_flag_s21 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__GetDevPic::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap_flag_xb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:xb", (char**)&a->_ns1__GetDevPic::xb, "xsd:string"))
				{	soap_flag_xb1--;
					continue;
				}
			}
			if (soap_flag_station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:station", (char**)&a->_ns1__GetDevPic::station, "xsd:string"))
				{	soap_flag_station1--;
					continue;
				}
			}
			if (soap_flag_iconname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:iconname", (char**)&a->_ns1__GetDevPic::iconname, "xsd:string"))
				{	soap_flag_iconname1--;
					continue;
				}
			}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:type", (char**)&a->_ns1__GetDevPic::type, "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			}
			if (soap_flag_sflag1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "ns1:sflag", &a->_ns1__GetDevPic::sflag, "xsd:boolean"))
				{	soap_flag_sflag1--;
					continue;
				}
			}
			if (soap_flag_s11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:s1", (char**)&a->_ns1__GetDevPic::s1, "xsd:string"))
				{	soap_flag_s11--;
					continue;
				}
			}
			if (soap_flag_s21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:s2", (char**)&a->_ns1__GetDevPic::s2, "xsd:string"))
				{	soap_flag_s21--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sflag1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetDevPic *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDevPic, SOAP_TYPE__ns1__GetDevPic, sizeof(_ns1__GetDevPic), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetDevPic * SOAP_FMAC2 soap_instantiate__ns1__GetDevPic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDevPic(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetDevPic *p;
	size_t k = sizeof(_ns1__GetDevPic);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetDevPic, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetDevPic);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetDevPic, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetDevPic location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetDevPic::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetDevPic(soap, tag ? tag : "ns1:GetDevPic", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDevPic::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDevPic(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDevPic * SOAP_FMAC4 soap_get__ns1__GetDevPic(struct soap *soap, _ns1__GetDevPic *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDevPic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetJxPicResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetJxPicResponse::GetJxPicResult);
	/* transient soap skipped */
}

void _ns1__GetJxPicResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetJxPicResponse::GetJxPicResult);
#endif
}

int _ns1__GetJxPicResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetJxPicResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetJxPicResponse(struct soap *soap, const char *tag, int id, const _ns1__GetJxPicResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetJxPicResponse), type))
		return soap->error;
	if (a->GetJxPicResult)
		soap_element_result(soap, "ns1:GetJxPicResult");
	if (soap_out_string(soap, "ns1:GetJxPicResult", -1, (char*const*)&a->_ns1__GetJxPicResponse::GetJxPicResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetJxPicResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetJxPicResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetJxPicResponse * SOAP_FMAC4 soap_in__ns1__GetJxPicResponse(struct soap *soap, const char *tag, _ns1__GetJxPicResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetJxPicResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetJxPicResponse, sizeof(_ns1__GetJxPicResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetJxPicResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetJxPicResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetJxPicResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetJxPicResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetJxPicResult", (char**)&a->_ns1__GetJxPicResponse::GetJxPicResult, "xsd:string"))
				{	soap_flag_GetJxPicResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetJxPicResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetJxPicResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetJxPicResponse, SOAP_TYPE__ns1__GetJxPicResponse, sizeof(_ns1__GetJxPicResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetJxPicResponse * SOAP_FMAC2 soap_instantiate__ns1__GetJxPicResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetJxPicResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetJxPicResponse *p;
	size_t k = sizeof(_ns1__GetJxPicResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetJxPicResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetJxPicResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetJxPicResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetJxPicResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetJxPicResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetJxPicResponse(soap, tag ? tag : "ns1:GetJxPicResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetJxPicResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetJxPicResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetJxPicResponse * SOAP_FMAC4 soap_get__ns1__GetJxPicResponse(struct soap *soap, _ns1__GetJxPicResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetJxPicResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetJxPic::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetJxPic::dwname);
	soap_default_string(soap, &this->_ns1__GetJxPic::upguid);
	soap_default_string(soap, &this->_ns1__GetJxPic::type);
	/* transient soap skipped */
}

void _ns1__GetJxPic::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetJxPic::dwname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetJxPic::upguid);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetJxPic::type);
#endif
}

int _ns1__GetJxPic::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetJxPic(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetJxPic(struct soap *soap, const char *tag, int id, const _ns1__GetJxPic *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetJxPic), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__GetJxPic::dwname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:upguid", -1, (char*const*)&a->_ns1__GetJxPic::upguid, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:type", -1, (char*const*)&a->_ns1__GetJxPic::type, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetJxPic::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetJxPic(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetJxPic * SOAP_FMAC4 soap_in__ns1__GetJxPic(struct soap *soap, const char *tag, _ns1__GetJxPic *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetJxPic *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetJxPic, sizeof(_ns1__GetJxPic), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetJxPic)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetJxPic *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dwname1 = 1;
	size_t soap_flag_upguid1 = 1;
	size_t soap_flag_type1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__GetJxPic::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap_flag_upguid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:upguid", (char**)&a->_ns1__GetJxPic::upguid, "xsd:string"))
				{	soap_flag_upguid1--;
					continue;
				}
			}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:type", (char**)&a->_ns1__GetJxPic::type, "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetJxPic *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetJxPic, SOAP_TYPE__ns1__GetJxPic, sizeof(_ns1__GetJxPic), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetJxPic * SOAP_FMAC2 soap_instantiate__ns1__GetJxPic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetJxPic(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetJxPic *p;
	size_t k = sizeof(_ns1__GetJxPic);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetJxPic, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetJxPic);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetJxPic, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetJxPic location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetJxPic::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetJxPic(soap, tag ? tag : "ns1:GetJxPic", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetJxPic::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetJxPic(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetJxPic * SOAP_FMAC4 soap_get__ns1__GetJxPic(struct soap *soap, _ns1__GetJxPic *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetJxPic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetStationJxDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetStationJxDataResponse::GetStationJxDataResult);
	/* transient soap skipped */
}

void _ns1__GetStationJxDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetStationJxDataResponse::GetStationJxDataResult);
#endif
}

int _ns1__GetStationJxDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetStationJxDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetStationJxDataResponse(struct soap *soap, const char *tag, int id, const _ns1__GetStationJxDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetStationJxDataResponse), type))
		return soap->error;
	if (a->GetStationJxDataResult)
		soap_element_result(soap, "ns1:GetStationJxDataResult");
	if (soap_out_string(soap, "ns1:GetStationJxDataResult", -1, (char*const*)&a->_ns1__GetStationJxDataResponse::GetStationJxDataResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetStationJxDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetStationJxDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetStationJxDataResponse * SOAP_FMAC4 soap_in__ns1__GetStationJxDataResponse(struct soap *soap, const char *tag, _ns1__GetStationJxDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetStationJxDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetStationJxDataResponse, sizeof(_ns1__GetStationJxDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetStationJxDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetStationJxDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetStationJxDataResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetStationJxDataResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetStationJxDataResult", (char**)&a->_ns1__GetStationJxDataResponse::GetStationJxDataResult, "xsd:string"))
				{	soap_flag_GetStationJxDataResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetStationJxDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetStationJxDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetStationJxDataResponse, SOAP_TYPE__ns1__GetStationJxDataResponse, sizeof(_ns1__GetStationJxDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetStationJxDataResponse * SOAP_FMAC2 soap_instantiate__ns1__GetStationJxDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetStationJxDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetStationJxDataResponse *p;
	size_t k = sizeof(_ns1__GetStationJxDataResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetStationJxDataResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetStationJxDataResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetStationJxDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetStationJxDataResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetStationJxDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetStationJxDataResponse(soap, tag ? tag : "ns1:GetStationJxDataResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetStationJxDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetStationJxDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetStationJxDataResponse * SOAP_FMAC4 soap_get__ns1__GetStationJxDataResponse(struct soap *soap, _ns1__GetStationJxDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetStationJxDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetStationJxData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetStationJxData::dwname);
	soap_default_string(soap, &this->_ns1__GetStationJxData::xb);
	soap_default_string(soap, &this->_ns1__GetStationJxData::station);
	soap_default_bool(soap, &this->_ns1__GetStationJxData::sflag);
	/* transient soap skipped */
}

void _ns1__GetStationJxData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetStationJxData::dwname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetStationJxData::xb);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetStationJxData::station);
#endif
}

int _ns1__GetStationJxData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetStationJxData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetStationJxData(struct soap *soap, const char *tag, int id, const _ns1__GetStationJxData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetStationJxData), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__GetStationJxData::dwname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:xb", -1, (char*const*)&a->_ns1__GetStationJxData::xb, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:station", -1, (char*const*)&a->_ns1__GetStationJxData::station, ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:sflag", -1, &a->_ns1__GetStationJxData::sflag, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetStationJxData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetStationJxData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetStationJxData * SOAP_FMAC4 soap_in__ns1__GetStationJxData(struct soap *soap, const char *tag, _ns1__GetStationJxData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetStationJxData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetStationJxData, sizeof(_ns1__GetStationJxData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetStationJxData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetStationJxData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dwname1 = 1;
	size_t soap_flag_xb1 = 1;
	size_t soap_flag_station1 = 1;
	size_t soap_flag_sflag1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__GetStationJxData::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap_flag_xb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:xb", (char**)&a->_ns1__GetStationJxData::xb, "xsd:string"))
				{	soap_flag_xb1--;
					continue;
				}
			}
			if (soap_flag_station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:station", (char**)&a->_ns1__GetStationJxData::station, "xsd:string"))
				{	soap_flag_station1--;
					continue;
				}
			}
			if (soap_flag_sflag1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "ns1:sflag", &a->_ns1__GetStationJxData::sflag, "xsd:boolean"))
				{	soap_flag_sflag1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sflag1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetStationJxData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetStationJxData, SOAP_TYPE__ns1__GetStationJxData, sizeof(_ns1__GetStationJxData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetStationJxData * SOAP_FMAC2 soap_instantiate__ns1__GetStationJxData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetStationJxData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetStationJxData *p;
	size_t k = sizeof(_ns1__GetStationJxData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetStationJxData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetStationJxData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetStationJxData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetStationJxData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetStationJxData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetStationJxData(soap, tag ? tag : "ns1:GetStationJxData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetStationJxData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetStationJxData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetStationJxData * SOAP_FMAC4 soap_get__ns1__GetStationJxData(struct soap *soap, _ns1__GetStationJxData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetStationJxData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetJxDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetJxDataResponse::GetJxDataResult);
	/* transient soap skipped */
}

void _ns1__GetJxDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetJxDataResponse::GetJxDataResult);
#endif
}

int _ns1__GetJxDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetJxDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetJxDataResponse(struct soap *soap, const char *tag, int id, const _ns1__GetJxDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetJxDataResponse), type))
		return soap->error;
	if (a->GetJxDataResult)
		soap_element_result(soap, "ns1:GetJxDataResult");
	if (soap_out_string(soap, "ns1:GetJxDataResult", -1, (char*const*)&a->_ns1__GetJxDataResponse::GetJxDataResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetJxDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetJxDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetJxDataResponse * SOAP_FMAC4 soap_in__ns1__GetJxDataResponse(struct soap *soap, const char *tag, _ns1__GetJxDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetJxDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetJxDataResponse, sizeof(_ns1__GetJxDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetJxDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetJxDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetJxDataResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetJxDataResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetJxDataResult", (char**)&a->_ns1__GetJxDataResponse::GetJxDataResult, "xsd:string"))
				{	soap_flag_GetJxDataResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetJxDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetJxDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetJxDataResponse, SOAP_TYPE__ns1__GetJxDataResponse, sizeof(_ns1__GetJxDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetJxDataResponse * SOAP_FMAC2 soap_instantiate__ns1__GetJxDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetJxDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetJxDataResponse *p;
	size_t k = sizeof(_ns1__GetJxDataResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetJxDataResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetJxDataResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetJxDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetJxDataResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetJxDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetJxDataResponse(soap, tag ? tag : "ns1:GetJxDataResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetJxDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetJxDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetJxDataResponse * SOAP_FMAC4 soap_get__ns1__GetJxDataResponse(struct soap *soap, _ns1__GetJxDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetJxDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetJxData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetJxData::dwname);
	soap_default_string(soap, &this->_ns1__GetJxData::xb);
	soap_default_string(soap, &this->_ns1__GetJxData::station);
	soap_default_string(soap, &this->_ns1__GetJxData::iconname);
	soap_default_string(soap, &this->_ns1__GetJxData::type);
	soap_default_string(soap, &this->_ns1__GetJxData::filename);
	/* transient soap skipped */
}

void _ns1__GetJxData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetJxData::dwname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetJxData::xb);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetJxData::station);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetJxData::iconname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetJxData::type);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetJxData::filename);
#endif
}

int _ns1__GetJxData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetJxData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetJxData(struct soap *soap, const char *tag, int id, const _ns1__GetJxData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetJxData), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__GetJxData::dwname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:xb", -1, (char*const*)&a->_ns1__GetJxData::xb, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:station", -1, (char*const*)&a->_ns1__GetJxData::station, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:iconname", -1, (char*const*)&a->_ns1__GetJxData::iconname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:type", -1, (char*const*)&a->_ns1__GetJxData::type, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, (char*const*)&a->_ns1__GetJxData::filename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetJxData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetJxData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetJxData * SOAP_FMAC4 soap_in__ns1__GetJxData(struct soap *soap, const char *tag, _ns1__GetJxData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetJxData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetJxData, sizeof(_ns1__GetJxData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetJxData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetJxData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dwname1 = 1;
	size_t soap_flag_xb1 = 1;
	size_t soap_flag_station1 = 1;
	size_t soap_flag_iconname1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_filename1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__GetJxData::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap_flag_xb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:xb", (char**)&a->_ns1__GetJxData::xb, "xsd:string"))
				{	soap_flag_xb1--;
					continue;
				}
			}
			if (soap_flag_station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:station", (char**)&a->_ns1__GetJxData::station, "xsd:string"))
				{	soap_flag_station1--;
					continue;
				}
			}
			if (soap_flag_iconname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:iconname", (char**)&a->_ns1__GetJxData::iconname, "xsd:string"))
				{	soap_flag_iconname1--;
					continue;
				}
			}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:type", (char**)&a->_ns1__GetJxData::type, "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			}
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:filename", (char**)&a->_ns1__GetJxData::filename, "xsd:string"))
				{	soap_flag_filename1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetJxData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetJxData, SOAP_TYPE__ns1__GetJxData, sizeof(_ns1__GetJxData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetJxData * SOAP_FMAC2 soap_instantiate__ns1__GetJxData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetJxData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetJxData *p;
	size_t k = sizeof(_ns1__GetJxData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetJxData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetJxData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetJxData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetJxData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetJxData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetJxData(soap, tag ? tag : "ns1:GetJxData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetJxData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetJxData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetJxData * SOAP_FMAC4 soap_get__ns1__GetJxData(struct soap *soap, _ns1__GetJxData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetJxData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetDeviceXjResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetDeviceXjResponse::GetDeviceXjResult);
	/* transient soap skipped */
}

void _ns1__GetDeviceXjResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDeviceXjResponse::GetDeviceXjResult);
#endif
}

int _ns1__GetDeviceXjResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDeviceXjResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDeviceXjResponse(struct soap *soap, const char *tag, int id, const _ns1__GetDeviceXjResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDeviceXjResponse), type))
		return soap->error;
	if (a->GetDeviceXjResult)
		soap_element_result(soap, "ns1:GetDeviceXjResult");
	if (soap_out_string(soap, "ns1:GetDeviceXjResult", -1, (char*const*)&a->_ns1__GetDeviceXjResponse::GetDeviceXjResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDeviceXjResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDeviceXjResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDeviceXjResponse * SOAP_FMAC4 soap_in__ns1__GetDeviceXjResponse(struct soap *soap, const char *tag, _ns1__GetDeviceXjResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDeviceXjResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDeviceXjResponse, sizeof(_ns1__GetDeviceXjResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetDeviceXjResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetDeviceXjResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetDeviceXjResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetDeviceXjResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetDeviceXjResult", (char**)&a->_ns1__GetDeviceXjResponse::GetDeviceXjResult, "xsd:string"))
				{	soap_flag_GetDeviceXjResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetDeviceXjResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDeviceXjResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDeviceXjResponse, SOAP_TYPE__ns1__GetDeviceXjResponse, sizeof(_ns1__GetDeviceXjResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetDeviceXjResponse * SOAP_FMAC2 soap_instantiate__ns1__GetDeviceXjResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDeviceXjResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetDeviceXjResponse *p;
	size_t k = sizeof(_ns1__GetDeviceXjResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetDeviceXjResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetDeviceXjResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetDeviceXjResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetDeviceXjResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetDeviceXjResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetDeviceXjResponse(soap, tag ? tag : "ns1:GetDeviceXjResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDeviceXjResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDeviceXjResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDeviceXjResponse * SOAP_FMAC4 soap_get__ns1__GetDeviceXjResponse(struct soap *soap, _ns1__GetDeviceXjResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDeviceXjResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetDeviceXj::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetDeviceXj::station);
	soap_default_string(soap, &this->_ns1__GetDeviceXj::xb);
	soap_default_string(soap, &this->_ns1__GetDeviceXj::dwname);
	soap_default_string(soap, &this->_ns1__GetDeviceXj::device);
	soap_default_string(soap, &this->_ns1__GetDeviceXj::filename);
	/* transient soap skipped */
}

void _ns1__GetDeviceXj::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDeviceXj::station);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDeviceXj::xb);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDeviceXj::dwname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDeviceXj::device);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDeviceXj::filename);
#endif
}

int _ns1__GetDeviceXj::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDeviceXj(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDeviceXj(struct soap *soap, const char *tag, int id, const _ns1__GetDeviceXj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDeviceXj), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:station", -1, (char*const*)&a->_ns1__GetDeviceXj::station, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:xb", -1, (char*const*)&a->_ns1__GetDeviceXj::xb, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__GetDeviceXj::dwname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:device", -1, (char*const*)&a->_ns1__GetDeviceXj::device, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, (char*const*)&a->_ns1__GetDeviceXj::filename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDeviceXj::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDeviceXj(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDeviceXj * SOAP_FMAC4 soap_in__ns1__GetDeviceXj(struct soap *soap, const char *tag, _ns1__GetDeviceXj *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDeviceXj *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDeviceXj, sizeof(_ns1__GetDeviceXj), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetDeviceXj)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetDeviceXj *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_station1 = 1;
	size_t soap_flag_xb1 = 1;
	size_t soap_flag_dwname1 = 1;
	size_t soap_flag_device1 = 1;
	size_t soap_flag_filename1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:station", (char**)&a->_ns1__GetDeviceXj::station, "xsd:string"))
				{	soap_flag_station1--;
					continue;
				}
			}
			if (soap_flag_xb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:xb", (char**)&a->_ns1__GetDeviceXj::xb, "xsd:string"))
				{	soap_flag_xb1--;
					continue;
				}
			}
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__GetDeviceXj::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap_flag_device1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:device", (char**)&a->_ns1__GetDeviceXj::device, "xsd:string"))
				{	soap_flag_device1--;
					continue;
				}
			}
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:filename", (char**)&a->_ns1__GetDeviceXj::filename, "xsd:string"))
				{	soap_flag_filename1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDeviceXj *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDeviceXj, SOAP_TYPE__ns1__GetDeviceXj, sizeof(_ns1__GetDeviceXj), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetDeviceXj * SOAP_FMAC2 soap_instantiate__ns1__GetDeviceXj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDeviceXj(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetDeviceXj *p;
	size_t k = sizeof(_ns1__GetDeviceXj);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetDeviceXj, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetDeviceXj);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetDeviceXj, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetDeviceXj location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetDeviceXj::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetDeviceXj(soap, tag ? tag : "ns1:GetDeviceXj", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDeviceXj::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDeviceXj(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDeviceXj * SOAP_FMAC4 soap_get__ns1__GetDeviceXj(struct soap *soap, _ns1__GetDeviceXj *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDeviceXj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetDwPicResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetDwPicResponse::GetDwPicResult);
	/* transient soap skipped */
}

void _ns1__GetDwPicResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDwPicResponse::GetDwPicResult);
#endif
}

int _ns1__GetDwPicResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDwPicResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDwPicResponse(struct soap *soap, const char *tag, int id, const _ns1__GetDwPicResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDwPicResponse), type))
		return soap->error;
	if (a->GetDwPicResult)
		soap_element_result(soap, "ns1:GetDwPicResult");
	if (soap_out_string(soap, "ns1:GetDwPicResult", -1, (char*const*)&a->_ns1__GetDwPicResponse::GetDwPicResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDwPicResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDwPicResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDwPicResponse * SOAP_FMAC4 soap_in__ns1__GetDwPicResponse(struct soap *soap, const char *tag, _ns1__GetDwPicResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDwPicResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDwPicResponse, sizeof(_ns1__GetDwPicResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetDwPicResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetDwPicResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetDwPicResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetDwPicResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetDwPicResult", (char**)&a->_ns1__GetDwPicResponse::GetDwPicResult, "xsd:string"))
				{	soap_flag_GetDwPicResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetDwPicResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDwPicResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDwPicResponse, SOAP_TYPE__ns1__GetDwPicResponse, sizeof(_ns1__GetDwPicResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetDwPicResponse * SOAP_FMAC2 soap_instantiate__ns1__GetDwPicResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDwPicResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetDwPicResponse *p;
	size_t k = sizeof(_ns1__GetDwPicResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetDwPicResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetDwPicResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetDwPicResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetDwPicResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetDwPicResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetDwPicResponse(soap, tag ? tag : "ns1:GetDwPicResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDwPicResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDwPicResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDwPicResponse * SOAP_FMAC4 soap_get__ns1__GetDwPicResponse(struct soap *soap, _ns1__GetDwPicResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDwPicResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetDwPic::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetDwPic::dwname);
	soap_default_string(soap, &this->_ns1__GetDwPic::unitname);
	soap_default_int(soap, &this->_ns1__GetDwPic::unitid);
	/* transient soap skipped */
}

void _ns1__GetDwPic::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDwPic::dwname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDwPic::unitname);
#endif
}

int _ns1__GetDwPic::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDwPic(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDwPic(struct soap *soap, const char *tag, int id, const _ns1__GetDwPic *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDwPic), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__GetDwPic::dwname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:unitname", -1, (char*const*)&a->_ns1__GetDwPic::unitname, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:unitid", -1, &a->_ns1__GetDwPic::unitid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDwPic::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDwPic(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDwPic * SOAP_FMAC4 soap_in__ns1__GetDwPic(struct soap *soap, const char *tag, _ns1__GetDwPic *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDwPic *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDwPic, sizeof(_ns1__GetDwPic), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetDwPic)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetDwPic *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dwname1 = 1;
	size_t soap_flag_unitname1 = 1;
	size_t soap_flag_unitid1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__GetDwPic::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap_flag_unitname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:unitname", (char**)&a->_ns1__GetDwPic::unitname, "xsd:string"))
				{	soap_flag_unitname1--;
					continue;
				}
			}
			if (soap_flag_unitid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:unitid", &a->_ns1__GetDwPic::unitid, "xsd:int"))
				{	soap_flag_unitid1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_unitid1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetDwPic *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDwPic, SOAP_TYPE__ns1__GetDwPic, sizeof(_ns1__GetDwPic), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetDwPic * SOAP_FMAC2 soap_instantiate__ns1__GetDwPic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDwPic(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetDwPic *p;
	size_t k = sizeof(_ns1__GetDwPic);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetDwPic, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetDwPic);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetDwPic, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetDwPic location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetDwPic::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetDwPic(soap, tag ? tag : "ns1:GetDwPic", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDwPic::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDwPic(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDwPic * SOAP_FMAC4 soap_get__ns1__GetDwPic(struct soap *soap, _ns1__GetDwPic *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDwPic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetDwInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetDwInfoResponse::GetDwInfoResult);
	/* transient soap skipped */
}

void _ns1__GetDwInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDwInfoResponse::GetDwInfoResult);
#endif
}

int _ns1__GetDwInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDwInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDwInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetDwInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDwInfoResponse), type))
		return soap->error;
	if (a->GetDwInfoResult)
		soap_element_result(soap, "ns1:GetDwInfoResult");
	if (soap_out_string(soap, "ns1:GetDwInfoResult", -1, (char*const*)&a->_ns1__GetDwInfoResponse::GetDwInfoResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDwInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDwInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDwInfoResponse * SOAP_FMAC4 soap_in__ns1__GetDwInfoResponse(struct soap *soap, const char *tag, _ns1__GetDwInfoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDwInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDwInfoResponse, sizeof(_ns1__GetDwInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetDwInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetDwInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetDwInfoResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetDwInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetDwInfoResult", (char**)&a->_ns1__GetDwInfoResponse::GetDwInfoResult, "xsd:string"))
				{	soap_flag_GetDwInfoResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetDwInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDwInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDwInfoResponse, SOAP_TYPE__ns1__GetDwInfoResponse, sizeof(_ns1__GetDwInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetDwInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__GetDwInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDwInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetDwInfoResponse *p;
	size_t k = sizeof(_ns1__GetDwInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetDwInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetDwInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetDwInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetDwInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetDwInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetDwInfoResponse(soap, tag ? tag : "ns1:GetDwInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDwInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDwInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDwInfoResponse * SOAP_FMAC4 soap_get__ns1__GetDwInfoResponse(struct soap *soap, _ns1__GetDwInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDwInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetDwInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetDwInfo::dwname);
	soap_default_string(soap, &this->_ns1__GetDwInfo::unitname);
	soap_default_int(soap, &this->_ns1__GetDwInfo::unitid);
	/* transient soap skipped */
}

void _ns1__GetDwInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDwInfo::dwname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDwInfo::unitname);
#endif
}

int _ns1__GetDwInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDwInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDwInfo(struct soap *soap, const char *tag, int id, const _ns1__GetDwInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDwInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__GetDwInfo::dwname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:unitname", -1, (char*const*)&a->_ns1__GetDwInfo::unitname, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:unitid", -1, &a->_ns1__GetDwInfo::unitid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDwInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDwInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDwInfo * SOAP_FMAC4 soap_in__ns1__GetDwInfo(struct soap *soap, const char *tag, _ns1__GetDwInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDwInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDwInfo, sizeof(_ns1__GetDwInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetDwInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetDwInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dwname1 = 1;
	size_t soap_flag_unitname1 = 1;
	size_t soap_flag_unitid1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__GetDwInfo::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap_flag_unitname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:unitname", (char**)&a->_ns1__GetDwInfo::unitname, "xsd:string"))
				{	soap_flag_unitname1--;
					continue;
				}
			}
			if (soap_flag_unitid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:unitid", &a->_ns1__GetDwInfo::unitid, "xsd:int"))
				{	soap_flag_unitid1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_unitid1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetDwInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDwInfo, SOAP_TYPE__ns1__GetDwInfo, sizeof(_ns1__GetDwInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetDwInfo * SOAP_FMAC2 soap_instantiate__ns1__GetDwInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDwInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetDwInfo *p;
	size_t k = sizeof(_ns1__GetDwInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetDwInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetDwInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetDwInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetDwInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetDwInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetDwInfo(soap, tag ? tag : "ns1:GetDwInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDwInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDwInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDwInfo * SOAP_FMAC4 soap_get__ns1__GetDwInfo(struct soap *soap, _ns1__GetDwInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDwInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetPicNamesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetPicNamesResponse::GetPicNamesResult);
	/* transient soap skipped */
}

void _ns1__GetPicNamesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetPicNamesResponse::GetPicNamesResult);
#endif
}

int _ns1__GetPicNamesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPicNamesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPicNamesResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPicNamesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPicNamesResponse), type))
		return soap->error;
	if (a->GetPicNamesResult)
		soap_element_result(soap, "ns1:GetPicNamesResult");
	if (soap_out_string(soap, "ns1:GetPicNamesResult", -1, (char*const*)&a->_ns1__GetPicNamesResponse::GetPicNamesResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPicNamesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPicNamesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPicNamesResponse * SOAP_FMAC4 soap_in__ns1__GetPicNamesResponse(struct soap *soap, const char *tag, _ns1__GetPicNamesResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPicNamesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPicNamesResponse, sizeof(_ns1__GetPicNamesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetPicNamesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetPicNamesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetPicNamesResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPicNamesResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetPicNamesResult", (char**)&a->_ns1__GetPicNamesResponse::GetPicNamesResult, "xsd:string"))
				{	soap_flag_GetPicNamesResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetPicNamesResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPicNamesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPicNamesResponse, SOAP_TYPE__ns1__GetPicNamesResponse, sizeof(_ns1__GetPicNamesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetPicNamesResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPicNamesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPicNamesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetPicNamesResponse *p;
	size_t k = sizeof(_ns1__GetPicNamesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetPicNamesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetPicNamesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetPicNamesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetPicNamesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetPicNamesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetPicNamesResponse(soap, tag ? tag : "ns1:GetPicNamesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPicNamesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPicNamesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPicNamesResponse * SOAP_FMAC4 soap_get__ns1__GetPicNamesResponse(struct soap *soap, _ns1__GetPicNamesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPicNamesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetPicNames::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetPicNames::xb);
	soap_default_string(soap, &this->_ns1__GetPicNames::station);
	/* transient soap skipped */
}

void _ns1__GetPicNames::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetPicNames::xb);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetPicNames::station);
#endif
}

int _ns1__GetPicNames::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPicNames(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPicNames(struct soap *soap, const char *tag, int id, const _ns1__GetPicNames *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPicNames), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xb", -1, (char*const*)&a->_ns1__GetPicNames::xb, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:station", -1, (char*const*)&a->_ns1__GetPicNames::station, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPicNames::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPicNames(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPicNames * SOAP_FMAC4 soap_in__ns1__GetPicNames(struct soap *soap, const char *tag, _ns1__GetPicNames *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPicNames *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPicNames, sizeof(_ns1__GetPicNames), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetPicNames)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetPicNames *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_xb1 = 1;
	size_t soap_flag_station1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:xb", (char**)&a->_ns1__GetPicNames::xb, "xsd:string"))
				{	soap_flag_xb1--;
					continue;
				}
			}
			if (soap_flag_station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:station", (char**)&a->_ns1__GetPicNames::station, "xsd:string"))
				{	soap_flag_station1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPicNames *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPicNames, SOAP_TYPE__ns1__GetPicNames, sizeof(_ns1__GetPicNames), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetPicNames * SOAP_FMAC2 soap_instantiate__ns1__GetPicNames(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPicNames(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetPicNames *p;
	size_t k = sizeof(_ns1__GetPicNames);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetPicNames, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetPicNames);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetPicNames, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetPicNames location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetPicNames::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetPicNames(soap, tag ? tag : "ns1:GetPicNames", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPicNames::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPicNames(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPicNames * SOAP_FMAC4 soap_get__ns1__GetPicNames(struct soap *soap, _ns1__GetPicNames *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPicNames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DownloadPicResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__DownloadPicResponse::DownloadPicResult);
	/* transient soap skipped */
}

void _ns1__DownloadPicResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__DownloadPicResponse::DownloadPicResult);
#endif
}

int _ns1__DownloadPicResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DownloadPicResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DownloadPicResponse(struct soap *soap, const char *tag, int id, const _ns1__DownloadPicResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DownloadPicResponse), type))
		return soap->error;
	if (a->DownloadPicResult)
		soap_element_result(soap, "ns1:DownloadPicResult");
	if (soap_out_string(soap, "ns1:DownloadPicResult", -1, (char*const*)&a->_ns1__DownloadPicResponse::DownloadPicResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DownloadPicResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DownloadPicResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DownloadPicResponse * SOAP_FMAC4 soap_in__ns1__DownloadPicResponse(struct soap *soap, const char *tag, _ns1__DownloadPicResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DownloadPicResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DownloadPicResponse, sizeof(_ns1__DownloadPicResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__DownloadPicResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__DownloadPicResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DownloadPicResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DownloadPicResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:DownloadPicResult", (char**)&a->_ns1__DownloadPicResponse::DownloadPicResult, "xsd:string"))
				{	soap_flag_DownloadPicResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:DownloadPicResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DownloadPicResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DownloadPicResponse, SOAP_TYPE__ns1__DownloadPicResponse, sizeof(_ns1__DownloadPicResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DownloadPicResponse * SOAP_FMAC2 soap_instantiate__ns1__DownloadPicResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DownloadPicResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DownloadPicResponse *p;
	size_t k = sizeof(_ns1__DownloadPicResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__DownloadPicResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__DownloadPicResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__DownloadPicResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DownloadPicResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__DownloadPicResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__DownloadPicResponse(soap, tag ? tag : "ns1:DownloadPicResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DownloadPicResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DownloadPicResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DownloadPicResponse * SOAP_FMAC4 soap_get__ns1__DownloadPicResponse(struct soap *soap, _ns1__DownloadPicResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DownloadPicResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DownloadPic::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__DownloadPic::picname);
	soap_default_string(soap, &this->_ns1__DownloadPic::dwname);
	/* transient soap skipped */
}

void _ns1__DownloadPic::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__DownloadPic::picname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__DownloadPic::dwname);
#endif
}

int _ns1__DownloadPic::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DownloadPic(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DownloadPic(struct soap *soap, const char *tag, int id, const _ns1__DownloadPic *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DownloadPic), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:picname", -1, (char*const*)&a->_ns1__DownloadPic::picname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__DownloadPic::dwname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DownloadPic::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DownloadPic(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DownloadPic * SOAP_FMAC4 soap_in__ns1__DownloadPic(struct soap *soap, const char *tag, _ns1__DownloadPic *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DownloadPic *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DownloadPic, sizeof(_ns1__DownloadPic), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__DownloadPic)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__DownloadPic *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_picname1 = 1;
	size_t soap_flag_dwname1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_picname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:picname", (char**)&a->_ns1__DownloadPic::picname, "xsd:string"))
				{	soap_flag_picname1--;
					continue;
				}
			}
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__DownloadPic::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DownloadPic *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DownloadPic, SOAP_TYPE__ns1__DownloadPic, sizeof(_ns1__DownloadPic), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DownloadPic * SOAP_FMAC2 soap_instantiate__ns1__DownloadPic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DownloadPic(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DownloadPic *p;
	size_t k = sizeof(_ns1__DownloadPic);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__DownloadPic, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__DownloadPic);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__DownloadPic, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DownloadPic location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__DownloadPic::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__DownloadPic(soap, tag ? tag : "ns1:DownloadPic", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DownloadPic::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DownloadPic(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DownloadPic * SOAP_FMAC4 soap_get__ns1__DownloadPic(struct soap *soap, _ns1__DownloadPic *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DownloadPic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__upPicResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__upPicResponse::upPicResult);
	/* transient soap skipped */
}

void _ns1__upPicResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__upPicResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__upPicResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__upPicResponse(struct soap *soap, const char *tag, int id, const _ns1__upPicResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__upPicResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:upPicResult");
	if (soap_out_int(soap, "ns1:upPicResult", -1, &a->_ns1__upPicResponse::upPicResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__upPicResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__upPicResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__upPicResponse * SOAP_FMAC4 soap_in__ns1__upPicResponse(struct soap *soap, const char *tag, _ns1__upPicResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__upPicResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__upPicResponse, sizeof(_ns1__upPicResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__upPicResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__upPicResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_upPicResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_upPicResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:upPicResult", &a->_ns1__upPicResponse::upPicResult, "xsd:int"))
				{	soap_flag_upPicResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:upPicResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_upPicResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__upPicResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__upPicResponse, SOAP_TYPE__ns1__upPicResponse, sizeof(_ns1__upPicResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__upPicResponse * SOAP_FMAC2 soap_instantiate__ns1__upPicResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__upPicResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__upPicResponse *p;
	size_t k = sizeof(_ns1__upPicResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__upPicResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__upPicResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__upPicResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__upPicResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__upPicResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__upPicResponse(soap, tag ? tag : "ns1:upPicResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__upPicResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__upPicResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__upPicResponse * SOAP_FMAC4 soap_get__ns1__upPicResponse(struct soap *soap, _ns1__upPicResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__upPicResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__upPic::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__upPic::personid);
	soap_default_string(soap, &this->_ns1__upPic::personname);
	soap_default_string(soap, &this->_ns1__upPic::xb);
	soap_default_string(soap, &this->_ns1__upPic::station);
	soap_default_string(soap, &this->_ns1__upPic::picname);
	soap_default_string(soap, &this->_ns1__upPic::picstr);
	soap_default_string(soap, &this->_ns1__upPic::dwname);
	/* transient soap skipped */
}

void _ns1__upPic::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__upPic::personid);
	soap_serialize_string(soap, (char*const*)&this->_ns1__upPic::personname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__upPic::xb);
	soap_serialize_string(soap, (char*const*)&this->_ns1__upPic::station);
	soap_serialize_string(soap, (char*const*)&this->_ns1__upPic::picname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__upPic::picstr);
	soap_serialize_string(soap, (char*const*)&this->_ns1__upPic::dwname);
#endif
}

int _ns1__upPic::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__upPic(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__upPic(struct soap *soap, const char *tag, int id, const _ns1__upPic *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__upPic), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:personid", -1, (char*const*)&a->_ns1__upPic::personid, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:personname", -1, (char*const*)&a->_ns1__upPic::personname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:xb", -1, (char*const*)&a->_ns1__upPic::xb, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:station", -1, (char*const*)&a->_ns1__upPic::station, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:picname", -1, (char*const*)&a->_ns1__upPic::picname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:picstr", -1, (char*const*)&a->_ns1__upPic::picstr, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__upPic::dwname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__upPic::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__upPic(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__upPic * SOAP_FMAC4 soap_in__ns1__upPic(struct soap *soap, const char *tag, _ns1__upPic *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__upPic *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__upPic, sizeof(_ns1__upPic), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__upPic)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__upPic *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_personid1 = 1;
	size_t soap_flag_personname1 = 1;
	size_t soap_flag_xb1 = 1;
	size_t soap_flag_station1 = 1;
	size_t soap_flag_picname1 = 1;
	size_t soap_flag_picstr1 = 1;
	size_t soap_flag_dwname1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_personid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:personid", (char**)&a->_ns1__upPic::personid, "xsd:string"))
				{	soap_flag_personid1--;
					continue;
				}
			}
			if (soap_flag_personname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:personname", (char**)&a->_ns1__upPic::personname, "xsd:string"))
				{	soap_flag_personname1--;
					continue;
				}
			}
			if (soap_flag_xb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:xb", (char**)&a->_ns1__upPic::xb, "xsd:string"))
				{	soap_flag_xb1--;
					continue;
				}
			}
			if (soap_flag_station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:station", (char**)&a->_ns1__upPic::station, "xsd:string"))
				{	soap_flag_station1--;
					continue;
				}
			}
			if (soap_flag_picname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:picname", (char**)&a->_ns1__upPic::picname, "xsd:string"))
				{	soap_flag_picname1--;
					continue;
				}
			}
			if (soap_flag_picstr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:picstr", (char**)&a->_ns1__upPic::picstr, "xsd:string"))
				{	soap_flag_picstr1--;
					continue;
				}
			}
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__upPic::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__upPic *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__upPic, SOAP_TYPE__ns1__upPic, sizeof(_ns1__upPic), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__upPic * SOAP_FMAC2 soap_instantiate__ns1__upPic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__upPic(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__upPic *p;
	size_t k = sizeof(_ns1__upPic);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__upPic, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__upPic);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__upPic, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__upPic location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__upPic::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__upPic(soap, tag ? tag : "ns1:upPic", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__upPic::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__upPic(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__upPic * SOAP_FMAC4 soap_get__ns1__upPic(struct soap *soap, _ns1__upPic *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__upPic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UpLoadFileResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__UpLoadFileResponse::UpLoadFileResult);
	/* transient soap skipped */
}

void _ns1__UpLoadFileResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__UpLoadFileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpLoadFileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpLoadFileResponse(struct soap *soap, const char *tag, int id, const _ns1__UpLoadFileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpLoadFileResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:UpLoadFileResult");
	if (soap_out_int(soap, "ns1:UpLoadFileResult", -1, &a->_ns1__UpLoadFileResponse::UpLoadFileResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpLoadFileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpLoadFileResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpLoadFileResponse * SOAP_FMAC4 soap_in__ns1__UpLoadFileResponse(struct soap *soap, const char *tag, _ns1__UpLoadFileResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpLoadFileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpLoadFileResponse, sizeof(_ns1__UpLoadFileResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__UpLoadFileResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__UpLoadFileResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UpLoadFileResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpLoadFileResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:UpLoadFileResult", &a->_ns1__UpLoadFileResponse::UpLoadFileResult, "xsd:int"))
				{	soap_flag_UpLoadFileResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:UpLoadFileResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UpLoadFileResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__UpLoadFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpLoadFileResponse, SOAP_TYPE__ns1__UpLoadFileResponse, sizeof(_ns1__UpLoadFileResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UpLoadFileResponse * SOAP_FMAC2 soap_instantiate__ns1__UpLoadFileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpLoadFileResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UpLoadFileResponse *p;
	size_t k = sizeof(_ns1__UpLoadFileResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__UpLoadFileResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__UpLoadFileResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__UpLoadFileResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UpLoadFileResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__UpLoadFileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__UpLoadFileResponse(soap, tag ? tag : "ns1:UpLoadFileResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpLoadFileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpLoadFileResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpLoadFileResponse * SOAP_FMAC4 soap_get__ns1__UpLoadFileResponse(struct soap *soap, _ns1__UpLoadFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpLoadFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UpLoadFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpLoadFile::filename);
	soap_default_int(soap, &this->_ns1__UpLoadFile::index);
	soap_default_string(soap, &this->_ns1__UpLoadFile::fstr);
	soap_default_string(soap, &this->_ns1__UpLoadFile::dwname);
	/* transient soap skipped */
}

void _ns1__UpLoadFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__UpLoadFile::filename);
	soap_serialize_string(soap, (char*const*)&this->_ns1__UpLoadFile::fstr);
	soap_serialize_string(soap, (char*const*)&this->_ns1__UpLoadFile::dwname);
#endif
}

int _ns1__UpLoadFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpLoadFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpLoadFile(struct soap *soap, const char *tag, int id, const _ns1__UpLoadFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpLoadFile), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, (char*const*)&a->_ns1__UpLoadFile::filename, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:index", -1, &a->_ns1__UpLoadFile::index, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:fstr", -1, (char*const*)&a->_ns1__UpLoadFile::fstr, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__UpLoadFile::dwname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpLoadFile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpLoadFile(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpLoadFile * SOAP_FMAC4 soap_in__ns1__UpLoadFile(struct soap *soap, const char *tag, _ns1__UpLoadFile *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpLoadFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpLoadFile, sizeof(_ns1__UpLoadFile), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__UpLoadFile)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__UpLoadFile *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_filename1 = 1;
	size_t soap_flag_index1 = 1;
	size_t soap_flag_fstr1 = 1;
	size_t soap_flag_dwname1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:filename", (char**)&a->_ns1__UpLoadFile::filename, "xsd:string"))
				{	soap_flag_filename1--;
					continue;
				}
			}
			if (soap_flag_index1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:index", &a->_ns1__UpLoadFile::index, "xsd:int"))
				{	soap_flag_index1--;
					continue;
				}
			}
			if (soap_flag_fstr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:fstr", (char**)&a->_ns1__UpLoadFile::fstr, "xsd:string"))
				{	soap_flag_fstr1--;
					continue;
				}
			}
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__UpLoadFile::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_index1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__UpLoadFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpLoadFile, SOAP_TYPE__ns1__UpLoadFile, sizeof(_ns1__UpLoadFile), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UpLoadFile * SOAP_FMAC2 soap_instantiate__ns1__UpLoadFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpLoadFile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UpLoadFile *p;
	size_t k = sizeof(_ns1__UpLoadFile);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__UpLoadFile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__UpLoadFile);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__UpLoadFile, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UpLoadFile location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__UpLoadFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__UpLoadFile(soap, tag ? tag : "ns1:UpLoadFile", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpLoadFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpLoadFile(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpLoadFile * SOAP_FMAC4 soap_get__ns1__UpLoadFile(struct soap *soap, _ns1__UpLoadFile *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpLoadFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetAPVupdaterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetAPVupdaterResponse::GetAPVupdaterResult);
	/* transient soap skipped */
}

void _ns1__GetAPVupdaterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetAPVupdaterResponse::GetAPVupdaterResult);
#endif
}

int _ns1__GetAPVupdaterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAPVupdaterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAPVupdaterResponse(struct soap *soap, const char *tag, int id, const _ns1__GetAPVupdaterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAPVupdaterResponse), type))
		return soap->error;
	if (a->GetAPVupdaterResult)
		soap_element_result(soap, "ns1:GetAPVupdaterResult");
	if (soap_out_string(soap, "ns1:GetAPVupdaterResult", -1, (char*const*)&a->_ns1__GetAPVupdaterResponse::GetAPVupdaterResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAPVupdaterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAPVupdaterResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAPVupdaterResponse * SOAP_FMAC4 soap_in__ns1__GetAPVupdaterResponse(struct soap *soap, const char *tag, _ns1__GetAPVupdaterResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAPVupdaterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAPVupdaterResponse, sizeof(_ns1__GetAPVupdaterResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetAPVupdaterResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetAPVupdaterResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetAPVupdaterResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetAPVupdaterResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetAPVupdaterResult", (char**)&a->_ns1__GetAPVupdaterResponse::GetAPVupdaterResult, "xsd:string"))
				{	soap_flag_GetAPVupdaterResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetAPVupdaterResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAPVupdaterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAPVupdaterResponse, SOAP_TYPE__ns1__GetAPVupdaterResponse, sizeof(_ns1__GetAPVupdaterResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetAPVupdaterResponse * SOAP_FMAC2 soap_instantiate__ns1__GetAPVupdaterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAPVupdaterResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetAPVupdaterResponse *p;
	size_t k = sizeof(_ns1__GetAPVupdaterResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetAPVupdaterResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetAPVupdaterResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetAPVupdaterResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetAPVupdaterResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetAPVupdaterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetAPVupdaterResponse(soap, tag ? tag : "ns1:GetAPVupdaterResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAPVupdaterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAPVupdaterResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAPVupdaterResponse * SOAP_FMAC4 soap_get__ns1__GetAPVupdaterResponse(struct soap *soap, _ns1__GetAPVupdaterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAPVupdaterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetAPVupdater::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetAPVupdater::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetAPVupdater::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAPVupdater(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAPVupdater(struct soap *soap, const char *tag, int id, const _ns1__GetAPVupdater *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAPVupdater), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAPVupdater::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAPVupdater(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAPVupdater * SOAP_FMAC4 soap_in__ns1__GetAPVupdater(struct soap *soap, const char *tag, _ns1__GetAPVupdater *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAPVupdater *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAPVupdater, sizeof(_ns1__GetAPVupdater), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetAPVupdater)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetAPVupdater *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAPVupdater *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAPVupdater, SOAP_TYPE__ns1__GetAPVupdater, sizeof(_ns1__GetAPVupdater), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetAPVupdater * SOAP_FMAC2 soap_instantiate__ns1__GetAPVupdater(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAPVupdater(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetAPVupdater *p;
	size_t k = sizeof(_ns1__GetAPVupdater);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetAPVupdater, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetAPVupdater);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetAPVupdater, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetAPVupdater location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetAPVupdater::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetAPVupdater(soap, tag ? tag : "ns1:GetAPVupdater", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAPVupdater::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAPVupdater(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAPVupdater * SOAP_FMAC4 soap_get__ns1__GetAPVupdater(struct soap *soap, _ns1__GetAPVupdater *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAPVupdater(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetXHYDGLXTupdaterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetXHYDGLXTupdaterResponse::GetXHYDGLXTupdaterResult);
	/* transient soap skipped */
}

void _ns1__GetXHYDGLXTupdaterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetXHYDGLXTupdaterResponse::GetXHYDGLXTupdaterResult);
#endif
}

int _ns1__GetXHYDGLXTupdaterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetXHYDGLXTupdaterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetXHYDGLXTupdaterResponse(struct soap *soap, const char *tag, int id, const _ns1__GetXHYDGLXTupdaterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetXHYDGLXTupdaterResponse), type))
		return soap->error;
	if (a->GetXHYDGLXTupdaterResult)
		soap_element_result(soap, "ns1:GetXHYDGLXTupdaterResult");
	if (soap_out_string(soap, "ns1:GetXHYDGLXTupdaterResult", -1, (char*const*)&a->_ns1__GetXHYDGLXTupdaterResponse::GetXHYDGLXTupdaterResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetXHYDGLXTupdaterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetXHYDGLXTupdaterResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetXHYDGLXTupdaterResponse * SOAP_FMAC4 soap_in__ns1__GetXHYDGLXTupdaterResponse(struct soap *soap, const char *tag, _ns1__GetXHYDGLXTupdaterResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetXHYDGLXTupdaterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetXHYDGLXTupdaterResponse, sizeof(_ns1__GetXHYDGLXTupdaterResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetXHYDGLXTupdaterResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetXHYDGLXTupdaterResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetXHYDGLXTupdaterResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetXHYDGLXTupdaterResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetXHYDGLXTupdaterResult", (char**)&a->_ns1__GetXHYDGLXTupdaterResponse::GetXHYDGLXTupdaterResult, "xsd:string"))
				{	soap_flag_GetXHYDGLXTupdaterResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetXHYDGLXTupdaterResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetXHYDGLXTupdaterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetXHYDGLXTupdaterResponse, SOAP_TYPE__ns1__GetXHYDGLXTupdaterResponse, sizeof(_ns1__GetXHYDGLXTupdaterResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetXHYDGLXTupdaterResponse * SOAP_FMAC2 soap_instantiate__ns1__GetXHYDGLXTupdaterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetXHYDGLXTupdaterResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetXHYDGLXTupdaterResponse *p;
	size_t k = sizeof(_ns1__GetXHYDGLXTupdaterResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetXHYDGLXTupdaterResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetXHYDGLXTupdaterResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetXHYDGLXTupdaterResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetXHYDGLXTupdaterResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetXHYDGLXTupdaterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetXHYDGLXTupdaterResponse(soap, tag ? tag : "ns1:GetXHYDGLXTupdaterResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetXHYDGLXTupdaterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetXHYDGLXTupdaterResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetXHYDGLXTupdaterResponse * SOAP_FMAC4 soap_get__ns1__GetXHYDGLXTupdaterResponse(struct soap *soap, _ns1__GetXHYDGLXTupdaterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetXHYDGLXTupdaterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetXHYDGLXTupdater::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetXHYDGLXTupdater::localver);
	/* transient soap skipped */
}

void _ns1__GetXHYDGLXTupdater::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetXHYDGLXTupdater::localver);
#endif
}

int _ns1__GetXHYDGLXTupdater::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetXHYDGLXTupdater(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetXHYDGLXTupdater(struct soap *soap, const char *tag, int id, const _ns1__GetXHYDGLXTupdater *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetXHYDGLXTupdater), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:localver", -1, (char*const*)&a->_ns1__GetXHYDGLXTupdater::localver, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetXHYDGLXTupdater::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetXHYDGLXTupdater(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetXHYDGLXTupdater * SOAP_FMAC4 soap_in__ns1__GetXHYDGLXTupdater(struct soap *soap, const char *tag, _ns1__GetXHYDGLXTupdater *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetXHYDGLXTupdater *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetXHYDGLXTupdater, sizeof(_ns1__GetXHYDGLXTupdater), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetXHYDGLXTupdater)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetXHYDGLXTupdater *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_localver1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_localver1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:localver", (char**)&a->_ns1__GetXHYDGLXTupdater::localver, "xsd:string"))
				{	soap_flag_localver1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetXHYDGLXTupdater *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetXHYDGLXTupdater, SOAP_TYPE__ns1__GetXHYDGLXTupdater, sizeof(_ns1__GetXHYDGLXTupdater), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetXHYDGLXTupdater * SOAP_FMAC2 soap_instantiate__ns1__GetXHYDGLXTupdater(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetXHYDGLXTupdater(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetXHYDGLXTupdater *p;
	size_t k = sizeof(_ns1__GetXHYDGLXTupdater);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetXHYDGLXTupdater, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetXHYDGLXTupdater);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetXHYDGLXTupdater, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetXHYDGLXTupdater location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetXHYDGLXTupdater::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetXHYDGLXTupdater(soap, tag ? tag : "ns1:GetXHYDGLXTupdater", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetXHYDGLXTupdater::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetXHYDGLXTupdater(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetXHYDGLXTupdater * SOAP_FMAC4 soap_get__ns1__GetXHYDGLXTupdater(struct soap *soap, _ns1__GetXHYDGLXTupdater *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetXHYDGLXTupdater(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ExecuteSqlForColbResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__ExecuteSqlForColbResponse::ExecuteSqlForColbResult);
	/* transient soap skipped */
}

void _ns1__ExecuteSqlForColbResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__ExecuteSqlForColbResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ExecuteSqlForColbResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ExecuteSqlForColbResponse(struct soap *soap, const char *tag, int id, const _ns1__ExecuteSqlForColbResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ExecuteSqlForColbResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:ExecuteSqlForColbResult");
	if (soap_out_int(soap, "ns1:ExecuteSqlForColbResult", -1, &a->_ns1__ExecuteSqlForColbResponse::ExecuteSqlForColbResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ExecuteSqlForColbResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ExecuteSqlForColbResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ExecuteSqlForColbResponse * SOAP_FMAC4 soap_in__ns1__ExecuteSqlForColbResponse(struct soap *soap, const char *tag, _ns1__ExecuteSqlForColbResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ExecuteSqlForColbResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ExecuteSqlForColbResponse, sizeof(_ns1__ExecuteSqlForColbResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ExecuteSqlForColbResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ExecuteSqlForColbResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ExecuteSqlForColbResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ExecuteSqlForColbResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:ExecuteSqlForColbResult", &a->_ns1__ExecuteSqlForColbResponse::ExecuteSqlForColbResult, "xsd:int"))
				{	soap_flag_ExecuteSqlForColbResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:ExecuteSqlForColbResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ExecuteSqlForColbResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__ExecuteSqlForColbResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ExecuteSqlForColbResponse, SOAP_TYPE__ns1__ExecuteSqlForColbResponse, sizeof(_ns1__ExecuteSqlForColbResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ExecuteSqlForColbResponse * SOAP_FMAC2 soap_instantiate__ns1__ExecuteSqlForColbResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ExecuteSqlForColbResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ExecuteSqlForColbResponse *p;
	size_t k = sizeof(_ns1__ExecuteSqlForColbResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ExecuteSqlForColbResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ExecuteSqlForColbResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ExecuteSqlForColbResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ExecuteSqlForColbResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ExecuteSqlForColbResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ExecuteSqlForColbResponse(soap, tag ? tag : "ns1:ExecuteSqlForColbResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ExecuteSqlForColbResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ExecuteSqlForColbResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ExecuteSqlForColbResponse * SOAP_FMAC4 soap_get__ns1__ExecuteSqlForColbResponse(struct soap *soap, _ns1__ExecuteSqlForColbResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ExecuteSqlForColbResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ExecuteSqlForColb::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__ExecuteSqlForColb::sql);
	soap_default_string(soap, &this->_ns1__ExecuteSqlForColb::sqlParName);
	soap_default_string(soap, &this->_ns1__ExecuteSqlForColb::fieldValue);
	/* transient soap skipped */
}

void _ns1__ExecuteSqlForColb::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__ExecuteSqlForColb::sql);
	soap_serialize_string(soap, (char*const*)&this->_ns1__ExecuteSqlForColb::sqlParName);
	soap_serialize_string(soap, (char*const*)&this->_ns1__ExecuteSqlForColb::fieldValue);
#endif
}

int _ns1__ExecuteSqlForColb::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ExecuteSqlForColb(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ExecuteSqlForColb(struct soap *soap, const char *tag, int id, const _ns1__ExecuteSqlForColb *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ExecuteSqlForColb), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:sql", -1, (char*const*)&a->_ns1__ExecuteSqlForColb::sql, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:sqlParName", -1, (char*const*)&a->_ns1__ExecuteSqlForColb::sqlParName, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:fieldValue", -1, (char*const*)&a->_ns1__ExecuteSqlForColb::fieldValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ExecuteSqlForColb::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ExecuteSqlForColb(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ExecuteSqlForColb * SOAP_FMAC4 soap_in__ns1__ExecuteSqlForColb(struct soap *soap, const char *tag, _ns1__ExecuteSqlForColb *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ExecuteSqlForColb *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ExecuteSqlForColb, sizeof(_ns1__ExecuteSqlForColb), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ExecuteSqlForColb)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ExecuteSqlForColb *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sql1 = 1;
	size_t soap_flag_sqlParName1 = 1;
	size_t soap_flag_fieldValue1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sql1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:sql", (char**)&a->_ns1__ExecuteSqlForColb::sql, "xsd:string"))
				{	soap_flag_sql1--;
					continue;
				}
			}
			if (soap_flag_sqlParName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:sqlParName", (char**)&a->_ns1__ExecuteSqlForColb::sqlParName, "xsd:string"))
				{	soap_flag_sqlParName1--;
					continue;
				}
			}
			if (soap_flag_fieldValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:fieldValue", (char**)&a->_ns1__ExecuteSqlForColb::fieldValue, "xsd:string"))
				{	soap_flag_fieldValue1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ExecuteSqlForColb *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ExecuteSqlForColb, SOAP_TYPE__ns1__ExecuteSqlForColb, sizeof(_ns1__ExecuteSqlForColb), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ExecuteSqlForColb * SOAP_FMAC2 soap_instantiate__ns1__ExecuteSqlForColb(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ExecuteSqlForColb(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ExecuteSqlForColb *p;
	size_t k = sizeof(_ns1__ExecuteSqlForColb);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ExecuteSqlForColb, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ExecuteSqlForColb);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ExecuteSqlForColb, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ExecuteSqlForColb location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ExecuteSqlForColb::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ExecuteSqlForColb(soap, tag ? tag : "ns1:ExecuteSqlForColb", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ExecuteSqlForColb::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ExecuteSqlForColb(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ExecuteSqlForColb * SOAP_FMAC4 soap_get__ns1__ExecuteSqlForColb(struct soap *soap, _ns1__ExecuteSqlForColb *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ExecuteSqlForColb(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UpLoadDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpLoadDataResponse::UpLoadDataResult);
	/* transient soap skipped */
}

void _ns1__UpLoadDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__UpLoadDataResponse::UpLoadDataResult);
#endif
}

int _ns1__UpLoadDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpLoadDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpLoadDataResponse(struct soap *soap, const char *tag, int id, const _ns1__UpLoadDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpLoadDataResponse), type))
		return soap->error;
	if (a->UpLoadDataResult)
		soap_element_result(soap, "ns1:UpLoadDataResult");
	if (soap_out_string(soap, "ns1:UpLoadDataResult", -1, (char*const*)&a->_ns1__UpLoadDataResponse::UpLoadDataResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpLoadDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpLoadDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpLoadDataResponse * SOAP_FMAC4 soap_in__ns1__UpLoadDataResponse(struct soap *soap, const char *tag, _ns1__UpLoadDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpLoadDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpLoadDataResponse, sizeof(_ns1__UpLoadDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__UpLoadDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__UpLoadDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UpLoadDataResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpLoadDataResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:UpLoadDataResult", (char**)&a->_ns1__UpLoadDataResponse::UpLoadDataResult, "xsd:string"))
				{	soap_flag_UpLoadDataResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:UpLoadDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpLoadDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpLoadDataResponse, SOAP_TYPE__ns1__UpLoadDataResponse, sizeof(_ns1__UpLoadDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UpLoadDataResponse * SOAP_FMAC2 soap_instantiate__ns1__UpLoadDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpLoadDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UpLoadDataResponse *p;
	size_t k = sizeof(_ns1__UpLoadDataResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__UpLoadDataResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__UpLoadDataResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__UpLoadDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UpLoadDataResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__UpLoadDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__UpLoadDataResponse(soap, tag ? tag : "ns1:UpLoadDataResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpLoadDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpLoadDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpLoadDataResponse * SOAP_FMAC4 soap_get__ns1__UpLoadDataResponse(struct soap *soap, _ns1__UpLoadDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpLoadDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UpLoadData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpLoadData::sql);
	soap_default_string(soap, &this->_ns1__UpLoadData::file);
	soap_default_string(soap, &this->_ns1__UpLoadData::filename);
	soap_default_string(soap, &this->_ns1__UpLoadData::dwname);
	/* transient soap skipped */
}

void _ns1__UpLoadData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__UpLoadData::sql);
	soap_serialize_string(soap, (char*const*)&this->_ns1__UpLoadData::file);
	soap_serialize_string(soap, (char*const*)&this->_ns1__UpLoadData::filename);
	soap_serialize_string(soap, (char*const*)&this->_ns1__UpLoadData::dwname);
#endif
}

int _ns1__UpLoadData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpLoadData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpLoadData(struct soap *soap, const char *tag, int id, const _ns1__UpLoadData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpLoadData), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:sql", -1, (char*const*)&a->_ns1__UpLoadData::sql, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:file", -1, (char*const*)&a->_ns1__UpLoadData::file, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, (char*const*)&a->_ns1__UpLoadData::filename, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__UpLoadData::dwname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpLoadData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpLoadData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpLoadData * SOAP_FMAC4 soap_in__ns1__UpLoadData(struct soap *soap, const char *tag, _ns1__UpLoadData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpLoadData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpLoadData, sizeof(_ns1__UpLoadData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__UpLoadData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__UpLoadData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sql1 = 1;
	size_t soap_flag_file1 = 1;
	size_t soap_flag_filename1 = 1;
	size_t soap_flag_dwname1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sql1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:sql", (char**)&a->_ns1__UpLoadData::sql, "xsd:string"))
				{	soap_flag_sql1--;
					continue;
				}
			}
			if (soap_flag_file1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:file", (char**)&a->_ns1__UpLoadData::file, "xsd:string"))
				{	soap_flag_file1--;
					continue;
				}
			}
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:filename", (char**)&a->_ns1__UpLoadData::filename, "xsd:string"))
				{	soap_flag_filename1--;
					continue;
				}
			}
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__UpLoadData::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpLoadData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpLoadData, SOAP_TYPE__ns1__UpLoadData, sizeof(_ns1__UpLoadData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UpLoadData * SOAP_FMAC2 soap_instantiate__ns1__UpLoadData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpLoadData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UpLoadData *p;
	size_t k = sizeof(_ns1__UpLoadData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__UpLoadData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__UpLoadData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__UpLoadData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UpLoadData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__UpLoadData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__UpLoadData(soap, tag ? tag : "ns1:UpLoadData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpLoadData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpLoadData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpLoadData * SOAP_FMAC4 soap_get__ns1__UpLoadData(struct soap *soap, _ns1__UpLoadData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpLoadData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__TcdSendupResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__TcdSendupResponse::TcdSendupResult);
	/* transient soap skipped */
}

void _ns1__TcdSendupResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__TcdSendupResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__TcdSendupResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__TcdSendupResponse(struct soap *soap, const char *tag, int id, const _ns1__TcdSendupResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__TcdSendupResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:TcdSendupResult");
	if (soap_out_int(soap, "ns1:TcdSendupResult", -1, &a->_ns1__TcdSendupResponse::TcdSendupResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__TcdSendupResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__TcdSendupResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__TcdSendupResponse * SOAP_FMAC4 soap_in__ns1__TcdSendupResponse(struct soap *soap, const char *tag, _ns1__TcdSendupResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__TcdSendupResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__TcdSendupResponse, sizeof(_ns1__TcdSendupResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__TcdSendupResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__TcdSendupResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TcdSendupResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TcdSendupResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:TcdSendupResult", &a->_ns1__TcdSendupResponse::TcdSendupResult, "xsd:int"))
				{	soap_flag_TcdSendupResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:TcdSendupResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TcdSendupResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__TcdSendupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__TcdSendupResponse, SOAP_TYPE__ns1__TcdSendupResponse, sizeof(_ns1__TcdSendupResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__TcdSendupResponse * SOAP_FMAC2 soap_instantiate__ns1__TcdSendupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__TcdSendupResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__TcdSendupResponse *p;
	size_t k = sizeof(_ns1__TcdSendupResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__TcdSendupResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__TcdSendupResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__TcdSendupResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__TcdSendupResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__TcdSendupResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__TcdSendupResponse(soap, tag ? tag : "ns1:TcdSendupResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__TcdSendupResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__TcdSendupResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__TcdSendupResponse * SOAP_FMAC4 soap_get__ns1__TcdSendupResponse(struct soap *soap, _ns1__TcdSendupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__TcdSendupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__TcdSendup::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__TcdSendup::guid);
	soap_default_string(soap, &this->_ns1__TcdSendup::tctype);
	soap_default_string(soap, &this->_ns1__TcdSendup::date);
	soap_default_string(soap, &this->_ns1__TcdSendup::personnum);
	soap_default_string(soap, &this->_ns1__TcdSendup::time1);
	soap_default_string(soap, &this->_ns1__TcdSendup::time2);
	/* transient soap skipped */
}

void _ns1__TcdSendup::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__TcdSendup::guid);
	soap_serialize_string(soap, (char*const*)&this->_ns1__TcdSendup::tctype);
	soap_serialize_string(soap, (char*const*)&this->_ns1__TcdSendup::date);
	soap_serialize_string(soap, (char*const*)&this->_ns1__TcdSendup::personnum);
	soap_serialize_string(soap, (char*const*)&this->_ns1__TcdSendup::time1);
	soap_serialize_string(soap, (char*const*)&this->_ns1__TcdSendup::time2);
#endif
}

int _ns1__TcdSendup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__TcdSendup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__TcdSendup(struct soap *soap, const char *tag, int id, const _ns1__TcdSendup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__TcdSendup), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:guid", -1, (char*const*)&a->_ns1__TcdSendup::guid, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:tctype", -1, (char*const*)&a->_ns1__TcdSendup::tctype, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:date", -1, (char*const*)&a->_ns1__TcdSendup::date, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:personnum", -1, (char*const*)&a->_ns1__TcdSendup::personnum, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:time1", -1, (char*const*)&a->_ns1__TcdSendup::time1, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:time2", -1, (char*const*)&a->_ns1__TcdSendup::time2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__TcdSendup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__TcdSendup(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__TcdSendup * SOAP_FMAC4 soap_in__ns1__TcdSendup(struct soap *soap, const char *tag, _ns1__TcdSendup *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__TcdSendup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__TcdSendup, sizeof(_ns1__TcdSendup), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__TcdSendup)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__TcdSendup *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_guid1 = 1;
	size_t soap_flag_tctype1 = 1;
	size_t soap_flag_date1 = 1;
	size_t soap_flag_personnum1 = 1;
	size_t soap_flag_time11 = 1;
	size_t soap_flag_time21 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:guid", (char**)&a->_ns1__TcdSendup::guid, "xsd:string"))
				{	soap_flag_guid1--;
					continue;
				}
			}
			if (soap_flag_tctype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:tctype", (char**)&a->_ns1__TcdSendup::tctype, "xsd:string"))
				{	soap_flag_tctype1--;
					continue;
				}
			}
			if (soap_flag_date1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:date", (char**)&a->_ns1__TcdSendup::date, "xsd:string"))
				{	soap_flag_date1--;
					continue;
				}
			}
			if (soap_flag_personnum1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:personnum", (char**)&a->_ns1__TcdSendup::personnum, "xsd:string"))
				{	soap_flag_personnum1--;
					continue;
				}
			}
			if (soap_flag_time11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:time1", (char**)&a->_ns1__TcdSendup::time1, "xsd:string"))
				{	soap_flag_time11--;
					continue;
				}
			}
			if (soap_flag_time21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:time2", (char**)&a->_ns1__TcdSendup::time2, "xsd:string"))
				{	soap_flag_time21--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__TcdSendup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__TcdSendup, SOAP_TYPE__ns1__TcdSendup, sizeof(_ns1__TcdSendup), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__TcdSendup * SOAP_FMAC2 soap_instantiate__ns1__TcdSendup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__TcdSendup(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__TcdSendup *p;
	size_t k = sizeof(_ns1__TcdSendup);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__TcdSendup, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__TcdSendup);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__TcdSendup, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__TcdSendup location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__TcdSendup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__TcdSendup(soap, tag ? tag : "ns1:TcdSendup", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__TcdSendup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__TcdSendup(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__TcdSendup * SOAP_FMAC4 soap_get__ns1__TcdSendup(struct soap *soap, _ns1__TcdSendup *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__TcdSendup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__TcdQueryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__TcdQueryResponse::TcdQueryResult);
	/* transient soap skipped */
}

void _ns1__TcdQueryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__TcdQueryResponse::TcdQueryResult);
#endif
}

int _ns1__TcdQueryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__TcdQueryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__TcdQueryResponse(struct soap *soap, const char *tag, int id, const _ns1__TcdQueryResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__TcdQueryResponse), type))
		return soap->error;
	if (a->TcdQueryResult)
		soap_element_result(soap, "ns1:TcdQueryResult");
	if (soap_out_string(soap, "ns1:TcdQueryResult", -1, (char*const*)&a->_ns1__TcdQueryResponse::TcdQueryResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__TcdQueryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__TcdQueryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__TcdQueryResponse * SOAP_FMAC4 soap_in__ns1__TcdQueryResponse(struct soap *soap, const char *tag, _ns1__TcdQueryResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__TcdQueryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__TcdQueryResponse, sizeof(_ns1__TcdQueryResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__TcdQueryResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__TcdQueryResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TcdQueryResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TcdQueryResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:TcdQueryResult", (char**)&a->_ns1__TcdQueryResponse::TcdQueryResult, "xsd:string"))
				{	soap_flag_TcdQueryResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:TcdQueryResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__TcdQueryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__TcdQueryResponse, SOAP_TYPE__ns1__TcdQueryResponse, sizeof(_ns1__TcdQueryResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__TcdQueryResponse * SOAP_FMAC2 soap_instantiate__ns1__TcdQueryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__TcdQueryResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__TcdQueryResponse *p;
	size_t k = sizeof(_ns1__TcdQueryResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__TcdQueryResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__TcdQueryResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__TcdQueryResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__TcdQueryResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__TcdQueryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__TcdQueryResponse(soap, tag ? tag : "ns1:TcdQueryResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__TcdQueryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__TcdQueryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__TcdQueryResponse * SOAP_FMAC4 soap_get__ns1__TcdQueryResponse(struct soap *soap, _ns1__TcdQueryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__TcdQueryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__TcdQuery::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__TcdQuery::xb);
	soap_default_string(soap, &this->_ns1__TcdQuery::station);
	/* transient soap skipped */
}

void _ns1__TcdQuery::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__TcdQuery::xb);
	soap_serialize_string(soap, (char*const*)&this->_ns1__TcdQuery::station);
#endif
}

int _ns1__TcdQuery::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__TcdQuery(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__TcdQuery(struct soap *soap, const char *tag, int id, const _ns1__TcdQuery *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__TcdQuery), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xb", -1, (char*const*)&a->_ns1__TcdQuery::xb, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:station", -1, (char*const*)&a->_ns1__TcdQuery::station, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__TcdQuery::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__TcdQuery(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__TcdQuery * SOAP_FMAC4 soap_in__ns1__TcdQuery(struct soap *soap, const char *tag, _ns1__TcdQuery *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__TcdQuery *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__TcdQuery, sizeof(_ns1__TcdQuery), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__TcdQuery)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__TcdQuery *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_xb1 = 1;
	size_t soap_flag_station1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:xb", (char**)&a->_ns1__TcdQuery::xb, "xsd:string"))
				{	soap_flag_xb1--;
					continue;
				}
			}
			if (soap_flag_station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:station", (char**)&a->_ns1__TcdQuery::station, "xsd:string"))
				{	soap_flag_station1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__TcdQuery *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__TcdQuery, SOAP_TYPE__ns1__TcdQuery, sizeof(_ns1__TcdQuery), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__TcdQuery * SOAP_FMAC2 soap_instantiate__ns1__TcdQuery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__TcdQuery(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__TcdQuery *p;
	size_t k = sizeof(_ns1__TcdQuery);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__TcdQuery, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__TcdQuery);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__TcdQuery, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__TcdQuery location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__TcdQuery::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__TcdQuery(soap, tag ? tag : "ns1:TcdQuery", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__TcdQuery::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__TcdQuery(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__TcdQuery * SOAP_FMAC4 soap_get__ns1__TcdQuery(struct soap *soap, _ns1__TcdQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__TcdQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__QueryPhotobwResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__QueryPhotobwResponse::QueryPhotobwResult);
	/* transient soap skipped */
}

void _ns1__QueryPhotobwResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__QueryPhotobwResponse::QueryPhotobwResult);
#endif
}

int _ns1__QueryPhotobwResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QueryPhotobwResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QueryPhotobwResponse(struct soap *soap, const char *tag, int id, const _ns1__QueryPhotobwResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__QueryPhotobwResponse), type))
		return soap->error;
	if (a->QueryPhotobwResult)
		soap_element_result(soap, "ns1:QueryPhotobwResult");
	if (soap_out_string(soap, "ns1:QueryPhotobwResult", -1, (char*const*)&a->_ns1__QueryPhotobwResponse::QueryPhotobwResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__QueryPhotobwResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QueryPhotobwResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QueryPhotobwResponse * SOAP_FMAC4 soap_in__ns1__QueryPhotobwResponse(struct soap *soap, const char *tag, _ns1__QueryPhotobwResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QueryPhotobwResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__QueryPhotobwResponse, sizeof(_ns1__QueryPhotobwResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__QueryPhotobwResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__QueryPhotobwResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_QueryPhotobwResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QueryPhotobwResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:QueryPhotobwResult", (char**)&a->_ns1__QueryPhotobwResponse::QueryPhotobwResult, "xsd:string"))
				{	soap_flag_QueryPhotobwResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:QueryPhotobwResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QueryPhotobwResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__QueryPhotobwResponse, SOAP_TYPE__ns1__QueryPhotobwResponse, sizeof(_ns1__QueryPhotobwResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__QueryPhotobwResponse * SOAP_FMAC2 soap_instantiate__ns1__QueryPhotobwResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QueryPhotobwResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__QueryPhotobwResponse *p;
	size_t k = sizeof(_ns1__QueryPhotobwResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__QueryPhotobwResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__QueryPhotobwResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__QueryPhotobwResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__QueryPhotobwResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__QueryPhotobwResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__QueryPhotobwResponse(soap, tag ? tag : "ns1:QueryPhotobwResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__QueryPhotobwResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QueryPhotobwResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QueryPhotobwResponse * SOAP_FMAC4 soap_get__ns1__QueryPhotobwResponse(struct soap *soap, _ns1__QueryPhotobwResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QueryPhotobwResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__QueryPhotobw::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__QueryPhotobw::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__QueryPhotobw::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QueryPhotobw(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QueryPhotobw(struct soap *soap, const char *tag, int id, const _ns1__QueryPhotobw *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__QueryPhotobw), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__QueryPhotobw::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QueryPhotobw(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QueryPhotobw * SOAP_FMAC4 soap_in__ns1__QueryPhotobw(struct soap *soap, const char *tag, _ns1__QueryPhotobw *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QueryPhotobw *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__QueryPhotobw, sizeof(_ns1__QueryPhotobw), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__QueryPhotobw)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__QueryPhotobw *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QueryPhotobw *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__QueryPhotobw, SOAP_TYPE__ns1__QueryPhotobw, sizeof(_ns1__QueryPhotobw), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__QueryPhotobw * SOAP_FMAC2 soap_instantiate__ns1__QueryPhotobw(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QueryPhotobw(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__QueryPhotobw *p;
	size_t k = sizeof(_ns1__QueryPhotobw);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__QueryPhotobw, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__QueryPhotobw);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__QueryPhotobw, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__QueryPhotobw location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__QueryPhotobw::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__QueryPhotobw(soap, tag ? tag : "ns1:QueryPhotobw", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__QueryPhotobw::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QueryPhotobw(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QueryPhotobw * SOAP_FMAC4 soap_get__ns1__QueryPhotobw(struct soap *soap, _ns1__QueryPhotobw *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QueryPhotobw(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetOsDateTimeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetOsDateTimeResponse::GetOsDateTimeResult);
	/* transient soap skipped */
}

void _ns1__GetOsDateTimeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetOsDateTimeResponse::GetOsDateTimeResult);
#endif
}

int _ns1__GetOsDateTimeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetOsDateTimeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetOsDateTimeResponse(struct soap *soap, const char *tag, int id, const _ns1__GetOsDateTimeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetOsDateTimeResponse), type))
		return soap->error;
	if (a->GetOsDateTimeResult)
		soap_element_result(soap, "ns1:GetOsDateTimeResult");
	if (soap_out_string(soap, "ns1:GetOsDateTimeResult", -1, (char*const*)&a->_ns1__GetOsDateTimeResponse::GetOsDateTimeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetOsDateTimeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetOsDateTimeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetOsDateTimeResponse * SOAP_FMAC4 soap_in__ns1__GetOsDateTimeResponse(struct soap *soap, const char *tag, _ns1__GetOsDateTimeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetOsDateTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetOsDateTimeResponse, sizeof(_ns1__GetOsDateTimeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetOsDateTimeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetOsDateTimeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetOsDateTimeResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetOsDateTimeResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetOsDateTimeResult", (char**)&a->_ns1__GetOsDateTimeResponse::GetOsDateTimeResult, "xsd:string"))
				{	soap_flag_GetOsDateTimeResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetOsDateTimeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetOsDateTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetOsDateTimeResponse, SOAP_TYPE__ns1__GetOsDateTimeResponse, sizeof(_ns1__GetOsDateTimeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetOsDateTimeResponse * SOAP_FMAC2 soap_instantiate__ns1__GetOsDateTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetOsDateTimeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetOsDateTimeResponse *p;
	size_t k = sizeof(_ns1__GetOsDateTimeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetOsDateTimeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetOsDateTimeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetOsDateTimeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetOsDateTimeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetOsDateTimeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetOsDateTimeResponse(soap, tag ? tag : "ns1:GetOsDateTimeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetOsDateTimeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetOsDateTimeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetOsDateTimeResponse * SOAP_FMAC4 soap_get__ns1__GetOsDateTimeResponse(struct soap *soap, _ns1__GetOsDateTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetOsDateTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetOsDateTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetOsDateTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetOsDateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetOsDateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetOsDateTime(struct soap *soap, const char *tag, int id, const _ns1__GetOsDateTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetOsDateTime), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetOsDateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetOsDateTime(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetOsDateTime * SOAP_FMAC4 soap_in__ns1__GetOsDateTime(struct soap *soap, const char *tag, _ns1__GetOsDateTime *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetOsDateTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetOsDateTime, sizeof(_ns1__GetOsDateTime), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetOsDateTime)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetOsDateTime *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetOsDateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetOsDateTime, SOAP_TYPE__ns1__GetOsDateTime, sizeof(_ns1__GetOsDateTime), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetOsDateTime * SOAP_FMAC2 soap_instantiate__ns1__GetOsDateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetOsDateTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetOsDateTime *p;
	size_t k = sizeof(_ns1__GetOsDateTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetOsDateTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetOsDateTime);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetOsDateTime, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetOsDateTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetOsDateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetOsDateTime(soap, tag ? tag : "ns1:GetOsDateTime", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetOsDateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetOsDateTime(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetOsDateTime * SOAP_FMAC4 soap_get__ns1__GetOsDateTime(struct soap *soap, _ns1__GetOsDateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetOsDateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__signedUserInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__signedUserInfoResponse::signedUserInfoResult);
	/* transient soap skipped */
}

void _ns1__signedUserInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__signedUserInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__signedUserInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__signedUserInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__signedUserInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__signedUserInfoResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:signedUserInfoResult");
	if (soap_out_int(soap, "ns1:signedUserInfoResult", -1, &a->_ns1__signedUserInfoResponse::signedUserInfoResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__signedUserInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__signedUserInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__signedUserInfoResponse * SOAP_FMAC4 soap_in__ns1__signedUserInfoResponse(struct soap *soap, const char *tag, _ns1__signedUserInfoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__signedUserInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__signedUserInfoResponse, sizeof(_ns1__signedUserInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__signedUserInfoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__signedUserInfoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_signedUserInfoResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_signedUserInfoResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:signedUserInfoResult", &a->_ns1__signedUserInfoResponse::signedUserInfoResult, "xsd:int"))
				{	soap_flag_signedUserInfoResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:signedUserInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_signedUserInfoResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__signedUserInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__signedUserInfoResponse, SOAP_TYPE__ns1__signedUserInfoResponse, sizeof(_ns1__signedUserInfoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__signedUserInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__signedUserInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__signedUserInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__signedUserInfoResponse *p;
	size_t k = sizeof(_ns1__signedUserInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__signedUserInfoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__signedUserInfoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__signedUserInfoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__signedUserInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__signedUserInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__signedUserInfoResponse(soap, tag ? tag : "ns1:signedUserInfoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__signedUserInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__signedUserInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__signedUserInfoResponse * SOAP_FMAC4 soap_get__ns1__signedUserInfoResponse(struct soap *soap, _ns1__signedUserInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__signedUserInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__signedUserInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__signedUserInfo::personid);
	soap_default_string(soap, &this->_ns1__signedUserInfo::personname);
	soap_default_string(soap, &this->_ns1__signedUserInfo::password);
	soap_default_string(soap, &this->_ns1__signedUserInfo::phonenum);
	soap_default_string(soap, &this->_ns1__signedUserInfo::publishtime);
	soap_default_string(soap, &this->_ns1__signedUserInfo::publishver);
	soap_default_string(soap, &this->_ns1__signedUserInfo::dwname);
	/* transient soap skipped */
}

void _ns1__signedUserInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__signedUserInfo::personid);
	soap_serialize_string(soap, (char*const*)&this->_ns1__signedUserInfo::personname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__signedUserInfo::password);
	soap_serialize_string(soap, (char*const*)&this->_ns1__signedUserInfo::phonenum);
	soap_serialize_string(soap, (char*const*)&this->_ns1__signedUserInfo::publishtime);
	soap_serialize_string(soap, (char*const*)&this->_ns1__signedUserInfo::publishver);
	soap_serialize_string(soap, (char*const*)&this->_ns1__signedUserInfo::dwname);
#endif
}

int _ns1__signedUserInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__signedUserInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__signedUserInfo(struct soap *soap, const char *tag, int id, const _ns1__signedUserInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__signedUserInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:personid", -1, (char*const*)&a->_ns1__signedUserInfo::personid, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:personname", -1, (char*const*)&a->_ns1__signedUserInfo::personname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:password", -1, (char*const*)&a->_ns1__signedUserInfo::password, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:phonenum", -1, (char*const*)&a->_ns1__signedUserInfo::phonenum, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:publishtime", -1, (char*const*)&a->_ns1__signedUserInfo::publishtime, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:publishver", -1, (char*const*)&a->_ns1__signedUserInfo::publishver, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__signedUserInfo::dwname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__signedUserInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__signedUserInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__signedUserInfo * SOAP_FMAC4 soap_in__ns1__signedUserInfo(struct soap *soap, const char *tag, _ns1__signedUserInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__signedUserInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__signedUserInfo, sizeof(_ns1__signedUserInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__signedUserInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__signedUserInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_personid1 = 1;
	size_t soap_flag_personname1 = 1;
	size_t soap_flag_password1 = 1;
	size_t soap_flag_phonenum1 = 1;
	size_t soap_flag_publishtime1 = 1;
	size_t soap_flag_publishver1 = 1;
	size_t soap_flag_dwname1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_personid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:personid", (char**)&a->_ns1__signedUserInfo::personid, "xsd:string"))
				{	soap_flag_personid1--;
					continue;
				}
			}
			if (soap_flag_personname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:personname", (char**)&a->_ns1__signedUserInfo::personname, "xsd:string"))
				{	soap_flag_personname1--;
					continue;
				}
			}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:password", (char**)&a->_ns1__signedUserInfo::password, "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			}
			if (soap_flag_phonenum1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:phonenum", (char**)&a->_ns1__signedUserInfo::phonenum, "xsd:string"))
				{	soap_flag_phonenum1--;
					continue;
				}
			}
			if (soap_flag_publishtime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:publishtime", (char**)&a->_ns1__signedUserInfo::publishtime, "xsd:string"))
				{	soap_flag_publishtime1--;
					continue;
				}
			}
			if (soap_flag_publishver1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:publishver", (char**)&a->_ns1__signedUserInfo::publishver, "xsd:string"))
				{	soap_flag_publishver1--;
					continue;
				}
			}
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__signedUserInfo::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__signedUserInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__signedUserInfo, SOAP_TYPE__ns1__signedUserInfo, sizeof(_ns1__signedUserInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__signedUserInfo * SOAP_FMAC2 soap_instantiate__ns1__signedUserInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__signedUserInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__signedUserInfo *p;
	size_t k = sizeof(_ns1__signedUserInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__signedUserInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__signedUserInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__signedUserInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__signedUserInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__signedUserInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__signedUserInfo(soap, tag ? tag : "ns1:signedUserInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__signedUserInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__signedUserInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__signedUserInfo * SOAP_FMAC4 soap_get__ns1__signedUserInfo(struct soap *soap, _ns1__signedUserInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__signedUserInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetGxdataUpTimeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetGxdataUpTimeResponse::GetGxdataUpTimeResult);
	/* transient soap skipped */
}

void _ns1__GetGxdataUpTimeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetGxdataUpTimeResponse::GetGxdataUpTimeResult);
#endif
}

int _ns1__GetGxdataUpTimeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetGxdataUpTimeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetGxdataUpTimeResponse(struct soap *soap, const char *tag, int id, const _ns1__GetGxdataUpTimeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetGxdataUpTimeResponse), type))
		return soap->error;
	if (a->GetGxdataUpTimeResult)
		soap_element_result(soap, "ns1:GetGxdataUpTimeResult");
	if (soap_out_string(soap, "ns1:GetGxdataUpTimeResult", -1, (char*const*)&a->_ns1__GetGxdataUpTimeResponse::GetGxdataUpTimeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetGxdataUpTimeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetGxdataUpTimeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetGxdataUpTimeResponse * SOAP_FMAC4 soap_in__ns1__GetGxdataUpTimeResponse(struct soap *soap, const char *tag, _ns1__GetGxdataUpTimeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetGxdataUpTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetGxdataUpTimeResponse, sizeof(_ns1__GetGxdataUpTimeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetGxdataUpTimeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetGxdataUpTimeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetGxdataUpTimeResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetGxdataUpTimeResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetGxdataUpTimeResult", (char**)&a->_ns1__GetGxdataUpTimeResponse::GetGxdataUpTimeResult, "xsd:string"))
				{	soap_flag_GetGxdataUpTimeResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetGxdataUpTimeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetGxdataUpTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetGxdataUpTimeResponse, SOAP_TYPE__ns1__GetGxdataUpTimeResponse, sizeof(_ns1__GetGxdataUpTimeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetGxdataUpTimeResponse * SOAP_FMAC2 soap_instantiate__ns1__GetGxdataUpTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetGxdataUpTimeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetGxdataUpTimeResponse *p;
	size_t k = sizeof(_ns1__GetGxdataUpTimeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetGxdataUpTimeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetGxdataUpTimeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetGxdataUpTimeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetGxdataUpTimeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetGxdataUpTimeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetGxdataUpTimeResponse(soap, tag ? tag : "ns1:GetGxdataUpTimeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetGxdataUpTimeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetGxdataUpTimeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetGxdataUpTimeResponse * SOAP_FMAC4 soap_get__ns1__GetGxdataUpTimeResponse(struct soap *soap, _ns1__GetGxdataUpTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetGxdataUpTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetGxdataUpTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetGxdataUpTime::unitname);
	soap_default_string(soap, &this->_ns1__GetGxdataUpTime::unitlevel);
	/* transient soap skipped */
}

void _ns1__GetGxdataUpTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetGxdataUpTime::unitname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetGxdataUpTime::unitlevel);
#endif
}

int _ns1__GetGxdataUpTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetGxdataUpTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetGxdataUpTime(struct soap *soap, const char *tag, int id, const _ns1__GetGxdataUpTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetGxdataUpTime), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:unitname", -1, (char*const*)&a->_ns1__GetGxdataUpTime::unitname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:unitlevel", -1, (char*const*)&a->_ns1__GetGxdataUpTime::unitlevel, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetGxdataUpTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetGxdataUpTime(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetGxdataUpTime * SOAP_FMAC4 soap_in__ns1__GetGxdataUpTime(struct soap *soap, const char *tag, _ns1__GetGxdataUpTime *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetGxdataUpTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetGxdataUpTime, sizeof(_ns1__GetGxdataUpTime), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetGxdataUpTime)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetGxdataUpTime *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_unitname1 = 1;
	size_t soap_flag_unitlevel1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_unitname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:unitname", (char**)&a->_ns1__GetGxdataUpTime::unitname, "xsd:string"))
				{	soap_flag_unitname1--;
					continue;
				}
			}
			if (soap_flag_unitlevel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:unitlevel", (char**)&a->_ns1__GetGxdataUpTime::unitlevel, "xsd:string"))
				{	soap_flag_unitlevel1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetGxdataUpTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetGxdataUpTime, SOAP_TYPE__ns1__GetGxdataUpTime, sizeof(_ns1__GetGxdataUpTime), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetGxdataUpTime * SOAP_FMAC2 soap_instantiate__ns1__GetGxdataUpTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetGxdataUpTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetGxdataUpTime *p;
	size_t k = sizeof(_ns1__GetGxdataUpTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetGxdataUpTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetGxdataUpTime);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetGxdataUpTime, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetGxdataUpTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetGxdataUpTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetGxdataUpTime(soap, tag ? tag : "ns1:GetGxdataUpTime", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetGxdataUpTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetGxdataUpTime(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetGxdataUpTime * SOAP_FMAC4 soap_get__ns1__GetGxdataUpTime(struct soap *soap, _ns1__GetGxdataUpTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetGxdataUpTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DownAllPicResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__DownAllPicResponse::DownAllPicResult);
	/* transient soap skipped */
}

void _ns1__DownAllPicResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__DownAllPicResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DownAllPicResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DownAllPicResponse(struct soap *soap, const char *tag, int id, const _ns1__DownAllPicResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DownAllPicResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:DownAllPicResult");
	if (soap_out_int(soap, "ns1:DownAllPicResult", -1, &a->_ns1__DownAllPicResponse::DownAllPicResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DownAllPicResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DownAllPicResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DownAllPicResponse * SOAP_FMAC4 soap_in__ns1__DownAllPicResponse(struct soap *soap, const char *tag, _ns1__DownAllPicResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DownAllPicResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DownAllPicResponse, sizeof(_ns1__DownAllPicResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__DownAllPicResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__DownAllPicResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DownAllPicResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DownAllPicResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:DownAllPicResult", &a->_ns1__DownAllPicResponse::DownAllPicResult, "xsd:int"))
				{	soap_flag_DownAllPicResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:DownAllPicResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DownAllPicResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__DownAllPicResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DownAllPicResponse, SOAP_TYPE__ns1__DownAllPicResponse, sizeof(_ns1__DownAllPicResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DownAllPicResponse * SOAP_FMAC2 soap_instantiate__ns1__DownAllPicResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DownAllPicResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DownAllPicResponse *p;
	size_t k = sizeof(_ns1__DownAllPicResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__DownAllPicResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__DownAllPicResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__DownAllPicResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DownAllPicResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__DownAllPicResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__DownAllPicResponse(soap, tag ? tag : "ns1:DownAllPicResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DownAllPicResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DownAllPicResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DownAllPicResponse * SOAP_FMAC4 soap_get__ns1__DownAllPicResponse(struct soap *soap, _ns1__DownAllPicResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DownAllPicResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DownAllPic::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__DownAllPic::dwname);
	/* transient soap skipped */
}

void _ns1__DownAllPic::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__DownAllPic::dwname);
#endif
}

int _ns1__DownAllPic::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DownAllPic(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DownAllPic(struct soap *soap, const char *tag, int id, const _ns1__DownAllPic *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DownAllPic), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__DownAllPic::dwname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DownAllPic::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DownAllPic(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DownAllPic * SOAP_FMAC4 soap_in__ns1__DownAllPic(struct soap *soap, const char *tag, _ns1__DownAllPic *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DownAllPic *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DownAllPic, sizeof(_ns1__DownAllPic), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__DownAllPic)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__DownAllPic *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dwname1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__DownAllPic::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DownAllPic *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DownAllPic, SOAP_TYPE__ns1__DownAllPic, sizeof(_ns1__DownAllPic), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DownAllPic * SOAP_FMAC2 soap_instantiate__ns1__DownAllPic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DownAllPic(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DownAllPic *p;
	size_t k = sizeof(_ns1__DownAllPic);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__DownAllPic, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__DownAllPic);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__DownAllPic, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DownAllPic location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__DownAllPic::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__DownAllPic(soap, tag ? tag : "ns1:DownAllPic", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DownAllPic::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DownAllPic(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DownAllPic * SOAP_FMAC4 soap_get__ns1__DownAllPic(struct soap *soap, _ns1__DownAllPic *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DownAllPic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DownPicResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__DownPicResponse::DownPicResult);
	/* transient soap skipped */
}

void _ns1__DownPicResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__DownPicResponse::DownPicResult);
#endif
}

int _ns1__DownPicResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DownPicResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DownPicResponse(struct soap *soap, const char *tag, int id, const _ns1__DownPicResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DownPicResponse), type))
		return soap->error;
	if (a->DownPicResult)
		soap_element_result(soap, "ns1:DownPicResult");
	if (soap_out_string(soap, "ns1:DownPicResult", -1, (char*const*)&a->_ns1__DownPicResponse::DownPicResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DownPicResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DownPicResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DownPicResponse * SOAP_FMAC4 soap_in__ns1__DownPicResponse(struct soap *soap, const char *tag, _ns1__DownPicResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DownPicResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DownPicResponse, sizeof(_ns1__DownPicResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__DownPicResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__DownPicResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DownPicResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DownPicResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:DownPicResult", (char**)&a->_ns1__DownPicResponse::DownPicResult, "xsd:string"))
				{	soap_flag_DownPicResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:DownPicResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DownPicResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DownPicResponse, SOAP_TYPE__ns1__DownPicResponse, sizeof(_ns1__DownPicResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DownPicResponse * SOAP_FMAC2 soap_instantiate__ns1__DownPicResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DownPicResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DownPicResponse *p;
	size_t k = sizeof(_ns1__DownPicResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__DownPicResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__DownPicResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__DownPicResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DownPicResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__DownPicResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__DownPicResponse(soap, tag ? tag : "ns1:DownPicResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DownPicResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DownPicResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DownPicResponse * SOAP_FMAC4 soap_get__ns1__DownPicResponse(struct soap *soap, _ns1__DownPicResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DownPicResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DownPic::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__DownPic::guid);
	soap_default_string(soap, &this->_ns1__DownPic::dwname);
	/* transient soap skipped */
}

void _ns1__DownPic::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__DownPic::guid);
	soap_serialize_string(soap, (char*const*)&this->_ns1__DownPic::dwname);
#endif
}

int _ns1__DownPic::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DownPic(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DownPic(struct soap *soap, const char *tag, int id, const _ns1__DownPic *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DownPic), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:guid", -1, (char*const*)&a->_ns1__DownPic::guid, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__DownPic::dwname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DownPic::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DownPic(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DownPic * SOAP_FMAC4 soap_in__ns1__DownPic(struct soap *soap, const char *tag, _ns1__DownPic *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DownPic *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DownPic, sizeof(_ns1__DownPic), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__DownPic)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__DownPic *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_guid1 = 1;
	size_t soap_flag_dwname1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:guid", (char**)&a->_ns1__DownPic::guid, "xsd:string"))
				{	soap_flag_guid1--;
					continue;
				}
			}
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__DownPic::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DownPic *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DownPic, SOAP_TYPE__ns1__DownPic, sizeof(_ns1__DownPic), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DownPic * SOAP_FMAC2 soap_instantiate__ns1__DownPic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DownPic(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DownPic *p;
	size_t k = sizeof(_ns1__DownPic);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__DownPic, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__DownPic);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__DownPic, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DownPic location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__DownPic::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__DownPic(soap, tag ? tag : "ns1:DownPic", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DownPic::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DownPic(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DownPic * SOAP_FMAC4 soap_get__ns1__DownPic(struct soap *soap, _ns1__DownPic *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DownPic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SaveFileDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SaveFileDataResponse::SaveFileDataResult);
	/* transient soap skipped */
}

void _ns1__SaveFileDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__SaveFileDataResponse::SaveFileDataResult);
#endif
}

int _ns1__SaveFileDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SaveFileDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SaveFileDataResponse(struct soap *soap, const char *tag, int id, const _ns1__SaveFileDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SaveFileDataResponse), type))
		return soap->error;
	if (a->SaveFileDataResult)
		soap_element_result(soap, "ns1:SaveFileDataResult");
	if (soap_out_string(soap, "ns1:SaveFileDataResult", -1, (char*const*)&a->_ns1__SaveFileDataResponse::SaveFileDataResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SaveFileDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SaveFileDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SaveFileDataResponse * SOAP_FMAC4 soap_in__ns1__SaveFileDataResponse(struct soap *soap, const char *tag, _ns1__SaveFileDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SaveFileDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SaveFileDataResponse, sizeof(_ns1__SaveFileDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SaveFileDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SaveFileDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SaveFileDataResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SaveFileDataResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:SaveFileDataResult", (char**)&a->_ns1__SaveFileDataResponse::SaveFileDataResult, "xsd:string"))
				{	soap_flag_SaveFileDataResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:SaveFileDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SaveFileDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SaveFileDataResponse, SOAP_TYPE__ns1__SaveFileDataResponse, sizeof(_ns1__SaveFileDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SaveFileDataResponse * SOAP_FMAC2 soap_instantiate__ns1__SaveFileDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SaveFileDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SaveFileDataResponse *p;
	size_t k = sizeof(_ns1__SaveFileDataResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__SaveFileDataResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__SaveFileDataResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__SaveFileDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SaveFileDataResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__SaveFileDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SaveFileDataResponse(soap, tag ? tag : "ns1:SaveFileDataResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SaveFileDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SaveFileDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SaveFileDataResponse * SOAP_FMAC4 soap_get__ns1__SaveFileDataResponse(struct soap *soap, _ns1__SaveFileDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SaveFileDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SaveFileData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SaveFileData::xml);
	soap_default_string(soap, &this->_ns1__SaveFileData::filename);
	soap_default_string(soap, &this->_ns1__SaveFileData::pics);
	soap_default_string(soap, &this->_ns1__SaveFileData::dwname);
	/* transient soap skipped */
}

void _ns1__SaveFileData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__SaveFileData::xml);
	soap_serialize_string(soap, (char*const*)&this->_ns1__SaveFileData::filename);
	soap_serialize_string(soap, (char*const*)&this->_ns1__SaveFileData::pics);
	soap_serialize_string(soap, (char*const*)&this->_ns1__SaveFileData::dwname);
#endif
}

int _ns1__SaveFileData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SaveFileData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SaveFileData(struct soap *soap, const char *tag, int id, const _ns1__SaveFileData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SaveFileData), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xml", -1, (char*const*)&a->_ns1__SaveFileData::xml, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, (char*const*)&a->_ns1__SaveFileData::filename, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:pics", -1, (char*const*)&a->_ns1__SaveFileData::pics, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__SaveFileData::dwname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SaveFileData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SaveFileData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SaveFileData * SOAP_FMAC4 soap_in__ns1__SaveFileData(struct soap *soap, const char *tag, _ns1__SaveFileData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SaveFileData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SaveFileData, sizeof(_ns1__SaveFileData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SaveFileData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SaveFileData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_xml1 = 1;
	size_t soap_flag_filename1 = 1;
	size_t soap_flag_pics1 = 1;
	size_t soap_flag_dwname1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xml1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:xml", (char**)&a->_ns1__SaveFileData::xml, "xsd:string"))
				{	soap_flag_xml1--;
					continue;
				}
			}
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:filename", (char**)&a->_ns1__SaveFileData::filename, "xsd:string"))
				{	soap_flag_filename1--;
					continue;
				}
			}
			if (soap_flag_pics1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:pics", (char**)&a->_ns1__SaveFileData::pics, "xsd:string"))
				{	soap_flag_pics1--;
					continue;
				}
			}
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__SaveFileData::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SaveFileData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SaveFileData, SOAP_TYPE__ns1__SaveFileData, sizeof(_ns1__SaveFileData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SaveFileData * SOAP_FMAC2 soap_instantiate__ns1__SaveFileData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SaveFileData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SaveFileData *p;
	size_t k = sizeof(_ns1__SaveFileData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__SaveFileData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__SaveFileData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__SaveFileData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SaveFileData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__SaveFileData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SaveFileData(soap, tag ? tag : "ns1:SaveFileData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SaveFileData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SaveFileData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SaveFileData * SOAP_FMAC4 soap_get__ns1__SaveFileData(struct soap *soap, _ns1__SaveFileData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SaveFileData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SaveDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SaveDataResponse::SaveDataResult);
	/* transient soap skipped */
}

void _ns1__SaveDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__SaveDataResponse::SaveDataResult);
#endif
}

int _ns1__SaveDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SaveDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SaveDataResponse(struct soap *soap, const char *tag, int id, const _ns1__SaveDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SaveDataResponse), type))
		return soap->error;
	if (a->SaveDataResult)
		soap_element_result(soap, "ns1:SaveDataResult");
	if (soap_out_string(soap, "ns1:SaveDataResult", -1, (char*const*)&a->_ns1__SaveDataResponse::SaveDataResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SaveDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SaveDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SaveDataResponse * SOAP_FMAC4 soap_in__ns1__SaveDataResponse(struct soap *soap, const char *tag, _ns1__SaveDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SaveDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SaveDataResponse, sizeof(_ns1__SaveDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SaveDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SaveDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SaveDataResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SaveDataResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:SaveDataResult", (char**)&a->_ns1__SaveDataResponse::SaveDataResult, "xsd:string"))
				{	soap_flag_SaveDataResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:SaveDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SaveDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SaveDataResponse, SOAP_TYPE__ns1__SaveDataResponse, sizeof(_ns1__SaveDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SaveDataResponse * SOAP_FMAC2 soap_instantiate__ns1__SaveDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SaveDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SaveDataResponse *p;
	size_t k = sizeof(_ns1__SaveDataResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__SaveDataResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__SaveDataResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__SaveDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SaveDataResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__SaveDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SaveDataResponse(soap, tag ? tag : "ns1:SaveDataResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SaveDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SaveDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SaveDataResponse * SOAP_FMAC4 soap_get__ns1__SaveDataResponse(struct soap *soap, _ns1__SaveDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SaveDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SaveData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SaveData::xml);
	/* transient soap skipped */
}

void _ns1__SaveData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__SaveData::xml);
#endif
}

int _ns1__SaveData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SaveData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SaveData(struct soap *soap, const char *tag, int id, const _ns1__SaveData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SaveData), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xml", -1, (char*const*)&a->_ns1__SaveData::xml, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SaveData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SaveData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SaveData * SOAP_FMAC4 soap_in__ns1__SaveData(struct soap *soap, const char *tag, _ns1__SaveData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SaveData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SaveData, sizeof(_ns1__SaveData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SaveData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SaveData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_xml1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xml1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:xml", (char**)&a->_ns1__SaveData::xml, "xsd:string"))
				{	soap_flag_xml1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SaveData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SaveData, SOAP_TYPE__ns1__SaveData, sizeof(_ns1__SaveData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SaveData * SOAP_FMAC2 soap_instantiate__ns1__SaveData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SaveData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SaveData *p;
	size_t k = sizeof(_ns1__SaveData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__SaveData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__SaveData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__SaveData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SaveData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__SaveData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SaveData(soap, tag ? tag : "ns1:SaveData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SaveData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SaveData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SaveData * SOAP_FMAC4 soap_get__ns1__SaveData(struct soap *soap, _ns1__SaveData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SaveData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ExecuteSqlResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__ExecuteSqlResponse::ExecuteSqlResult);
	/* transient soap skipped */
}

void _ns1__ExecuteSqlResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__ExecuteSqlResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ExecuteSqlResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ExecuteSqlResponse(struct soap *soap, const char *tag, int id, const _ns1__ExecuteSqlResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ExecuteSqlResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:ExecuteSqlResult");
	if (soap_out_int(soap, "ns1:ExecuteSqlResult", -1, &a->_ns1__ExecuteSqlResponse::ExecuteSqlResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ExecuteSqlResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ExecuteSqlResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ExecuteSqlResponse * SOAP_FMAC4 soap_in__ns1__ExecuteSqlResponse(struct soap *soap, const char *tag, _ns1__ExecuteSqlResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ExecuteSqlResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ExecuteSqlResponse, sizeof(_ns1__ExecuteSqlResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ExecuteSqlResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ExecuteSqlResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ExecuteSqlResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ExecuteSqlResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:ExecuteSqlResult", &a->_ns1__ExecuteSqlResponse::ExecuteSqlResult, "xsd:int"))
				{	soap_flag_ExecuteSqlResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:ExecuteSqlResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ExecuteSqlResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__ExecuteSqlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ExecuteSqlResponse, SOAP_TYPE__ns1__ExecuteSqlResponse, sizeof(_ns1__ExecuteSqlResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ExecuteSqlResponse * SOAP_FMAC2 soap_instantiate__ns1__ExecuteSqlResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ExecuteSqlResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ExecuteSqlResponse *p;
	size_t k = sizeof(_ns1__ExecuteSqlResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ExecuteSqlResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ExecuteSqlResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ExecuteSqlResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ExecuteSqlResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ExecuteSqlResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ExecuteSqlResponse(soap, tag ? tag : "ns1:ExecuteSqlResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ExecuteSqlResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ExecuteSqlResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ExecuteSqlResponse * SOAP_FMAC4 soap_get__ns1__ExecuteSqlResponse(struct soap *soap, _ns1__ExecuteSqlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ExecuteSqlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ExecuteSql::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__ExecuteSql::sql);
	/* transient soap skipped */
}

void _ns1__ExecuteSql::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__ExecuteSql::sql);
#endif
}

int _ns1__ExecuteSql::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ExecuteSql(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ExecuteSql(struct soap *soap, const char *tag, int id, const _ns1__ExecuteSql *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ExecuteSql), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:sql", -1, (char*const*)&a->_ns1__ExecuteSql::sql, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ExecuteSql::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ExecuteSql(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ExecuteSql * SOAP_FMAC4 soap_in__ns1__ExecuteSql(struct soap *soap, const char *tag, _ns1__ExecuteSql *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ExecuteSql *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ExecuteSql, sizeof(_ns1__ExecuteSql), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ExecuteSql)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ExecuteSql *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sql1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sql1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:sql", (char**)&a->_ns1__ExecuteSql::sql, "xsd:string"))
				{	soap_flag_sql1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ExecuteSql *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ExecuteSql, SOAP_TYPE__ns1__ExecuteSql, sizeof(_ns1__ExecuteSql), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ExecuteSql * SOAP_FMAC2 soap_instantiate__ns1__ExecuteSql(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ExecuteSql(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ExecuteSql *p;
	size_t k = sizeof(_ns1__ExecuteSql);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ExecuteSql, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ExecuteSql);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ExecuteSql, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ExecuteSql location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ExecuteSql::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ExecuteSql(soap, tag ? tag : "ns1:ExecuteSql", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ExecuteSql::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ExecuteSql(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ExecuteSql * SOAP_FMAC4 soap_get__ns1__ExecuteSql(struct soap *soap, _ns1__ExecuteSql *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ExecuteSql(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__QueryDataCountResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__QueryDataCountResponse::QueryDataCountResult);
	/* transient soap skipped */
}

void _ns1__QueryDataCountResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__QueryDataCountResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QueryDataCountResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QueryDataCountResponse(struct soap *soap, const char *tag, int id, const _ns1__QueryDataCountResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__QueryDataCountResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:QueryDataCountResult");
	if (soap_out_int(soap, "ns1:QueryDataCountResult", -1, &a->_ns1__QueryDataCountResponse::QueryDataCountResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__QueryDataCountResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QueryDataCountResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QueryDataCountResponse * SOAP_FMAC4 soap_in__ns1__QueryDataCountResponse(struct soap *soap, const char *tag, _ns1__QueryDataCountResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QueryDataCountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__QueryDataCountResponse, sizeof(_ns1__QueryDataCountResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__QueryDataCountResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__QueryDataCountResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_QueryDataCountResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QueryDataCountResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:QueryDataCountResult", &a->_ns1__QueryDataCountResponse::QueryDataCountResult, "xsd:int"))
				{	soap_flag_QueryDataCountResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:QueryDataCountResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_QueryDataCountResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__QueryDataCountResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__QueryDataCountResponse, SOAP_TYPE__ns1__QueryDataCountResponse, sizeof(_ns1__QueryDataCountResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__QueryDataCountResponse * SOAP_FMAC2 soap_instantiate__ns1__QueryDataCountResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QueryDataCountResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__QueryDataCountResponse *p;
	size_t k = sizeof(_ns1__QueryDataCountResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__QueryDataCountResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__QueryDataCountResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__QueryDataCountResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__QueryDataCountResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__QueryDataCountResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__QueryDataCountResponse(soap, tag ? tag : "ns1:QueryDataCountResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__QueryDataCountResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QueryDataCountResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QueryDataCountResponse * SOAP_FMAC4 soap_get__ns1__QueryDataCountResponse(struct soap *soap, _ns1__QueryDataCountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QueryDataCountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__QueryDataCount::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__QueryDataCount::sql);
	/* transient soap skipped */
}

void _ns1__QueryDataCount::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__QueryDataCount::sql);
#endif
}

int _ns1__QueryDataCount::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QueryDataCount(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QueryDataCount(struct soap *soap, const char *tag, int id, const _ns1__QueryDataCount *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__QueryDataCount), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:sql", -1, (char*const*)&a->_ns1__QueryDataCount::sql, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__QueryDataCount::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QueryDataCount(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QueryDataCount * SOAP_FMAC4 soap_in__ns1__QueryDataCount(struct soap *soap, const char *tag, _ns1__QueryDataCount *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QueryDataCount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__QueryDataCount, sizeof(_ns1__QueryDataCount), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__QueryDataCount)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__QueryDataCount *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sql1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sql1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:sql", (char**)&a->_ns1__QueryDataCount::sql, "xsd:string"))
				{	soap_flag_sql1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QueryDataCount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__QueryDataCount, SOAP_TYPE__ns1__QueryDataCount, sizeof(_ns1__QueryDataCount), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__QueryDataCount * SOAP_FMAC2 soap_instantiate__ns1__QueryDataCount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QueryDataCount(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__QueryDataCount *p;
	size_t k = sizeof(_ns1__QueryDataCount);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__QueryDataCount, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__QueryDataCount);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__QueryDataCount, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__QueryDataCount location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__QueryDataCount::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__QueryDataCount(soap, tag ? tag : "ns1:QueryDataCount", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__QueryDataCount::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QueryDataCount(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QueryDataCount * SOAP_FMAC4 soap_get__ns1__QueryDataCount(struct soap *soap, _ns1__QueryDataCount *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QueryDataCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__QueryDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__QueryDataResponse::QueryDataResult);
	/* transient soap skipped */
}

void _ns1__QueryDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__QueryDataResponse::QueryDataResult);
#endif
}

int _ns1__QueryDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QueryDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QueryDataResponse(struct soap *soap, const char *tag, int id, const _ns1__QueryDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__QueryDataResponse), type))
		return soap->error;
	if (a->QueryDataResult)
		soap_element_result(soap, "ns1:QueryDataResult");
	if (soap_out_string(soap, "ns1:QueryDataResult", -1, (char*const*)&a->_ns1__QueryDataResponse::QueryDataResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__QueryDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QueryDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QueryDataResponse * SOAP_FMAC4 soap_in__ns1__QueryDataResponse(struct soap *soap, const char *tag, _ns1__QueryDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QueryDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__QueryDataResponse, sizeof(_ns1__QueryDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__QueryDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__QueryDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_QueryDataResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QueryDataResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:QueryDataResult", (char**)&a->_ns1__QueryDataResponse::QueryDataResult, "xsd:string"))
				{	soap_flag_QueryDataResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:QueryDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QueryDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__QueryDataResponse, SOAP_TYPE__ns1__QueryDataResponse, sizeof(_ns1__QueryDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__QueryDataResponse * SOAP_FMAC2 soap_instantiate__ns1__QueryDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QueryDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__QueryDataResponse *p;
	size_t k = sizeof(_ns1__QueryDataResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__QueryDataResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__QueryDataResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__QueryDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__QueryDataResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__QueryDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__QueryDataResponse(soap, tag ? tag : "ns1:QueryDataResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__QueryDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QueryDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QueryDataResponse * SOAP_FMAC4 soap_get__ns1__QueryDataResponse(struct soap *soap, _ns1__QueryDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QueryDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__QueryData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__QueryData::sql);
	/* transient soap skipped */
}

void _ns1__QueryData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__QueryData::sql);
#endif
}

int _ns1__QueryData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QueryData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QueryData(struct soap *soap, const char *tag, int id, const _ns1__QueryData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__QueryData), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:sql", -1, (char*const*)&a->_ns1__QueryData::sql, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__QueryData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QueryData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QueryData * SOAP_FMAC4 soap_in__ns1__QueryData(struct soap *soap, const char *tag, _ns1__QueryData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QueryData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__QueryData, sizeof(_ns1__QueryData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__QueryData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__QueryData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sql1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sql1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:sql", (char**)&a->_ns1__QueryData::sql, "xsd:string"))
				{	soap_flag_sql1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QueryData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__QueryData, SOAP_TYPE__ns1__QueryData, sizeof(_ns1__QueryData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__QueryData * SOAP_FMAC2 soap_instantiate__ns1__QueryData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QueryData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__QueryData *p;
	size_t k = sizeof(_ns1__QueryData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__QueryData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__QueryData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__QueryData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__QueryData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__QueryData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__QueryData(soap, tag ? tag : "ns1:QueryData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__QueryData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QueryData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QueryData * SOAP_FMAC4 soap_get__ns1__QueryData(struct soap *soap, _ns1__QueryData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QueryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetDBStringResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetDBStringResponse::GetDBStringResult);
	/* transient soap skipped */
}

void _ns1__GetDBStringResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDBStringResponse::GetDBStringResult);
#endif
}

int _ns1__GetDBStringResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDBStringResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDBStringResponse(struct soap *soap, const char *tag, int id, const _ns1__GetDBStringResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDBStringResponse), type))
		return soap->error;
	if (a->GetDBStringResult)
		soap_element_result(soap, "ns1:GetDBStringResult");
	if (soap_out_string(soap, "ns1:GetDBStringResult", -1, (char*const*)&a->_ns1__GetDBStringResponse::GetDBStringResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDBStringResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDBStringResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDBStringResponse * SOAP_FMAC4 soap_in__ns1__GetDBStringResponse(struct soap *soap, const char *tag, _ns1__GetDBStringResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDBStringResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDBStringResponse, sizeof(_ns1__GetDBStringResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetDBStringResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetDBStringResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetDBStringResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetDBStringResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetDBStringResult", (char**)&a->_ns1__GetDBStringResponse::GetDBStringResult, "xsd:string"))
				{	soap_flag_GetDBStringResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetDBStringResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDBStringResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDBStringResponse, SOAP_TYPE__ns1__GetDBStringResponse, sizeof(_ns1__GetDBStringResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetDBStringResponse * SOAP_FMAC2 soap_instantiate__ns1__GetDBStringResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDBStringResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetDBStringResponse *p;
	size_t k = sizeof(_ns1__GetDBStringResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetDBStringResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetDBStringResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetDBStringResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetDBStringResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetDBStringResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetDBStringResponse(soap, tag ? tag : "ns1:GetDBStringResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDBStringResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDBStringResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDBStringResponse * SOAP_FMAC4 soap_get__ns1__GetDBStringResponse(struct soap *soap, _ns1__GetDBStringResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDBStringResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetDBString::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetDBString::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetDBString::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDBString(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDBString(struct soap *soap, const char *tag, int id, const _ns1__GetDBString *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDBString), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDBString::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDBString(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDBString * SOAP_FMAC4 soap_in__ns1__GetDBString(struct soap *soap, const char *tag, _ns1__GetDBString *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDBString *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDBString, sizeof(_ns1__GetDBString), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetDBString)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetDBString *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDBString *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDBString, SOAP_TYPE__ns1__GetDBString, sizeof(_ns1__GetDBString), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetDBString * SOAP_FMAC2 soap_instantiate__ns1__GetDBString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDBString(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetDBString *p;
	size_t k = sizeof(_ns1__GetDBString);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetDBString, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetDBString);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetDBString, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetDBString location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetDBString::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetDBString(soap, tag ? tag : "ns1:GetDBString", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDBString::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDBString(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDBString * SOAP_FMAC4 soap_get__ns1__GetDBString(struct soap *soap, _ns1__GetDBString *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDBString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__HelloWorldResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__HelloWorldResponse::HelloWorldResult);
	/* transient soap skipped */
}

void _ns1__HelloWorldResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__HelloWorldResponse::HelloWorldResult);
#endif
}

int _ns1__HelloWorldResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__HelloWorldResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__HelloWorldResponse(struct soap *soap, const char *tag, int id, const _ns1__HelloWorldResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__HelloWorldResponse), type))
		return soap->error;
	if (a->HelloWorldResult)
		soap_element_result(soap, "ns1:HelloWorldResult");
	if (soap_out_string(soap, "ns1:HelloWorldResult", -1, (char*const*)&a->_ns1__HelloWorldResponse::HelloWorldResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__HelloWorldResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__HelloWorldResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__HelloWorldResponse * SOAP_FMAC4 soap_in__ns1__HelloWorldResponse(struct soap *soap, const char *tag, _ns1__HelloWorldResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__HelloWorldResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__HelloWorldResponse, sizeof(_ns1__HelloWorldResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__HelloWorldResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__HelloWorldResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_HelloWorldResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HelloWorldResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:HelloWorldResult", (char**)&a->_ns1__HelloWorldResponse::HelloWorldResult, "xsd:string"))
				{	soap_flag_HelloWorldResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:HelloWorldResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__HelloWorldResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__HelloWorldResponse, SOAP_TYPE__ns1__HelloWorldResponse, sizeof(_ns1__HelloWorldResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__HelloWorldResponse * SOAP_FMAC2 soap_instantiate__ns1__HelloWorldResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__HelloWorldResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__HelloWorldResponse *p;
	size_t k = sizeof(_ns1__HelloWorldResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__HelloWorldResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__HelloWorldResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__HelloWorldResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__HelloWorldResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__HelloWorldResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__HelloWorldResponse(soap, tag ? tag : "ns1:HelloWorldResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__HelloWorldResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__HelloWorldResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__HelloWorldResponse * SOAP_FMAC4 soap_get__ns1__HelloWorldResponse(struct soap *soap, _ns1__HelloWorldResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__HelloWorldResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__HelloWorld::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__HelloWorld::helloworld);
	/* transient soap skipped */
}

void _ns1__HelloWorld::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__HelloWorld::helloworld);
#endif
}

int _ns1__HelloWorld::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__HelloWorld(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__HelloWorld(struct soap *soap, const char *tag, int id, const _ns1__HelloWorld *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__HelloWorld), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:helloworld", -1, (char*const*)&a->_ns1__HelloWorld::helloworld, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__HelloWorld::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__HelloWorld(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__HelloWorld * SOAP_FMAC4 soap_in__ns1__HelloWorld(struct soap *soap, const char *tag, _ns1__HelloWorld *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__HelloWorld *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__HelloWorld, sizeof(_ns1__HelloWorld), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__HelloWorld)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__HelloWorld *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_helloworld1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_helloworld1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:helloworld", (char**)&a->_ns1__HelloWorld::helloworld, "xsd:string"))
				{	soap_flag_helloworld1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__HelloWorld *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__HelloWorld, SOAP_TYPE__ns1__HelloWorld, sizeof(_ns1__HelloWorld), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__HelloWorld * SOAP_FMAC2 soap_instantiate__ns1__HelloWorld(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__HelloWorld(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__HelloWorld *p;
	size_t k = sizeof(_ns1__HelloWorld);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__HelloWorld, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__HelloWorld);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__HelloWorld, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__HelloWorld location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__HelloWorld::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__HelloWorld(soap, tag ? tag : "ns1:HelloWorld", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__HelloWorld::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__HelloWorld(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__HelloWorld * SOAP_FMAC4 soap_get__ns1__HelloWorld(struct soap *soap, _ns1__HelloWorld *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__HelloWorld(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CheckDevCodeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__CheckDevCodeResponse::CheckDevCodeResult);
	/* transient soap skipped */
}

void _ns1__CheckDevCodeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__CheckDevCodeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CheckDevCodeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CheckDevCodeResponse(struct soap *soap, const char *tag, int id, const _ns1__CheckDevCodeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CheckDevCodeResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:CheckDevCodeResult");
	if (soap_out_int(soap, "ns1:CheckDevCodeResult", -1, &a->_ns1__CheckDevCodeResponse::CheckDevCodeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CheckDevCodeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CheckDevCodeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CheckDevCodeResponse * SOAP_FMAC4 soap_in__ns1__CheckDevCodeResponse(struct soap *soap, const char *tag, _ns1__CheckDevCodeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CheckDevCodeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CheckDevCodeResponse, sizeof(_ns1__CheckDevCodeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CheckDevCodeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CheckDevCodeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CheckDevCodeResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CheckDevCodeResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:CheckDevCodeResult", &a->_ns1__CheckDevCodeResponse::CheckDevCodeResult, "xsd:int"))
				{	soap_flag_CheckDevCodeResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:CheckDevCodeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CheckDevCodeResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CheckDevCodeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CheckDevCodeResponse, SOAP_TYPE__ns1__CheckDevCodeResponse, sizeof(_ns1__CheckDevCodeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CheckDevCodeResponse * SOAP_FMAC2 soap_instantiate__ns1__CheckDevCodeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CheckDevCodeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CheckDevCodeResponse *p;
	size_t k = sizeof(_ns1__CheckDevCodeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__CheckDevCodeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__CheckDevCodeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__CheckDevCodeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CheckDevCodeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__CheckDevCodeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CheckDevCodeResponse(soap, tag ? tag : "ns1:CheckDevCodeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CheckDevCodeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CheckDevCodeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CheckDevCodeResponse * SOAP_FMAC4 soap_get__ns1__CheckDevCodeResponse(struct soap *soap, _ns1__CheckDevCodeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CheckDevCodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CheckDevCode::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__CheckDevCode::xb);
	soap_default_string(soap, &this->_ns1__CheckDevCode::station);
	/* transient soap skipped */
}

void _ns1__CheckDevCode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__CheckDevCode::xb);
	soap_serialize_string(soap, (char*const*)&this->_ns1__CheckDevCode::station);
#endif
}

int _ns1__CheckDevCode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CheckDevCode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CheckDevCode(struct soap *soap, const char *tag, int id, const _ns1__CheckDevCode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CheckDevCode), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xb", -1, (char*const*)&a->_ns1__CheckDevCode::xb, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:station", -1, (char*const*)&a->_ns1__CheckDevCode::station, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CheckDevCode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CheckDevCode(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CheckDevCode * SOAP_FMAC4 soap_in__ns1__CheckDevCode(struct soap *soap, const char *tag, _ns1__CheckDevCode *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CheckDevCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CheckDevCode, sizeof(_ns1__CheckDevCode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CheckDevCode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CheckDevCode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_xb1 = 1;
	size_t soap_flag_station1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:xb", (char**)&a->_ns1__CheckDevCode::xb, "xsd:string"))
				{	soap_flag_xb1--;
					continue;
				}
			}
			if (soap_flag_station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:station", (char**)&a->_ns1__CheckDevCode::station, "xsd:string"))
				{	soap_flag_station1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CheckDevCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CheckDevCode, SOAP_TYPE__ns1__CheckDevCode, sizeof(_ns1__CheckDevCode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CheckDevCode * SOAP_FMAC2 soap_instantiate__ns1__CheckDevCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CheckDevCode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CheckDevCode *p;
	size_t k = sizeof(_ns1__CheckDevCode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__CheckDevCode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__CheckDevCode);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__CheckDevCode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CheckDevCode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__CheckDevCode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CheckDevCode(soap, tag ? tag : "ns1:CheckDevCode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CheckDevCode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CheckDevCode(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CheckDevCode * SOAP_FMAC4 soap_get__ns1__CheckDevCode(struct soap *soap, _ns1__CheckDevCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CheckDevCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetDevCodeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetDevCodeResponse::GetDevCodeResult);
	/* transient soap skipped */
}

void _ns1__GetDevCodeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDevCodeResponse::GetDevCodeResult);
#endif
}

int _ns1__GetDevCodeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDevCodeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDevCodeResponse(struct soap *soap, const char *tag, int id, const _ns1__GetDevCodeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDevCodeResponse), type))
		return soap->error;
	if (a->GetDevCodeResult)
		soap_element_result(soap, "ns1:GetDevCodeResult");
	if (soap_out_string(soap, "ns1:GetDevCodeResult", -1, (char*const*)&a->_ns1__GetDevCodeResponse::GetDevCodeResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDevCodeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDevCodeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDevCodeResponse * SOAP_FMAC4 soap_in__ns1__GetDevCodeResponse(struct soap *soap, const char *tag, _ns1__GetDevCodeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDevCodeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDevCodeResponse, sizeof(_ns1__GetDevCodeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetDevCodeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetDevCodeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetDevCodeResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetDevCodeResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetDevCodeResult", (char**)&a->_ns1__GetDevCodeResponse::GetDevCodeResult, "xsd:string"))
				{	soap_flag_GetDevCodeResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetDevCodeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDevCodeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDevCodeResponse, SOAP_TYPE__ns1__GetDevCodeResponse, sizeof(_ns1__GetDevCodeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetDevCodeResponse * SOAP_FMAC2 soap_instantiate__ns1__GetDevCodeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDevCodeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetDevCodeResponse *p;
	size_t k = sizeof(_ns1__GetDevCodeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetDevCodeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetDevCodeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetDevCodeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetDevCodeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetDevCodeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetDevCodeResponse(soap, tag ? tag : "ns1:GetDevCodeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDevCodeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDevCodeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDevCodeResponse * SOAP_FMAC4 soap_get__ns1__GetDevCodeResponse(struct soap *soap, _ns1__GetDevCodeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDevCodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetDevCode::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetDevCode::xb);
	soap_default_string(soap, &this->_ns1__GetDevCode::station);
	soap_default_int(soap, &this->_ns1__GetDevCode::iscode);
	/* transient soap skipped */
}

void _ns1__GetDevCode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDevCode::xb);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetDevCode::station);
#endif
}

int _ns1__GetDevCode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDevCode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDevCode(struct soap *soap, const char *tag, int id, const _ns1__GetDevCode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDevCode), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xb", -1, (char*const*)&a->_ns1__GetDevCode::xb, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:station", -1, (char*const*)&a->_ns1__GetDevCode::station, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:iscode", -1, &a->_ns1__GetDevCode::iscode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDevCode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDevCode(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDevCode * SOAP_FMAC4 soap_in__ns1__GetDevCode(struct soap *soap, const char *tag, _ns1__GetDevCode *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDevCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDevCode, sizeof(_ns1__GetDevCode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetDevCode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetDevCode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_xb1 = 1;
	size_t soap_flag_station1 = 1;
	size_t soap_flag_iscode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:xb", (char**)&a->_ns1__GetDevCode::xb, "xsd:string"))
				{	soap_flag_xb1--;
					continue;
				}
			}
			if (soap_flag_station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:station", (char**)&a->_ns1__GetDevCode::station, "xsd:string"))
				{	soap_flag_station1--;
					continue;
				}
			}
			if (soap_flag_iscode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:iscode", &a->_ns1__GetDevCode::iscode, "xsd:int"))
				{	soap_flag_iscode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_iscode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetDevCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDevCode, SOAP_TYPE__ns1__GetDevCode, sizeof(_ns1__GetDevCode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetDevCode * SOAP_FMAC2 soap_instantiate__ns1__GetDevCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDevCode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetDevCode *p;
	size_t k = sizeof(_ns1__GetDevCode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetDevCode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetDevCode);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetDevCode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetDevCode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetDevCode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetDevCode(soap, tag ? tag : "ns1:GetDevCode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDevCode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDevCode(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDevCode * SOAP_FMAC4 soap_get__ns1__GetDevCode(struct soap *soap, _ns1__GetDevCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDevCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetRyUnitResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetRyUnitResponse::GetRyUnitResult);
	/* transient soap skipped */
}

void _ns1__GetRyUnitResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetRyUnitResponse::GetRyUnitResult);
#endif
}

int _ns1__GetRyUnitResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetRyUnitResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetRyUnitResponse(struct soap *soap, const char *tag, int id, const _ns1__GetRyUnitResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetRyUnitResponse), type))
		return soap->error;
	if (a->GetRyUnitResult)
		soap_element_result(soap, "ns1:GetRyUnitResult");
	if (soap_out_string(soap, "ns1:GetRyUnitResult", -1, (char*const*)&a->_ns1__GetRyUnitResponse::GetRyUnitResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetRyUnitResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetRyUnitResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetRyUnitResponse * SOAP_FMAC4 soap_in__ns1__GetRyUnitResponse(struct soap *soap, const char *tag, _ns1__GetRyUnitResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetRyUnitResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetRyUnitResponse, sizeof(_ns1__GetRyUnitResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetRyUnitResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetRyUnitResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetRyUnitResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetRyUnitResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetRyUnitResult", (char**)&a->_ns1__GetRyUnitResponse::GetRyUnitResult, "xsd:string"))
				{	soap_flag_GetRyUnitResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetRyUnitResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetRyUnitResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetRyUnitResponse, SOAP_TYPE__ns1__GetRyUnitResponse, sizeof(_ns1__GetRyUnitResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetRyUnitResponse * SOAP_FMAC2 soap_instantiate__ns1__GetRyUnitResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetRyUnitResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetRyUnitResponse *p;
	size_t k = sizeof(_ns1__GetRyUnitResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetRyUnitResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetRyUnitResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetRyUnitResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetRyUnitResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetRyUnitResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetRyUnitResponse(soap, tag ? tag : "ns1:GetRyUnitResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetRyUnitResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetRyUnitResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetRyUnitResponse * SOAP_FMAC4 soap_get__ns1__GetRyUnitResponse(struct soap *soap, _ns1__GetRyUnitResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetRyUnitResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetRyUnit::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetRyUnit::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetRyUnit::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetRyUnit(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetRyUnit(struct soap *soap, const char *tag, int id, const _ns1__GetRyUnit *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetRyUnit), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetRyUnit::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetRyUnit(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetRyUnit * SOAP_FMAC4 soap_in__ns1__GetRyUnit(struct soap *soap, const char *tag, _ns1__GetRyUnit *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetRyUnit *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetRyUnit, sizeof(_ns1__GetRyUnit), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetRyUnit)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetRyUnit *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetRyUnit *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetRyUnit, SOAP_TYPE__ns1__GetRyUnit, sizeof(_ns1__GetRyUnit), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetRyUnit * SOAP_FMAC2 soap_instantiate__ns1__GetRyUnit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetRyUnit(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetRyUnit *p;
	size_t k = sizeof(_ns1__GetRyUnit);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetRyUnit, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetRyUnit);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetRyUnit, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetRyUnit location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetRyUnit::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetRyUnit(soap, tag ? tag : "ns1:GetRyUnit", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetRyUnit::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetRyUnit(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetRyUnit * SOAP_FMAC4 soap_get__ns1__GetRyUnit(struct soap *soap, _ns1__GetRyUnit *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetRyUnit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CheckLoginUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__CheckLoginUserResponse::CheckLoginUserResult);
	/* transient soap skipped */
}

void _ns1__CheckLoginUserResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__CheckLoginUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CheckLoginUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CheckLoginUserResponse(struct soap *soap, const char *tag, int id, const _ns1__CheckLoginUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CheckLoginUserResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:CheckLoginUserResult");
	if (soap_out_int(soap, "ns1:CheckLoginUserResult", -1, &a->_ns1__CheckLoginUserResponse::CheckLoginUserResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CheckLoginUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CheckLoginUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CheckLoginUserResponse * SOAP_FMAC4 soap_in__ns1__CheckLoginUserResponse(struct soap *soap, const char *tag, _ns1__CheckLoginUserResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CheckLoginUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CheckLoginUserResponse, sizeof(_ns1__CheckLoginUserResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CheckLoginUserResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CheckLoginUserResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CheckLoginUserResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CheckLoginUserResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:CheckLoginUserResult", &a->_ns1__CheckLoginUserResponse::CheckLoginUserResult, "xsd:int"))
				{	soap_flag_CheckLoginUserResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:CheckLoginUserResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CheckLoginUserResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CheckLoginUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CheckLoginUserResponse, SOAP_TYPE__ns1__CheckLoginUserResponse, sizeof(_ns1__CheckLoginUserResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CheckLoginUserResponse * SOAP_FMAC2 soap_instantiate__ns1__CheckLoginUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CheckLoginUserResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CheckLoginUserResponse *p;
	size_t k = sizeof(_ns1__CheckLoginUserResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__CheckLoginUserResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__CheckLoginUserResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__CheckLoginUserResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CheckLoginUserResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__CheckLoginUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CheckLoginUserResponse(soap, tag ? tag : "ns1:CheckLoginUserResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CheckLoginUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CheckLoginUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CheckLoginUserResponse * SOAP_FMAC4 soap_get__ns1__CheckLoginUserResponse(struct soap *soap, _ns1__CheckLoginUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CheckLoginUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CheckLoginUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__CheckLoginUser::username);
	soap_default_string(soap, &this->_ns1__CheckLoginUser::pass);
	soap_default_string(soap, &this->_ns1__CheckLoginUser::dwname);
	soap_default_string(soap, &this->_ns1__CheckLoginUser::peid);
	/* transient soap skipped */
}

void _ns1__CheckLoginUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__CheckLoginUser::username);
	soap_serialize_string(soap, (char*const*)&this->_ns1__CheckLoginUser::pass);
	soap_serialize_string(soap, (char*const*)&this->_ns1__CheckLoginUser::dwname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__CheckLoginUser::peid);
#endif
}

int _ns1__CheckLoginUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CheckLoginUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CheckLoginUser(struct soap *soap, const char *tag, int id, const _ns1__CheckLoginUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CheckLoginUser), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:username", -1, (char*const*)&a->_ns1__CheckLoginUser::username, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:pass", -1, (char*const*)&a->_ns1__CheckLoginUser::pass, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__CheckLoginUser::dwname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:peid", -1, (char*const*)&a->_ns1__CheckLoginUser::peid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CheckLoginUser::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CheckLoginUser(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CheckLoginUser * SOAP_FMAC4 soap_in__ns1__CheckLoginUser(struct soap *soap, const char *tag, _ns1__CheckLoginUser *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CheckLoginUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CheckLoginUser, sizeof(_ns1__CheckLoginUser), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CheckLoginUser)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CheckLoginUser *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_username1 = 1;
	size_t soap_flag_pass1 = 1;
	size_t soap_flag_dwname1 = 1;
	size_t soap_flag_peid1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:username", (char**)&a->_ns1__CheckLoginUser::username, "xsd:string"))
				{	soap_flag_username1--;
					continue;
				}
			}
			if (soap_flag_pass1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:pass", (char**)&a->_ns1__CheckLoginUser::pass, "xsd:string"))
				{	soap_flag_pass1--;
					continue;
				}
			}
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__CheckLoginUser::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap_flag_peid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:peid", (char**)&a->_ns1__CheckLoginUser::peid, "xsd:string"))
				{	soap_flag_peid1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CheckLoginUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CheckLoginUser, SOAP_TYPE__ns1__CheckLoginUser, sizeof(_ns1__CheckLoginUser), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CheckLoginUser * SOAP_FMAC2 soap_instantiate__ns1__CheckLoginUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CheckLoginUser(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CheckLoginUser *p;
	size_t k = sizeof(_ns1__CheckLoginUser);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__CheckLoginUser, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__CheckLoginUser);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__CheckLoginUser, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CheckLoginUser location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__CheckLoginUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CheckLoginUser(soap, tag ? tag : "ns1:CheckLoginUser", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CheckLoginUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CheckLoginUser(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CheckLoginUser * SOAP_FMAC4 soap_get__ns1__CheckLoginUser(struct soap *soap, _ns1__CheckLoginUser *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CheckLoginUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetPropNameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetPropNameResponse::GetPropNameResult);
	/* transient soap skipped */
}

void _ns1__GetPropNameResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetPropNameResponse::GetPropNameResult);
#endif
}

int _ns1__GetPropNameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPropNameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPropNameResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPropNameResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPropNameResponse), type))
		return soap->error;
	if (a->GetPropNameResult)
		soap_element_result(soap, "ns1:GetPropNameResult");
	if (soap_out_string(soap, "ns1:GetPropNameResult", -1, (char*const*)&a->_ns1__GetPropNameResponse::GetPropNameResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPropNameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPropNameResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPropNameResponse * SOAP_FMAC4 soap_in__ns1__GetPropNameResponse(struct soap *soap, const char *tag, _ns1__GetPropNameResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPropNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPropNameResponse, sizeof(_ns1__GetPropNameResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetPropNameResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetPropNameResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetPropNameResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPropNameResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetPropNameResult", (char**)&a->_ns1__GetPropNameResponse::GetPropNameResult, "xsd:string"))
				{	soap_flag_GetPropNameResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetPropNameResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPropNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPropNameResponse, SOAP_TYPE__ns1__GetPropNameResponse, sizeof(_ns1__GetPropNameResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetPropNameResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPropNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPropNameResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetPropNameResponse *p;
	size_t k = sizeof(_ns1__GetPropNameResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetPropNameResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetPropNameResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetPropNameResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetPropNameResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetPropNameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetPropNameResponse(soap, tag ? tag : "ns1:GetPropNameResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPropNameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPropNameResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPropNameResponse * SOAP_FMAC4 soap_get__ns1__GetPropNameResponse(struct soap *soap, _ns1__GetPropNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPropNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetPropName::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetPropName::stationtypeid);
	/* transient soap skipped */
}

void _ns1__GetPropName::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetPropName::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPropName(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPropName(struct soap *soap, const char *tag, int id, const _ns1__GetPropName *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPropName), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:stationtypeid", -1, &a->_ns1__GetPropName::stationtypeid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPropName::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPropName(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPropName * SOAP_FMAC4 soap_in__ns1__GetPropName(struct soap *soap, const char *tag, _ns1__GetPropName *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPropName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPropName, sizeof(_ns1__GetPropName), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetPropName)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetPropName *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_stationtypeid1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_stationtypeid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns1:stationtypeid", &a->_ns1__GetPropName::stationtypeid, "xsd:int"))
				{	soap_flag_stationtypeid1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_stationtypeid1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetPropName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPropName, SOAP_TYPE__ns1__GetPropName, sizeof(_ns1__GetPropName), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetPropName * SOAP_FMAC2 soap_instantiate__ns1__GetPropName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPropName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetPropName *p;
	size_t k = sizeof(_ns1__GetPropName);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetPropName, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetPropName);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetPropName, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetPropName location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetPropName::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetPropName(soap, tag ? tag : "ns1:GetPropName", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPropName::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPropName(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPropName * SOAP_FMAC4 soap_get__ns1__GetPropName(struct soap *soap, _ns1__GetPropName *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPropName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetPropListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetPropListResponse::GetPropListResult);
	/* transient soap skipped */
}

void _ns1__GetPropListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetPropListResponse::GetPropListResult);
#endif
}

int _ns1__GetPropListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPropListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPropListResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPropListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPropListResponse), type))
		return soap->error;
	if (a->GetPropListResult)
		soap_element_result(soap, "ns1:GetPropListResult");
	if (soap_out_string(soap, "ns1:GetPropListResult", -1, (char*const*)&a->_ns1__GetPropListResponse::GetPropListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPropListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPropListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPropListResponse * SOAP_FMAC4 soap_in__ns1__GetPropListResponse(struct soap *soap, const char *tag, _ns1__GetPropListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPropListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPropListResponse, sizeof(_ns1__GetPropListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetPropListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetPropListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetPropListResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPropListResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetPropListResult", (char**)&a->_ns1__GetPropListResponse::GetPropListResult, "xsd:string"))
				{	soap_flag_GetPropListResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetPropListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPropListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPropListResponse, SOAP_TYPE__ns1__GetPropListResponse, sizeof(_ns1__GetPropListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetPropListResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPropListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPropListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetPropListResponse *p;
	size_t k = sizeof(_ns1__GetPropListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetPropListResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetPropListResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetPropListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetPropListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetPropListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetPropListResponse(soap, tag ? tag : "ns1:GetPropListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPropListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPropListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPropListResponse * SOAP_FMAC4 soap_get__ns1__GetPropListResponse(struct soap *soap, _ns1__GetPropListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPropListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetPropList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetPropList::dwname);
	soap_default_string(soap, &this->_ns1__GetPropList::xbname);
	soap_default_string(soap, &this->_ns1__GetPropList::station);
	/* transient soap skipped */
}

void _ns1__GetPropList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetPropList::dwname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetPropList::xbname);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetPropList::station);
#endif
}

int _ns1__GetPropList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPropList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPropList(struct soap *soap, const char *tag, int id, const _ns1__GetPropList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPropList), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:dwname", -1, (char*const*)&a->_ns1__GetPropList::dwname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:xbname", -1, (char*const*)&a->_ns1__GetPropList::xbname, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:station", -1, (char*const*)&a->_ns1__GetPropList::station, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPropList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPropList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPropList * SOAP_FMAC4 soap_in__ns1__GetPropList(struct soap *soap, const char *tag, _ns1__GetPropList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPropList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPropList, sizeof(_ns1__GetPropList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetPropList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetPropList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dwname1 = 1;
	size_t soap_flag_xbname1 = 1;
	size_t soap_flag_station1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dwname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:dwname", (char**)&a->_ns1__GetPropList::dwname, "xsd:string"))
				{	soap_flag_dwname1--;
					continue;
				}
			}
			if (soap_flag_xbname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:xbname", (char**)&a->_ns1__GetPropList::xbname, "xsd:string"))
				{	soap_flag_xbname1--;
					continue;
				}
			}
			if (soap_flag_station1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:station", (char**)&a->_ns1__GetPropList::station, "xsd:string"))
				{	soap_flag_station1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPropList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPropList, SOAP_TYPE__ns1__GetPropList, sizeof(_ns1__GetPropList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetPropList * SOAP_FMAC2 soap_instantiate__ns1__GetPropList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPropList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetPropList *p;
	size_t k = sizeof(_ns1__GetPropList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetPropList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetPropList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetPropList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetPropList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetPropList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetPropList(soap, tag ? tag : "ns1:GetPropList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPropList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPropList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPropList * SOAP_FMAC4 soap_get__ns1__GetPropList(struct soap *soap, _ns1__GetPropList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPropList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetYjzhZskDevFlowChartListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetYjzhZskDevFlowChartListResponse::GetYjzhZskDevFlowChartListResult);
	/* transient soap skipped */
}

void _ns1__GetYjzhZskDevFlowChartListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetYjzhZskDevFlowChartListResponse::GetYjzhZskDevFlowChartListResult);
#endif
}

int _ns1__GetYjzhZskDevFlowChartListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetYjzhZskDevFlowChartListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetYjzhZskDevFlowChartListResponse(struct soap *soap, const char *tag, int id, const _ns1__GetYjzhZskDevFlowChartListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetYjzhZskDevFlowChartListResponse), type))
		return soap->error;
	if (a->GetYjzhZskDevFlowChartListResult)
		soap_element_result(soap, "ns1:GetYjzhZskDevFlowChartListResult");
	if (soap_out_string(soap, "ns1:GetYjzhZskDevFlowChartListResult", -1, (char*const*)&a->_ns1__GetYjzhZskDevFlowChartListResponse::GetYjzhZskDevFlowChartListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetYjzhZskDevFlowChartListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetYjzhZskDevFlowChartListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetYjzhZskDevFlowChartListResponse * SOAP_FMAC4 soap_in__ns1__GetYjzhZskDevFlowChartListResponse(struct soap *soap, const char *tag, _ns1__GetYjzhZskDevFlowChartListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetYjzhZskDevFlowChartListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetYjzhZskDevFlowChartListResponse, sizeof(_ns1__GetYjzhZskDevFlowChartListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetYjzhZskDevFlowChartListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetYjzhZskDevFlowChartListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetYjzhZskDevFlowChartListResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetYjzhZskDevFlowChartListResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetYjzhZskDevFlowChartListResult", (char**)&a->_ns1__GetYjzhZskDevFlowChartListResponse::GetYjzhZskDevFlowChartListResult, "xsd:string"))
				{	soap_flag_GetYjzhZskDevFlowChartListResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetYjzhZskDevFlowChartListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetYjzhZskDevFlowChartListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetYjzhZskDevFlowChartListResponse, SOAP_TYPE__ns1__GetYjzhZskDevFlowChartListResponse, sizeof(_ns1__GetYjzhZskDevFlowChartListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetYjzhZskDevFlowChartListResponse * SOAP_FMAC2 soap_instantiate__ns1__GetYjzhZskDevFlowChartListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetYjzhZskDevFlowChartListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetYjzhZskDevFlowChartListResponse *p;
	size_t k = sizeof(_ns1__GetYjzhZskDevFlowChartListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetYjzhZskDevFlowChartListResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetYjzhZskDevFlowChartListResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetYjzhZskDevFlowChartListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetYjzhZskDevFlowChartListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetYjzhZskDevFlowChartListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetYjzhZskDevFlowChartListResponse(soap, tag ? tag : "ns1:GetYjzhZskDevFlowChartListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetYjzhZskDevFlowChartListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetYjzhZskDevFlowChartListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetYjzhZskDevFlowChartListResponse * SOAP_FMAC4 soap_get__ns1__GetYjzhZskDevFlowChartListResponse(struct soap *soap, _ns1__GetYjzhZskDevFlowChartListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetYjzhZskDevFlowChartListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetYjzhZskDevFlowChartList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetYjzhZskDevFlowChartList::xb);
	soap_default_string(soap, &this->_ns1__GetYjzhZskDevFlowChartList::cz);
	soap_default_string(soap, &this->_ns1__GetYjzhZskDevFlowChartList::devtypeid);
	soap_default_string(soap, &this->_ns1__GetYjzhZskDevFlowChartList::devname);
	/* transient soap skipped */
}

void _ns1__GetYjzhZskDevFlowChartList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetYjzhZskDevFlowChartList::xb);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetYjzhZskDevFlowChartList::cz);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetYjzhZskDevFlowChartList::devtypeid);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetYjzhZskDevFlowChartList::devname);
#endif
}

int _ns1__GetYjzhZskDevFlowChartList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetYjzhZskDevFlowChartList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetYjzhZskDevFlowChartList(struct soap *soap, const char *tag, int id, const _ns1__GetYjzhZskDevFlowChartList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetYjzhZskDevFlowChartList), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xb", -1, (char*const*)&a->_ns1__GetYjzhZskDevFlowChartList::xb, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:cz", -1, (char*const*)&a->_ns1__GetYjzhZskDevFlowChartList::cz, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:devtypeid", -1, (char*const*)&a->_ns1__GetYjzhZskDevFlowChartList::devtypeid, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:devname", -1, (char*const*)&a->_ns1__GetYjzhZskDevFlowChartList::devname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetYjzhZskDevFlowChartList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetYjzhZskDevFlowChartList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetYjzhZskDevFlowChartList * SOAP_FMAC4 soap_in__ns1__GetYjzhZskDevFlowChartList(struct soap *soap, const char *tag, _ns1__GetYjzhZskDevFlowChartList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetYjzhZskDevFlowChartList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetYjzhZskDevFlowChartList, sizeof(_ns1__GetYjzhZskDevFlowChartList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetYjzhZskDevFlowChartList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetYjzhZskDevFlowChartList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_xb1 = 1;
	size_t soap_flag_cz1 = 1;
	size_t soap_flag_devtypeid1 = 1;
	size_t soap_flag_devname1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:xb", (char**)&a->_ns1__GetYjzhZskDevFlowChartList::xb, "xsd:string"))
				{	soap_flag_xb1--;
					continue;
				}
			}
			if (soap_flag_cz1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:cz", (char**)&a->_ns1__GetYjzhZskDevFlowChartList::cz, "xsd:string"))
				{	soap_flag_cz1--;
					continue;
				}
			}
			if (soap_flag_devtypeid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:devtypeid", (char**)&a->_ns1__GetYjzhZskDevFlowChartList::devtypeid, "xsd:string"))
				{	soap_flag_devtypeid1--;
					continue;
				}
			}
			if (soap_flag_devname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:devname", (char**)&a->_ns1__GetYjzhZskDevFlowChartList::devname, "xsd:string"))
				{	soap_flag_devname1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetYjzhZskDevFlowChartList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetYjzhZskDevFlowChartList, SOAP_TYPE__ns1__GetYjzhZskDevFlowChartList, sizeof(_ns1__GetYjzhZskDevFlowChartList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetYjzhZskDevFlowChartList * SOAP_FMAC2 soap_instantiate__ns1__GetYjzhZskDevFlowChartList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetYjzhZskDevFlowChartList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetYjzhZskDevFlowChartList *p;
	size_t k = sizeof(_ns1__GetYjzhZskDevFlowChartList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetYjzhZskDevFlowChartList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetYjzhZskDevFlowChartList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetYjzhZskDevFlowChartList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetYjzhZskDevFlowChartList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetYjzhZskDevFlowChartList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetYjzhZskDevFlowChartList(soap, tag ? tag : "ns1:GetYjzhZskDevFlowChartList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetYjzhZskDevFlowChartList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetYjzhZskDevFlowChartList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetYjzhZskDevFlowChartList * SOAP_FMAC4 soap_get__ns1__GetYjzhZskDevFlowChartList(struct soap *soap, _ns1__GetYjzhZskDevFlowChartList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetYjzhZskDevFlowChartList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetYjzhZskOtherFlowChartListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetYjzhZskOtherFlowChartListResponse::GetYjzhZskOtherFlowChartListResult);
	/* transient soap skipped */
}

void _ns1__GetYjzhZskOtherFlowChartListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetYjzhZskOtherFlowChartListResponse::GetYjzhZskOtherFlowChartListResult);
#endif
}

int _ns1__GetYjzhZskOtherFlowChartListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetYjzhZskOtherFlowChartListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetYjzhZskOtherFlowChartListResponse(struct soap *soap, const char *tag, int id, const _ns1__GetYjzhZskOtherFlowChartListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartListResponse), type))
		return soap->error;
	if (a->GetYjzhZskOtherFlowChartListResult)
		soap_element_result(soap, "ns1:GetYjzhZskOtherFlowChartListResult");
	if (soap_out_string(soap, "ns1:GetYjzhZskOtherFlowChartListResult", -1, (char*const*)&a->_ns1__GetYjzhZskOtherFlowChartListResponse::GetYjzhZskOtherFlowChartListResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetYjzhZskOtherFlowChartListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetYjzhZskOtherFlowChartListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetYjzhZskOtherFlowChartListResponse * SOAP_FMAC4 soap_in__ns1__GetYjzhZskOtherFlowChartListResponse(struct soap *soap, const char *tag, _ns1__GetYjzhZskOtherFlowChartListResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetYjzhZskOtherFlowChartListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartListResponse, sizeof(_ns1__GetYjzhZskOtherFlowChartListResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartListResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetYjzhZskOtherFlowChartListResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetYjzhZskOtherFlowChartListResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetYjzhZskOtherFlowChartListResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetYjzhZskOtherFlowChartListResult", (char**)&a->_ns1__GetYjzhZskOtherFlowChartListResponse::GetYjzhZskOtherFlowChartListResult, "xsd:string"))
				{	soap_flag_GetYjzhZskOtherFlowChartListResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetYjzhZskOtherFlowChartListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetYjzhZskOtherFlowChartListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartListResponse, SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartListResponse, sizeof(_ns1__GetYjzhZskOtherFlowChartListResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetYjzhZskOtherFlowChartListResponse * SOAP_FMAC2 soap_instantiate__ns1__GetYjzhZskOtherFlowChartListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetYjzhZskOtherFlowChartListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetYjzhZskOtherFlowChartListResponse *p;
	size_t k = sizeof(_ns1__GetYjzhZskOtherFlowChartListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartListResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetYjzhZskOtherFlowChartListResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetYjzhZskOtherFlowChartListResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetYjzhZskOtherFlowChartListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetYjzhZskOtherFlowChartListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetYjzhZskOtherFlowChartListResponse(soap, tag ? tag : "ns1:GetYjzhZskOtherFlowChartListResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetYjzhZskOtherFlowChartListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetYjzhZskOtherFlowChartListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetYjzhZskOtherFlowChartListResponse * SOAP_FMAC4 soap_get__ns1__GetYjzhZskOtherFlowChartListResponse(struct soap *soap, _ns1__GetYjzhZskOtherFlowChartListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetYjzhZskOtherFlowChartListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetYjzhZskOtherFlowChartList::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetYjzhZskOtherFlowChartList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetYjzhZskOtherFlowChartList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetYjzhZskOtherFlowChartList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetYjzhZskOtherFlowChartList(struct soap *soap, const char *tag, int id, const _ns1__GetYjzhZskOtherFlowChartList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartList), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetYjzhZskOtherFlowChartList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetYjzhZskOtherFlowChartList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetYjzhZskOtherFlowChartList * SOAP_FMAC4 soap_in__ns1__GetYjzhZskOtherFlowChartList(struct soap *soap, const char *tag, _ns1__GetYjzhZskOtherFlowChartList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetYjzhZskOtherFlowChartList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartList, sizeof(_ns1__GetYjzhZskOtherFlowChartList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetYjzhZskOtherFlowChartList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetYjzhZskOtherFlowChartList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartList, SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartList, sizeof(_ns1__GetYjzhZskOtherFlowChartList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetYjzhZskOtherFlowChartList * SOAP_FMAC2 soap_instantiate__ns1__GetYjzhZskOtherFlowChartList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetYjzhZskOtherFlowChartList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetYjzhZskOtherFlowChartList *p;
	size_t k = sizeof(_ns1__GetYjzhZskOtherFlowChartList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetYjzhZskOtherFlowChartList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetYjzhZskOtherFlowChartList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetYjzhZskOtherFlowChartList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetYjzhZskOtherFlowChartList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetYjzhZskOtherFlowChartList(soap, tag ? tag : "ns1:GetYjzhZskOtherFlowChartList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetYjzhZskOtherFlowChartList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetYjzhZskOtherFlowChartList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetYjzhZskOtherFlowChartList * SOAP_FMAC4 soap_get__ns1__GetYjzhZskOtherFlowChartList(struct soap *soap, _ns1__GetYjzhZskOtherFlowChartList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetYjzhZskOtherFlowChartList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetYjzhZskGzFlowResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetYjzhZskGzFlowResponse::GetYjzhZskGzFlowResult);
	/* transient soap skipped */
}

void _ns1__GetYjzhZskGzFlowResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetYjzhZskGzFlowResponse::GetYjzhZskGzFlowResult);
#endif
}

int _ns1__GetYjzhZskGzFlowResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetYjzhZskGzFlowResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetYjzhZskGzFlowResponse(struct soap *soap, const char *tag, int id, const _ns1__GetYjzhZskGzFlowResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetYjzhZskGzFlowResponse), type))
		return soap->error;
	if (a->GetYjzhZskGzFlowResult)
		soap_element_result(soap, "ns1:GetYjzhZskGzFlowResult");
	if (soap_out_string(soap, "ns1:GetYjzhZskGzFlowResult", -1, (char*const*)&a->_ns1__GetYjzhZskGzFlowResponse::GetYjzhZskGzFlowResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetYjzhZskGzFlowResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetYjzhZskGzFlowResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetYjzhZskGzFlowResponse * SOAP_FMAC4 soap_in__ns1__GetYjzhZskGzFlowResponse(struct soap *soap, const char *tag, _ns1__GetYjzhZskGzFlowResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetYjzhZskGzFlowResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetYjzhZskGzFlowResponse, sizeof(_ns1__GetYjzhZskGzFlowResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetYjzhZskGzFlowResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetYjzhZskGzFlowResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetYjzhZskGzFlowResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetYjzhZskGzFlowResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:GetYjzhZskGzFlowResult", (char**)&a->_ns1__GetYjzhZskGzFlowResponse::GetYjzhZskGzFlowResult, "xsd:string"))
				{	soap_flag_GetYjzhZskGzFlowResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetYjzhZskGzFlowResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetYjzhZskGzFlowResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetYjzhZskGzFlowResponse, SOAP_TYPE__ns1__GetYjzhZskGzFlowResponse, sizeof(_ns1__GetYjzhZskGzFlowResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetYjzhZskGzFlowResponse * SOAP_FMAC2 soap_instantiate__ns1__GetYjzhZskGzFlowResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetYjzhZskGzFlowResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetYjzhZskGzFlowResponse *p;
	size_t k = sizeof(_ns1__GetYjzhZskGzFlowResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetYjzhZskGzFlowResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetYjzhZskGzFlowResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetYjzhZskGzFlowResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetYjzhZskGzFlowResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetYjzhZskGzFlowResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetYjzhZskGzFlowResponse(soap, tag ? tag : "ns1:GetYjzhZskGzFlowResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetYjzhZskGzFlowResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetYjzhZskGzFlowResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetYjzhZskGzFlowResponse * SOAP_FMAC4 soap_get__ns1__GetYjzhZskGzFlowResponse(struct soap *soap, _ns1__GetYjzhZskGzFlowResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetYjzhZskGzFlowResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetYjzhZskGzFlow::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetYjzhZskGzFlow::id);
	/* transient soap skipped */
}

void _ns1__GetYjzhZskGzFlow::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetYjzhZskGzFlow::id);
#endif
}

int _ns1__GetYjzhZskGzFlow::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetYjzhZskGzFlow(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetYjzhZskGzFlow(struct soap *soap, const char *tag, int id, const _ns1__GetYjzhZskGzFlow *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetYjzhZskGzFlow), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, (char*const*)&a->_ns1__GetYjzhZskGzFlow::id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetYjzhZskGzFlow::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetYjzhZskGzFlow(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetYjzhZskGzFlow * SOAP_FMAC4 soap_in__ns1__GetYjzhZskGzFlow(struct soap *soap, const char *tag, _ns1__GetYjzhZskGzFlow *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetYjzhZskGzFlow *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetYjzhZskGzFlow, sizeof(_ns1__GetYjzhZskGzFlow), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetYjzhZskGzFlow)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetYjzhZskGzFlow *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_id1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:id", (char**)&a->_ns1__GetYjzhZskGzFlow::id, "xsd:string"))
				{	soap_flag_id1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetYjzhZskGzFlow *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetYjzhZskGzFlow, SOAP_TYPE__ns1__GetYjzhZskGzFlow, sizeof(_ns1__GetYjzhZskGzFlow), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetYjzhZskGzFlow * SOAP_FMAC2 soap_instantiate__ns1__GetYjzhZskGzFlow(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetYjzhZskGzFlow(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetYjzhZskGzFlow *p;
	size_t k = sizeof(_ns1__GetYjzhZskGzFlow);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetYjzhZskGzFlow, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetYjzhZskGzFlow);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetYjzhZskGzFlow, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetYjzhZskGzFlow location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetYjzhZskGzFlow::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetYjzhZskGzFlow(soap, tag ? tag : "ns1:GetYjzhZskGzFlow", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetYjzhZskGzFlow::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetYjzhZskGzFlow(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetYjzhZskGzFlow * SOAP_FMAC4 soap_get__ns1__GetYjzhZskGzFlow(struct soap *soap, _ns1__GetYjzhZskGzFlow *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetYjzhZskGzFlow(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfBase64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfBase64Binary::__sizebase64Binary = 0;
	this->ns1__ArrayOfBase64Binary::base64Binary = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfBase64Binary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->ns1__ArrayOfBase64Binary::base64Binary)
	{	int i;
		for (i = 0; i < (int)this->ns1__ArrayOfBase64Binary::__sizebase64Binary; i++)
		{
			soap_embedded(soap, this->ns1__ArrayOfBase64Binary::base64Binary + i, SOAP_TYPE_xsd__base64Binary);
			this->ns1__ArrayOfBase64Binary::base64Binary[i].soap_serialize(soap);
		}
	}
#endif
}

int ns1__ArrayOfBase64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfBase64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfBase64Binary(struct soap *soap, const char *tag, int id, const ns1__ArrayOfBase64Binary *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfBase64Binary), type))
		return soap->error;
	if (a->ns1__ArrayOfBase64Binary::base64Binary)
	{	int i;
		for (i = 0; i < (int)a->ns1__ArrayOfBase64Binary::__sizebase64Binary; i++)
			if (a->ns1__ArrayOfBase64Binary::base64Binary[i].soap_out(soap, "ns1:base64Binary", -1, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfBase64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfBase64Binary(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfBase64Binary * SOAP_FMAC4 soap_in_ns1__ArrayOfBase64Binary(struct soap *soap, const char *tag, ns1__ArrayOfBase64Binary *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfBase64Binary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfBase64Binary, sizeof(ns1__ArrayOfBase64Binary), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ArrayOfBase64Binary)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ArrayOfBase64Binary *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	struct soap_blist *soap_blist_base64Binary1 = NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:base64Binary", 1, NULL))
			{	if (a->ns1__ArrayOfBase64Binary::base64Binary == NULL)
				{	if (soap_blist_base64Binary1 == NULL)
						soap_blist_base64Binary1 = soap_alloc_block(soap);
					a->ns1__ArrayOfBase64Binary::base64Binary = soap_block<xsd__base64Binary>::push(soap, soap_blist_base64Binary1);
					if (a->ns1__ArrayOfBase64Binary::base64Binary == NULL)
						return NULL;
					a->ns1__ArrayOfBase64Binary::base64Binary->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in_xsd__base64Binary(soap, "ns1:base64Binary", a->ns1__ArrayOfBase64Binary::base64Binary, "xsd:base64Binary"))
				{	a->ns1__ArrayOfBase64Binary::__sizebase64Binary++;
					a->ns1__ArrayOfBase64Binary::base64Binary = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfBase64Binary::base64Binary)
			soap_block<xsd__base64Binary>::pop(soap, soap_blist_base64Binary1);
		if (a->ns1__ArrayOfBase64Binary::__sizebase64Binary)
		{	a->ns1__ArrayOfBase64Binary::base64Binary = soap_new_xsd__base64Binary(soap, a->ns1__ArrayOfBase64Binary::__sizebase64Binary);
			if (!a->ns1__ArrayOfBase64Binary::base64Binary)
				return NULL;
			soap_block<xsd__base64Binary>::save(soap, soap_blist_base64Binary1, a->ns1__ArrayOfBase64Binary::base64Binary);
		}
		else
		{	a->ns1__ArrayOfBase64Binary::base64Binary = NULL;
			if (soap_blist_base64Binary1)
				soap_block<xsd__base64Binary>::end(soap, soap_blist_base64Binary1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfBase64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfBase64Binary, SOAP_TYPE_ns1__ArrayOfBase64Binary, sizeof(ns1__ArrayOfBase64Binary), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfBase64Binary * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfBase64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfBase64Binary(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfBase64Binary *p;
	size_t k = sizeof(ns1__ArrayOfBase64Binary);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ArrayOfBase64Binary, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ArrayOfBase64Binary);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ArrayOfBase64Binary, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfBase64Binary location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ArrayOfBase64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ArrayOfBase64Binary(soap, tag ? tag : "ns1:ArrayOfBase64Binary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfBase64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfBase64Binary(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfBase64Binary * SOAP_FMAC4 soap_get_ns1__ArrayOfBase64Binary(struct soap *soap, ns1__ArrayOfBase64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfBase64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ptr = NULL;
	this->__size = 0;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr)
		(void)soap_attachment_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_xsd__base64Binary, this->id, this->type);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__base64Binary2s(struct soap *soap, xsd__base64Binary a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_xsd__base64Binary, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__base64Binary(struct soap *soap, const char *s, xsd__base64Binary *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__base64Binary *p;
	size_t k = sizeof(xsd__base64Binary);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__base64Binary);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__base64Binary, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__base64Binary location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__base64Binary(soap, tag ? tag : "xsd:base64Binary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetYjzhZskAlarmTypes_(struct soap *soap, struct __ns1__GetYjzhZskAlarmTypes_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetYjzhZskAlarmTypes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetYjzhZskAlarmTypes_(struct soap *soap, const struct __ns1__GetYjzhZskAlarmTypes_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetYjzhZskAlarmTypes(soap, &a->ns1__GetYjzhZskAlarmTypes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetYjzhZskAlarmTypes_(struct soap *soap, const char *tag, int id, const struct __ns1__GetYjzhZskAlarmTypes_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetYjzhZskAlarmTypes(soap, "ns1:GetYjzhZskAlarmTypes", -1, &a->ns1__GetYjzhZskAlarmTypes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetYjzhZskAlarmTypes_ * SOAP_FMAC4 soap_in___ns1__GetYjzhZskAlarmTypes_(struct soap *soap, const char *tag, struct __ns1__GetYjzhZskAlarmTypes_ *a, const char *type)
{
	size_t soap_flag_ns1__GetYjzhZskAlarmTypes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetYjzhZskAlarmTypes_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetYjzhZskAlarmTypes_, sizeof(struct __ns1__GetYjzhZskAlarmTypes_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetYjzhZskAlarmTypes_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetYjzhZskAlarmTypes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetYjzhZskAlarmTypes(soap, "ns1:GetYjzhZskAlarmTypes", &a->ns1__GetYjzhZskAlarmTypes, ""))
				{	soap_flag_ns1__GetYjzhZskAlarmTypes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetYjzhZskAlarmTypes_ * SOAP_FMAC2 soap_instantiate___ns1__GetYjzhZskAlarmTypes_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetYjzhZskAlarmTypes_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetYjzhZskAlarmTypes_ *p;
	size_t k = sizeof(struct __ns1__GetYjzhZskAlarmTypes_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetYjzhZskAlarmTypes_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetYjzhZskAlarmTypes_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetYjzhZskAlarmTypes_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetYjzhZskAlarmTypes_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetYjzhZskAlarmTypes_(struct soap *soap, const struct __ns1__GetYjzhZskAlarmTypes_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetYjzhZskAlarmTypes_(soap, tag ? tag : "-ns1:GetYjzhZskAlarmTypes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetYjzhZskAlarmTypes_ * SOAP_FMAC4 soap_get___ns1__GetYjzhZskAlarmTypes_(struct soap *soap, struct __ns1__GetYjzhZskAlarmTypes_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetYjzhZskAlarmTypes_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SelectYjzhDevice_(struct soap *soap, struct __ns1__SelectYjzhDevice_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SelectYjzhDevice = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SelectYjzhDevice_(struct soap *soap, const struct __ns1__SelectYjzhDevice_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SelectYjzhDevice(soap, &a->ns1__SelectYjzhDevice);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SelectYjzhDevice_(struct soap *soap, const char *tag, int id, const struct __ns1__SelectYjzhDevice_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SelectYjzhDevice(soap, "ns1:SelectYjzhDevice", -1, &a->ns1__SelectYjzhDevice, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SelectYjzhDevice_ * SOAP_FMAC4 soap_in___ns1__SelectYjzhDevice_(struct soap *soap, const char *tag, struct __ns1__SelectYjzhDevice_ *a, const char *type)
{
	size_t soap_flag_ns1__SelectYjzhDevice = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SelectYjzhDevice_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SelectYjzhDevice_, sizeof(struct __ns1__SelectYjzhDevice_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SelectYjzhDevice_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SelectYjzhDevice && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SelectYjzhDevice(soap, "ns1:SelectYjzhDevice", &a->ns1__SelectYjzhDevice, ""))
				{	soap_flag_ns1__SelectYjzhDevice--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SelectYjzhDevice_ * SOAP_FMAC2 soap_instantiate___ns1__SelectYjzhDevice_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SelectYjzhDevice_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SelectYjzhDevice_ *p;
	size_t k = sizeof(struct __ns1__SelectYjzhDevice_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__SelectYjzhDevice_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__SelectYjzhDevice_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__SelectYjzhDevice_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SelectYjzhDevice_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SelectYjzhDevice_(struct soap *soap, const struct __ns1__SelectYjzhDevice_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SelectYjzhDevice_(soap, tag ? tag : "-ns1:SelectYjzhDevice", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SelectYjzhDevice_ * SOAP_FMAC4 soap_get___ns1__SelectYjzhDevice_(struct soap *soap, struct __ns1__SelectYjzhDevice_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SelectYjzhDevice_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SelectYjzhStation_(struct soap *soap, struct __ns1__SelectYjzhStation_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SelectYjzhStation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SelectYjzhStation_(struct soap *soap, const struct __ns1__SelectYjzhStation_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SelectYjzhStation(soap, &a->ns1__SelectYjzhStation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SelectYjzhStation_(struct soap *soap, const char *tag, int id, const struct __ns1__SelectYjzhStation_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SelectYjzhStation(soap, "ns1:SelectYjzhStation", -1, &a->ns1__SelectYjzhStation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SelectYjzhStation_ * SOAP_FMAC4 soap_in___ns1__SelectYjzhStation_(struct soap *soap, const char *tag, struct __ns1__SelectYjzhStation_ *a, const char *type)
{
	size_t soap_flag_ns1__SelectYjzhStation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SelectYjzhStation_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SelectYjzhStation_, sizeof(struct __ns1__SelectYjzhStation_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SelectYjzhStation_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SelectYjzhStation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SelectYjzhStation(soap, "ns1:SelectYjzhStation", &a->ns1__SelectYjzhStation, ""))
				{	soap_flag_ns1__SelectYjzhStation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SelectYjzhStation_ * SOAP_FMAC2 soap_instantiate___ns1__SelectYjzhStation_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SelectYjzhStation_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SelectYjzhStation_ *p;
	size_t k = sizeof(struct __ns1__SelectYjzhStation_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__SelectYjzhStation_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__SelectYjzhStation_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__SelectYjzhStation_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SelectYjzhStation_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SelectYjzhStation_(struct soap *soap, const struct __ns1__SelectYjzhStation_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SelectYjzhStation_(soap, tag ? tag : "-ns1:SelectYjzhStation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SelectYjzhStation_ * SOAP_FMAC4 soap_get___ns1__SelectYjzhStation_(struct soap *soap, struct __ns1__SelectYjzhStation_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SelectYjzhStation_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SaveMapFile_(struct soap *soap, struct __ns1__SaveMapFile_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SaveMapFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SaveMapFile_(struct soap *soap, const struct __ns1__SaveMapFile_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SaveMapFile(soap, &a->ns1__SaveMapFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SaveMapFile_(struct soap *soap, const char *tag, int id, const struct __ns1__SaveMapFile_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SaveMapFile(soap, "ns1:SaveMapFile", -1, &a->ns1__SaveMapFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SaveMapFile_ * SOAP_FMAC4 soap_in___ns1__SaveMapFile_(struct soap *soap, const char *tag, struct __ns1__SaveMapFile_ *a, const char *type)
{
	size_t soap_flag_ns1__SaveMapFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SaveMapFile_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SaveMapFile_, sizeof(struct __ns1__SaveMapFile_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SaveMapFile_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SaveMapFile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SaveMapFile(soap, "ns1:SaveMapFile", &a->ns1__SaveMapFile, ""))
				{	soap_flag_ns1__SaveMapFile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SaveMapFile_ * SOAP_FMAC2 soap_instantiate___ns1__SaveMapFile_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SaveMapFile_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SaveMapFile_ *p;
	size_t k = sizeof(struct __ns1__SaveMapFile_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__SaveMapFile_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__SaveMapFile_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__SaveMapFile_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SaveMapFile_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SaveMapFile_(struct soap *soap, const struct __ns1__SaveMapFile_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SaveMapFile_(soap, tag ? tag : "-ns1:SaveMapFile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SaveMapFile_ * SOAP_FMAC4 soap_get___ns1__SaveMapFile_(struct soap *soap, struct __ns1__SaveMapFile_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SaveMapFile_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GzGetDeviceStruct_(struct soap *soap, struct __ns1__GzGetDeviceStruct_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GzGetDeviceStruct = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GzGetDeviceStruct_(struct soap *soap, const struct __ns1__GzGetDeviceStruct_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GzGetDeviceStruct(soap, &a->ns1__GzGetDeviceStruct);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GzGetDeviceStruct_(struct soap *soap, const char *tag, int id, const struct __ns1__GzGetDeviceStruct_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GzGetDeviceStruct(soap, "ns1:GzGetDeviceStruct", -1, &a->ns1__GzGetDeviceStruct, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GzGetDeviceStruct_ * SOAP_FMAC4 soap_in___ns1__GzGetDeviceStruct_(struct soap *soap, const char *tag, struct __ns1__GzGetDeviceStruct_ *a, const char *type)
{
	size_t soap_flag_ns1__GzGetDeviceStruct = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GzGetDeviceStruct_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GzGetDeviceStruct_, sizeof(struct __ns1__GzGetDeviceStruct_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GzGetDeviceStruct_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GzGetDeviceStruct && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GzGetDeviceStruct(soap, "ns1:GzGetDeviceStruct", &a->ns1__GzGetDeviceStruct, ""))
				{	soap_flag_ns1__GzGetDeviceStruct--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GzGetDeviceStruct_ * SOAP_FMAC2 soap_instantiate___ns1__GzGetDeviceStruct_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GzGetDeviceStruct_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GzGetDeviceStruct_ *p;
	size_t k = sizeof(struct __ns1__GzGetDeviceStruct_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GzGetDeviceStruct_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GzGetDeviceStruct_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GzGetDeviceStruct_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GzGetDeviceStruct_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GzGetDeviceStruct_(struct soap *soap, const struct __ns1__GzGetDeviceStruct_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GzGetDeviceStruct_(soap, tag ? tag : "-ns1:GzGetDeviceStruct", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GzGetDeviceStruct_ * SOAP_FMAC4 soap_get___ns1__GzGetDeviceStruct_(struct soap *soap, struct __ns1__GzGetDeviceStruct_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GzGetDeviceStruct_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GzGetTypeList_(struct soap *soap, struct __ns1__GzGetTypeList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GzGetTypeList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GzGetTypeList_(struct soap *soap, const struct __ns1__GzGetTypeList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GzGetTypeList(soap, &a->ns1__GzGetTypeList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GzGetTypeList_(struct soap *soap, const char *tag, int id, const struct __ns1__GzGetTypeList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GzGetTypeList(soap, "ns1:GzGetTypeList", -1, &a->ns1__GzGetTypeList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GzGetTypeList_ * SOAP_FMAC4 soap_in___ns1__GzGetTypeList_(struct soap *soap, const char *tag, struct __ns1__GzGetTypeList_ *a, const char *type)
{
	size_t soap_flag_ns1__GzGetTypeList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GzGetTypeList_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GzGetTypeList_, sizeof(struct __ns1__GzGetTypeList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GzGetTypeList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GzGetTypeList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GzGetTypeList(soap, "ns1:GzGetTypeList", &a->ns1__GzGetTypeList, ""))
				{	soap_flag_ns1__GzGetTypeList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GzGetTypeList_ * SOAP_FMAC2 soap_instantiate___ns1__GzGetTypeList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GzGetTypeList_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GzGetTypeList_ *p;
	size_t k = sizeof(struct __ns1__GzGetTypeList_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GzGetTypeList_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GzGetTypeList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GzGetTypeList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GzGetTypeList_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GzGetTypeList_(struct soap *soap, const struct __ns1__GzGetTypeList_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GzGetTypeList_(soap, tag ? tag : "-ns1:GzGetTypeList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GzGetTypeList_ * SOAP_FMAC4 soap_get___ns1__GzGetTypeList_(struct soap *soap, struct __ns1__GzGetTypeList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GzGetTypeList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SGCDrawEmf_(struct soap *soap, struct __ns1__SGCDrawEmf_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SGCDrawEmf = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SGCDrawEmf_(struct soap *soap, const struct __ns1__SGCDrawEmf_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SGCDrawEmf(soap, &a->ns1__SGCDrawEmf);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SGCDrawEmf_(struct soap *soap, const char *tag, int id, const struct __ns1__SGCDrawEmf_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SGCDrawEmf(soap, "ns1:SGCDrawEmf", -1, &a->ns1__SGCDrawEmf, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SGCDrawEmf_ * SOAP_FMAC4 soap_in___ns1__SGCDrawEmf_(struct soap *soap, const char *tag, struct __ns1__SGCDrawEmf_ *a, const char *type)
{
	size_t soap_flag_ns1__SGCDrawEmf = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SGCDrawEmf_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SGCDrawEmf_, sizeof(struct __ns1__SGCDrawEmf_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SGCDrawEmf_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SGCDrawEmf && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SGCDrawEmf(soap, "ns1:SGCDrawEmf", &a->ns1__SGCDrawEmf, ""))
				{	soap_flag_ns1__SGCDrawEmf--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SGCDrawEmf_ * SOAP_FMAC2 soap_instantiate___ns1__SGCDrawEmf_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SGCDrawEmf_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SGCDrawEmf_ *p;
	size_t k = sizeof(struct __ns1__SGCDrawEmf_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__SGCDrawEmf_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__SGCDrawEmf_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__SGCDrawEmf_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SGCDrawEmf_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SGCDrawEmf_(struct soap *soap, const struct __ns1__SGCDrawEmf_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SGCDrawEmf_(soap, tag ? tag : "-ns1:SGCDrawEmf", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SGCDrawEmf_ * SOAP_FMAC4 soap_get___ns1__SGCDrawEmf_(struct soap *soap, struct __ns1__SGCDrawEmf_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SGCDrawEmf_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__FlowChartEmf_(struct soap *soap, struct __ns1__FlowChartEmf_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__FlowChartEmf = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__FlowChartEmf_(struct soap *soap, const struct __ns1__FlowChartEmf_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__FlowChartEmf(soap, &a->ns1__FlowChartEmf);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__FlowChartEmf_(struct soap *soap, const char *tag, int id, const struct __ns1__FlowChartEmf_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__FlowChartEmf(soap, "ns1:FlowChartEmf", -1, &a->ns1__FlowChartEmf, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FlowChartEmf_ * SOAP_FMAC4 soap_in___ns1__FlowChartEmf_(struct soap *soap, const char *tag, struct __ns1__FlowChartEmf_ *a, const char *type)
{
	size_t soap_flag_ns1__FlowChartEmf = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__FlowChartEmf_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__FlowChartEmf_, sizeof(struct __ns1__FlowChartEmf_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__FlowChartEmf_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__FlowChartEmf && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__FlowChartEmf(soap, "ns1:FlowChartEmf", &a->ns1__FlowChartEmf, ""))
				{	soap_flag_ns1__FlowChartEmf--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__FlowChartEmf_ * SOAP_FMAC2 soap_instantiate___ns1__FlowChartEmf_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__FlowChartEmf_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__FlowChartEmf_ *p;
	size_t k = sizeof(struct __ns1__FlowChartEmf_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__FlowChartEmf_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__FlowChartEmf_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__FlowChartEmf_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__FlowChartEmf_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__FlowChartEmf_(struct soap *soap, const struct __ns1__FlowChartEmf_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__FlowChartEmf_(soap, tag ? tag : "-ns1:FlowChartEmf", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FlowChartEmf_ * SOAP_FMAC4 soap_get___ns1__FlowChartEmf_(struct soap *soap, struct __ns1__FlowChartEmf_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__FlowChartEmf_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetZhouQi_(struct soap *soap, struct __ns1__GetZhouQi_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetZhouQi = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetZhouQi_(struct soap *soap, const struct __ns1__GetZhouQi_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetZhouQi(soap, &a->ns1__GetZhouQi);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetZhouQi_(struct soap *soap, const char *tag, int id, const struct __ns1__GetZhouQi_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetZhouQi(soap, "ns1:GetZhouQi", -1, &a->ns1__GetZhouQi, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetZhouQi_ * SOAP_FMAC4 soap_in___ns1__GetZhouQi_(struct soap *soap, const char *tag, struct __ns1__GetZhouQi_ *a, const char *type)
{
	size_t soap_flag_ns1__GetZhouQi = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetZhouQi_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetZhouQi_, sizeof(struct __ns1__GetZhouQi_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetZhouQi_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetZhouQi && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetZhouQi(soap, "ns1:GetZhouQi", &a->ns1__GetZhouQi, ""))
				{	soap_flag_ns1__GetZhouQi--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetZhouQi_ * SOAP_FMAC2 soap_instantiate___ns1__GetZhouQi_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetZhouQi_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetZhouQi_ *p;
	size_t k = sizeof(struct __ns1__GetZhouQi_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetZhouQi_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetZhouQi_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetZhouQi_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetZhouQi_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetZhouQi_(struct soap *soap, const struct __ns1__GetZhouQi_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetZhouQi_(soap, tag ? tag : "-ns1:GetZhouQi", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetZhouQi_ * SOAP_FMAC4 soap_get___ns1__GetZhouQi_(struct soap *soap, struct __ns1__GetZhouQi_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetZhouQi_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__JiChaoQi_(struct soap *soap, struct __ns1__JiChaoQi_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__JiChaoQi = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__JiChaoQi_(struct soap *soap, const struct __ns1__JiChaoQi_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__JiChaoQi(soap, &a->ns1__JiChaoQi);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__JiChaoQi_(struct soap *soap, const char *tag, int id, const struct __ns1__JiChaoQi_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__JiChaoQi(soap, "ns1:JiChaoQi", -1, &a->ns1__JiChaoQi, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__JiChaoQi_ * SOAP_FMAC4 soap_in___ns1__JiChaoQi_(struct soap *soap, const char *tag, struct __ns1__JiChaoQi_ *a, const char *type)
{
	size_t soap_flag_ns1__JiChaoQi = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__JiChaoQi_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__JiChaoQi_, sizeof(struct __ns1__JiChaoQi_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__JiChaoQi_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__JiChaoQi && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__JiChaoQi(soap, "ns1:JiChaoQi", &a->ns1__JiChaoQi, ""))
				{	soap_flag_ns1__JiChaoQi--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__JiChaoQi_ * SOAP_FMAC2 soap_instantiate___ns1__JiChaoQi_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__JiChaoQi_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__JiChaoQi_ *p;
	size_t k = sizeof(struct __ns1__JiChaoQi_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__JiChaoQi_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__JiChaoQi_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__JiChaoQi_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__JiChaoQi_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__JiChaoQi_(struct soap *soap, const struct __ns1__JiChaoQi_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__JiChaoQi_(soap, tag ? tag : "-ns1:JiChaoQi", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__JiChaoQi_ * SOAP_FMAC4 soap_get___ns1__JiChaoQi_(struct soap *soap, struct __ns1__JiChaoQi_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__JiChaoQi_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ChaoQi_(struct soap *soap, struct __ns1__ChaoQi_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ChaoQi = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ChaoQi_(struct soap *soap, const struct __ns1__ChaoQi_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ChaoQi(soap, &a->ns1__ChaoQi);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ChaoQi_(struct soap *soap, const char *tag, int id, const struct __ns1__ChaoQi_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ChaoQi(soap, "ns1:ChaoQi", -1, &a->ns1__ChaoQi, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChaoQi_ * SOAP_FMAC4 soap_in___ns1__ChaoQi_(struct soap *soap, const char *tag, struct __ns1__ChaoQi_ *a, const char *type)
{
	size_t soap_flag_ns1__ChaoQi = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ChaoQi_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ChaoQi_, sizeof(struct __ns1__ChaoQi_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ChaoQi_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ChaoQi && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ChaoQi(soap, "ns1:ChaoQi", &a->ns1__ChaoQi, ""))
				{	soap_flag_ns1__ChaoQi--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ChaoQi_ * SOAP_FMAC2 soap_instantiate___ns1__ChaoQi_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ChaoQi_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ChaoQi_ *p;
	size_t k = sizeof(struct __ns1__ChaoQi_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ChaoQi_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ChaoQi_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ChaoQi_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ChaoQi_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ChaoQi_(struct soap *soap, const struct __ns1__ChaoQi_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ChaoQi_(soap, tag ? tag : "-ns1:ChaoQi", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChaoQi_ * SOAP_FMAC4 soap_get___ns1__ChaoQi_(struct soap *soap, struct __ns1__ChaoQi_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ChaoQi_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OpenMapExe_(struct soap *soap, struct __ns1__OpenMapExe_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OpenMapExe = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OpenMapExe_(struct soap *soap, const struct __ns1__OpenMapExe_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__OpenMapExe(soap, &a->ns1__OpenMapExe);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OpenMapExe_(struct soap *soap, const char *tag, int id, const struct __ns1__OpenMapExe_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__OpenMapExe(soap, "ns1:OpenMapExe", -1, &a->ns1__OpenMapExe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OpenMapExe_ * SOAP_FMAC4 soap_in___ns1__OpenMapExe_(struct soap *soap, const char *tag, struct __ns1__OpenMapExe_ *a, const char *type)
{
	size_t soap_flag_ns1__OpenMapExe = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__OpenMapExe_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OpenMapExe_, sizeof(struct __ns1__OpenMapExe_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OpenMapExe_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OpenMapExe && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__OpenMapExe(soap, "ns1:OpenMapExe", &a->ns1__OpenMapExe, ""))
				{	soap_flag_ns1__OpenMapExe--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__OpenMapExe_ * SOAP_FMAC2 soap_instantiate___ns1__OpenMapExe_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__OpenMapExe_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__OpenMapExe_ *p;
	size_t k = sizeof(struct __ns1__OpenMapExe_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__OpenMapExe_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__OpenMapExe_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__OpenMapExe_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__OpenMapExe_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OpenMapExe_(struct soap *soap, const struct __ns1__OpenMapExe_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__OpenMapExe_(soap, tag ? tag : "-ns1:OpenMapExe", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OpenMapExe_ * SOAP_FMAC4 soap_get___ns1__OpenMapExe_(struct soap *soap, struct __ns1__OpenMapExe_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OpenMapExe_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetEmfPngFile_(struct soap *soap, struct __ns1__GetEmfPngFile_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetEmfPngFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetEmfPngFile_(struct soap *soap, const struct __ns1__GetEmfPngFile_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetEmfPngFile(soap, &a->ns1__GetEmfPngFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetEmfPngFile_(struct soap *soap, const char *tag, int id, const struct __ns1__GetEmfPngFile_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetEmfPngFile(soap, "ns1:GetEmfPngFile", -1, &a->ns1__GetEmfPngFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetEmfPngFile_ * SOAP_FMAC4 soap_in___ns1__GetEmfPngFile_(struct soap *soap, const char *tag, struct __ns1__GetEmfPngFile_ *a, const char *type)
{
	size_t soap_flag_ns1__GetEmfPngFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetEmfPngFile_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetEmfPngFile_, sizeof(struct __ns1__GetEmfPngFile_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetEmfPngFile_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetEmfPngFile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetEmfPngFile(soap, "ns1:GetEmfPngFile", &a->ns1__GetEmfPngFile, ""))
				{	soap_flag_ns1__GetEmfPngFile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetEmfPngFile_ * SOAP_FMAC2 soap_instantiate___ns1__GetEmfPngFile_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetEmfPngFile_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetEmfPngFile_ *p;
	size_t k = sizeof(struct __ns1__GetEmfPngFile_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetEmfPngFile_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetEmfPngFile_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetEmfPngFile_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetEmfPngFile_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetEmfPngFile_(struct soap *soap, const struct __ns1__GetEmfPngFile_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetEmfPngFile_(soap, tag ? tag : "-ns1:GetEmfPngFile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetEmfPngFile_ * SOAP_FMAC4 soap_get___ns1__GetEmfPngFile_(struct soap *soap, struct __ns1__GetEmfPngFile_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetEmfPngFile_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetEmfPngVer_(struct soap *soap, struct __ns1__GetEmfPngVer_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetEmfPngVer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetEmfPngVer_(struct soap *soap, const struct __ns1__GetEmfPngVer_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetEmfPngVer(soap, &a->ns1__GetEmfPngVer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetEmfPngVer_(struct soap *soap, const char *tag, int id, const struct __ns1__GetEmfPngVer_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetEmfPngVer(soap, "ns1:GetEmfPngVer", -1, &a->ns1__GetEmfPngVer, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetEmfPngVer_ * SOAP_FMAC4 soap_in___ns1__GetEmfPngVer_(struct soap *soap, const char *tag, struct __ns1__GetEmfPngVer_ *a, const char *type)
{
	size_t soap_flag_ns1__GetEmfPngVer = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetEmfPngVer_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetEmfPngVer_, sizeof(struct __ns1__GetEmfPngVer_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetEmfPngVer_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetEmfPngVer && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetEmfPngVer(soap, "ns1:GetEmfPngVer", &a->ns1__GetEmfPngVer, ""))
				{	soap_flag_ns1__GetEmfPngVer--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetEmfPngVer_ * SOAP_FMAC2 soap_instantiate___ns1__GetEmfPngVer_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetEmfPngVer_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetEmfPngVer_ *p;
	size_t k = sizeof(struct __ns1__GetEmfPngVer_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetEmfPngVer_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetEmfPngVer_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetEmfPngVer_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetEmfPngVer_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetEmfPngVer_(struct soap *soap, const struct __ns1__GetEmfPngVer_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetEmfPngVer_(soap, tag ? tag : "-ns1:GetEmfPngVer", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetEmfPngVer_ * SOAP_FMAC4 soap_get___ns1__GetEmfPngVer_(struct soap *soap, struct __ns1__GetEmfPngVer_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetEmfPngVer_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OpenProcess_(struct soap *soap, struct __ns1__OpenProcess_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OpenProcess = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OpenProcess_(struct soap *soap, const struct __ns1__OpenProcess_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__OpenProcess(soap, &a->ns1__OpenProcess);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OpenProcess_(struct soap *soap, const char *tag, int id, const struct __ns1__OpenProcess_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__OpenProcess(soap, "ns1:OpenProcess", -1, &a->ns1__OpenProcess, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OpenProcess_ * SOAP_FMAC4 soap_in___ns1__OpenProcess_(struct soap *soap, const char *tag, struct __ns1__OpenProcess_ *a, const char *type)
{
	size_t soap_flag_ns1__OpenProcess = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__OpenProcess_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OpenProcess_, sizeof(struct __ns1__OpenProcess_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OpenProcess_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OpenProcess && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__OpenProcess(soap, "ns1:OpenProcess", &a->ns1__OpenProcess, ""))
				{	soap_flag_ns1__OpenProcess--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__OpenProcess_ * SOAP_FMAC2 soap_instantiate___ns1__OpenProcess_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__OpenProcess_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__OpenProcess_ *p;
	size_t k = sizeof(struct __ns1__OpenProcess_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__OpenProcess_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__OpenProcess_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__OpenProcess_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__OpenProcess_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OpenProcess_(struct soap *soap, const struct __ns1__OpenProcess_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__OpenProcess_(soap, tag ? tag : "-ns1:OpenProcess", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OpenProcess_ * SOAP_FMAC4 soap_get___ns1__OpenProcess_(struct soap *soap, struct __ns1__OpenProcess_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OpenProcess_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMangeMapUpdate_(struct soap *soap, struct __ns1__GetMangeMapUpdate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMangeMapUpdate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMangeMapUpdate_(struct soap *soap, const struct __ns1__GetMangeMapUpdate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMangeMapUpdate(soap, &a->ns1__GetMangeMapUpdate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMangeMapUpdate_(struct soap *soap, const char *tag, int id, const struct __ns1__GetMangeMapUpdate_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMangeMapUpdate(soap, "ns1:GetMangeMapUpdate", -1, &a->ns1__GetMangeMapUpdate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMangeMapUpdate_ * SOAP_FMAC4 soap_in___ns1__GetMangeMapUpdate_(struct soap *soap, const char *tag, struct __ns1__GetMangeMapUpdate_ *a, const char *type)
{
	size_t soap_flag_ns1__GetMangeMapUpdate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMangeMapUpdate_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMangeMapUpdate_, sizeof(struct __ns1__GetMangeMapUpdate_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMangeMapUpdate_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMangeMapUpdate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMangeMapUpdate(soap, "ns1:GetMangeMapUpdate", &a->ns1__GetMangeMapUpdate, ""))
				{	soap_flag_ns1__GetMangeMapUpdate--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMangeMapUpdate_ * SOAP_FMAC2 soap_instantiate___ns1__GetMangeMapUpdate_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMangeMapUpdate_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMangeMapUpdate_ *p;
	size_t k = sizeof(struct __ns1__GetMangeMapUpdate_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetMangeMapUpdate_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetMangeMapUpdate_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetMangeMapUpdate_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMangeMapUpdate_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMangeMapUpdate_(struct soap *soap, const struct __ns1__GetMangeMapUpdate_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMangeMapUpdate_(soap, tag ? tag : "-ns1:GetMangeMapUpdate", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMangeMapUpdate_ * SOAP_FMAC4 soap_get___ns1__GetMangeMapUpdate_(struct soap *soap, struct __ns1__GetMangeMapUpdate_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMangeMapUpdate_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetUnitMapVer_(struct soap *soap, struct __ns1__GetUnitMapVer_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetUnitMapVer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetUnitMapVer_(struct soap *soap, const struct __ns1__GetUnitMapVer_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetUnitMapVer(soap, &a->ns1__GetUnitMapVer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetUnitMapVer_(struct soap *soap, const char *tag, int id, const struct __ns1__GetUnitMapVer_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetUnitMapVer(soap, "ns1:GetUnitMapVer", -1, &a->ns1__GetUnitMapVer, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUnitMapVer_ * SOAP_FMAC4 soap_in___ns1__GetUnitMapVer_(struct soap *soap, const char *tag, struct __ns1__GetUnitMapVer_ *a, const char *type)
{
	size_t soap_flag_ns1__GetUnitMapVer = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetUnitMapVer_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetUnitMapVer_, sizeof(struct __ns1__GetUnitMapVer_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetUnitMapVer_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetUnitMapVer && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetUnitMapVer(soap, "ns1:GetUnitMapVer", &a->ns1__GetUnitMapVer, ""))
				{	soap_flag_ns1__GetUnitMapVer--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetUnitMapVer_ * SOAP_FMAC2 soap_instantiate___ns1__GetUnitMapVer_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetUnitMapVer_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetUnitMapVer_ *p;
	size_t k = sizeof(struct __ns1__GetUnitMapVer_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetUnitMapVer_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetUnitMapVer_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetUnitMapVer_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetUnitMapVer_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetUnitMapVer_(struct soap *soap, const struct __ns1__GetUnitMapVer_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetUnitMapVer_(soap, tag ? tag : "-ns1:GetUnitMapVer", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUnitMapVer_ * SOAP_FMAC4 soap_get___ns1__GetUnitMapVer_(struct soap *soap, struct __ns1__GetUnitMapVer_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetUnitMapVer_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdateGzclMap_(struct soap *soap, struct __ns1__UpdateGzclMap_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateGzclMap = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdateGzclMap_(struct soap *soap, const struct __ns1__UpdateGzclMap_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UpdateGzclMap(soap, &a->ns1__UpdateGzclMap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdateGzclMap_(struct soap *soap, const char *tag, int id, const struct __ns1__UpdateGzclMap_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UpdateGzclMap(soap, "ns1:UpdateGzclMap", -1, &a->ns1__UpdateGzclMap, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateGzclMap_ * SOAP_FMAC4 soap_in___ns1__UpdateGzclMap_(struct soap *soap, const char *tag, struct __ns1__UpdateGzclMap_ *a, const char *type)
{
	size_t soap_flag_ns1__UpdateGzclMap = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UpdateGzclMap_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpdateGzclMap_, sizeof(struct __ns1__UpdateGzclMap_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdateGzclMap_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateGzclMap && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__UpdateGzclMap(soap, "ns1:UpdateGzclMap", &a->ns1__UpdateGzclMap, ""))
				{	soap_flag_ns1__UpdateGzclMap--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__UpdateGzclMap_ * SOAP_FMAC2 soap_instantiate___ns1__UpdateGzclMap_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdateGzclMap_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UpdateGzclMap_ *p;
	size_t k = sizeof(struct __ns1__UpdateGzclMap_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__UpdateGzclMap_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__UpdateGzclMap_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__UpdateGzclMap_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UpdateGzclMap_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdateGzclMap_(struct soap *soap, const struct __ns1__UpdateGzclMap_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UpdateGzclMap_(soap, tag ? tag : "-ns1:UpdateGzclMap", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateGzclMap_ * SOAP_FMAC4 soap_get___ns1__UpdateGzclMap_(struct soap *soap, struct __ns1__UpdateGzclMap_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdateGzclMap_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMapListTime_(struct soap *soap, struct __ns1__GetMapListTime_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMapListTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMapListTime_(struct soap *soap, const struct __ns1__GetMapListTime_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMapListTime(soap, &a->ns1__GetMapListTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMapListTime_(struct soap *soap, const char *tag, int id, const struct __ns1__GetMapListTime_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMapListTime(soap, "ns1:GetMapListTime", -1, &a->ns1__GetMapListTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMapListTime_ * SOAP_FMAC4 soap_in___ns1__GetMapListTime_(struct soap *soap, const char *tag, struct __ns1__GetMapListTime_ *a, const char *type)
{
	size_t soap_flag_ns1__GetMapListTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMapListTime_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMapListTime_, sizeof(struct __ns1__GetMapListTime_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMapListTime_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMapListTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMapListTime(soap, "ns1:GetMapListTime", &a->ns1__GetMapListTime, ""))
				{	soap_flag_ns1__GetMapListTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMapListTime_ * SOAP_FMAC2 soap_instantiate___ns1__GetMapListTime_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMapListTime_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMapListTime_ *p;
	size_t k = sizeof(struct __ns1__GetMapListTime_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetMapListTime_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetMapListTime_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetMapListTime_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMapListTime_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMapListTime_(struct soap *soap, const struct __ns1__GetMapListTime_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMapListTime_(soap, tag ? tag : "-ns1:GetMapListTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMapListTime_ * SOAP_FMAC4 soap_get___ns1__GetMapListTime_(struct soap *soap, struct __ns1__GetMapListTime_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMapListTime_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ServerLevel_(struct soap *soap, struct __ns1__ServerLevel_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ServerLevel = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ServerLevel_(struct soap *soap, const struct __ns1__ServerLevel_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ServerLevel(soap, &a->ns1__ServerLevel);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ServerLevel_(struct soap *soap, const char *tag, int id, const struct __ns1__ServerLevel_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ServerLevel(soap, "ns1:ServerLevel", -1, &a->ns1__ServerLevel, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ServerLevel_ * SOAP_FMAC4 soap_in___ns1__ServerLevel_(struct soap *soap, const char *tag, struct __ns1__ServerLevel_ *a, const char *type)
{
	size_t soap_flag_ns1__ServerLevel = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ServerLevel_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ServerLevel_, sizeof(struct __ns1__ServerLevel_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ServerLevel_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ServerLevel && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ServerLevel(soap, "ns1:ServerLevel", &a->ns1__ServerLevel, ""))
				{	soap_flag_ns1__ServerLevel--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ServerLevel_ * SOAP_FMAC2 soap_instantiate___ns1__ServerLevel_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ServerLevel_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ServerLevel_ *p;
	size_t k = sizeof(struct __ns1__ServerLevel_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ServerLevel_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ServerLevel_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ServerLevel_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ServerLevel_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ServerLevel_(struct soap *soap, const struct __ns1__ServerLevel_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ServerLevel_(soap, tag ? tag : "-ns1:ServerLevel", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ServerLevel_ * SOAP_FMAC4 soap_get___ns1__ServerLevel_(struct soap *soap, struct __ns1__ServerLevel_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ServerLevel_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetTableData_(struct soap *soap, struct __ns1__GetTableData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetTableData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetTableData_(struct soap *soap, const struct __ns1__GetTableData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetTableData(soap, &a->ns1__GetTableData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetTableData_(struct soap *soap, const char *tag, int id, const struct __ns1__GetTableData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetTableData(soap, "ns1:GetTableData", -1, &a->ns1__GetTableData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTableData_ * SOAP_FMAC4 soap_in___ns1__GetTableData_(struct soap *soap, const char *tag, struct __ns1__GetTableData_ *a, const char *type)
{
	size_t soap_flag_ns1__GetTableData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetTableData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetTableData_, sizeof(struct __ns1__GetTableData_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetTableData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetTableData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetTableData(soap, "ns1:GetTableData", &a->ns1__GetTableData, ""))
				{	soap_flag_ns1__GetTableData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetTableData_ * SOAP_FMAC2 soap_instantiate___ns1__GetTableData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetTableData_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetTableData_ *p;
	size_t k = sizeof(struct __ns1__GetTableData_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetTableData_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetTableData_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetTableData_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetTableData_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetTableData_(struct soap *soap, const struct __ns1__GetTableData_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetTableData_(soap, tag ? tag : "-ns1:GetTableData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTableData_ * SOAP_FMAC4 soap_get___ns1__GetTableData_(struct soap *soap, struct __ns1__GetTableData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetTableData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMap_(struct soap *soap, struct __ns1__GetMap_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMap = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMap_(struct soap *soap, const struct __ns1__GetMap_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMap(soap, &a->ns1__GetMap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMap_(struct soap *soap, const char *tag, int id, const struct __ns1__GetMap_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMap(soap, "ns1:GetMap", -1, &a->ns1__GetMap, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMap_ * SOAP_FMAC4 soap_in___ns1__GetMap_(struct soap *soap, const char *tag, struct __ns1__GetMap_ *a, const char *type)
{
	size_t soap_flag_ns1__GetMap = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMap_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMap_, sizeof(struct __ns1__GetMap_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMap_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMap && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMap(soap, "ns1:GetMap", &a->ns1__GetMap, ""))
				{	soap_flag_ns1__GetMap--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMap_ * SOAP_FMAC2 soap_instantiate___ns1__GetMap_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMap_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMap_ *p;
	size_t k = sizeof(struct __ns1__GetMap_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetMap_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetMap_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetMap_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMap_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMap_(struct soap *soap, const struct __ns1__GetMap_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMap_(soap, tag ? tag : "-ns1:GetMap", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMap_ * SOAP_FMAC4 soap_get___ns1__GetMap_(struct soap *soap, struct __ns1__GetMap_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMap_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CheckMapVer_(struct soap *soap, struct __ns1__CheckMapVer_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CheckMapVer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CheckMapVer_(struct soap *soap, const struct __ns1__CheckMapVer_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CheckMapVer(soap, &a->ns1__CheckMapVer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CheckMapVer_(struct soap *soap, const char *tag, int id, const struct __ns1__CheckMapVer_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CheckMapVer(soap, "ns1:CheckMapVer", -1, &a->ns1__CheckMapVer, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckMapVer_ * SOAP_FMAC4 soap_in___ns1__CheckMapVer_(struct soap *soap, const char *tag, struct __ns1__CheckMapVer_ *a, const char *type)
{
	size_t soap_flag_ns1__CheckMapVer = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CheckMapVer_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CheckMapVer_, sizeof(struct __ns1__CheckMapVer_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CheckMapVer_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CheckMapVer && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CheckMapVer(soap, "ns1:CheckMapVer", &a->ns1__CheckMapVer, ""))
				{	soap_flag_ns1__CheckMapVer--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CheckMapVer_ * SOAP_FMAC2 soap_instantiate___ns1__CheckMapVer_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CheckMapVer_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CheckMapVer_ *p;
	size_t k = sizeof(struct __ns1__CheckMapVer_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__CheckMapVer_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__CheckMapVer_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__CheckMapVer_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CheckMapVer_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CheckMapVer_(struct soap *soap, const struct __ns1__CheckMapVer_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CheckMapVer_(soap, tag ? tag : "-ns1:CheckMapVer", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckMapVer_ * SOAP_FMAC4 soap_get___ns1__CheckMapVer_(struct soap *soap, struct __ns1__CheckMapVer_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CheckMapVer_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMangeXb_(struct soap *soap, struct __ns1__GetMangeXb_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMangeXb = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMangeXb_(struct soap *soap, const struct __ns1__GetMangeXb_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMangeXb(soap, &a->ns1__GetMangeXb);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMangeXb_(struct soap *soap, const char *tag, int id, const struct __ns1__GetMangeXb_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMangeXb(soap, "ns1:GetMangeXb", -1, &a->ns1__GetMangeXb, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMangeXb_ * SOAP_FMAC4 soap_in___ns1__GetMangeXb_(struct soap *soap, const char *tag, struct __ns1__GetMangeXb_ *a, const char *type)
{
	size_t soap_flag_ns1__GetMangeXb = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMangeXb_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMangeXb_, sizeof(struct __ns1__GetMangeXb_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMangeXb_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMangeXb && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMangeXb(soap, "ns1:GetMangeXb", &a->ns1__GetMangeXb, ""))
				{	soap_flag_ns1__GetMangeXb--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMangeXb_ * SOAP_FMAC2 soap_instantiate___ns1__GetMangeXb_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMangeXb_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMangeXb_ *p;
	size_t k = sizeof(struct __ns1__GetMangeXb_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetMangeXb_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetMangeXb_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetMangeXb_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMangeXb_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMangeXb_(struct soap *soap, const struct __ns1__GetMangeXb_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMangeXb_(soap, tag ? tag : "-ns1:GetMangeXb", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMangeXb_ * SOAP_FMAC4 soap_get___ns1__GetMangeXb_(struct soap *soap, struct __ns1__GetMangeXb_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMangeXb_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMangeUnit_(struct soap *soap, struct __ns1__GetMangeUnit_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMangeUnit = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMangeUnit_(struct soap *soap, const struct __ns1__GetMangeUnit_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMangeUnit(soap, &a->ns1__GetMangeUnit);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMangeUnit_(struct soap *soap, const char *tag, int id, const struct __ns1__GetMangeUnit_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMangeUnit(soap, "ns1:GetMangeUnit", -1, &a->ns1__GetMangeUnit, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMangeUnit_ * SOAP_FMAC4 soap_in___ns1__GetMangeUnit_(struct soap *soap, const char *tag, struct __ns1__GetMangeUnit_ *a, const char *type)
{
	size_t soap_flag_ns1__GetMangeUnit = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMangeUnit_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMangeUnit_, sizeof(struct __ns1__GetMangeUnit_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMangeUnit_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMangeUnit && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMangeUnit(soap, "ns1:GetMangeUnit", &a->ns1__GetMangeUnit, ""))
				{	soap_flag_ns1__GetMangeUnit--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMangeUnit_ * SOAP_FMAC2 soap_instantiate___ns1__GetMangeUnit_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMangeUnit_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMangeUnit_ *p;
	size_t k = sizeof(struct __ns1__GetMangeUnit_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetMangeUnit_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetMangeUnit_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetMangeUnit_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMangeUnit_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMangeUnit_(struct soap *soap, const struct __ns1__GetMangeUnit_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMangeUnit_(soap, tag ? tag : "-ns1:GetMangeUnit", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMangeUnit_ * SOAP_FMAC4 soap_get___ns1__GetMangeUnit_(struct soap *soap, struct __ns1__GetMangeUnit_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMangeUnit_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMaList_(struct soap *soap, struct __ns1__GetMaList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMaList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMaList_(struct soap *soap, const struct __ns1__GetMaList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMaList(soap, &a->ns1__GetMaList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMaList_(struct soap *soap, const char *tag, int id, const struct __ns1__GetMaList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMaList(soap, "ns1:GetMaList", -1, &a->ns1__GetMaList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMaList_ * SOAP_FMAC4 soap_in___ns1__GetMaList_(struct soap *soap, const char *tag, struct __ns1__GetMaList_ *a, const char *type)
{
	size_t soap_flag_ns1__GetMaList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMaList_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMaList_, sizeof(struct __ns1__GetMaList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMaList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMaList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMaList(soap, "ns1:GetMaList", &a->ns1__GetMaList, ""))
				{	soap_flag_ns1__GetMaList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMaList_ * SOAP_FMAC2 soap_instantiate___ns1__GetMaList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMaList_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMaList_ *p;
	size_t k = sizeof(struct __ns1__GetMaList_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetMaList_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetMaList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetMaList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMaList_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMaList_(struct soap *soap, const struct __ns1__GetMaList_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMaList_(soap, tag ? tag : "-ns1:GetMaList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMaList_ * SOAP_FMAC4 soap_get___ns1__GetMaList_(struct soap *soap, struct __ns1__GetMaList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMaList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMapDeviceData_(struct soap *soap, struct __ns1__GetMapDeviceData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMapDeviceData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMapDeviceData_(struct soap *soap, const struct __ns1__GetMapDeviceData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMapDeviceData(soap, &a->ns1__GetMapDeviceData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMapDeviceData_(struct soap *soap, const char *tag, int id, const struct __ns1__GetMapDeviceData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMapDeviceData(soap, "ns1:GetMapDeviceData", -1, &a->ns1__GetMapDeviceData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMapDeviceData_ * SOAP_FMAC4 soap_in___ns1__GetMapDeviceData_(struct soap *soap, const char *tag, struct __ns1__GetMapDeviceData_ *a, const char *type)
{
	size_t soap_flag_ns1__GetMapDeviceData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMapDeviceData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMapDeviceData_, sizeof(struct __ns1__GetMapDeviceData_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMapDeviceData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMapDeviceData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMapDeviceData(soap, "ns1:GetMapDeviceData", &a->ns1__GetMapDeviceData, ""))
				{	soap_flag_ns1__GetMapDeviceData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMapDeviceData_ * SOAP_FMAC2 soap_instantiate___ns1__GetMapDeviceData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMapDeviceData_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMapDeviceData_ *p;
	size_t k = sizeof(struct __ns1__GetMapDeviceData_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetMapDeviceData_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetMapDeviceData_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetMapDeviceData_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMapDeviceData_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMapDeviceData_(struct soap *soap, const struct __ns1__GetMapDeviceData_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMapDeviceData_(soap, tag ? tag : "-ns1:GetMapDeviceData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMapDeviceData_ * SOAP_FMAC4 soap_get___ns1__GetMapDeviceData_(struct soap *soap, struct __ns1__GetMapDeviceData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMapDeviceData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMapTabName_(struct soap *soap, struct __ns1__GetMapTabName_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMapTabName = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMapTabName_(struct soap *soap, const struct __ns1__GetMapTabName_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMapTabName(soap, &a->ns1__GetMapTabName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMapTabName_(struct soap *soap, const char *tag, int id, const struct __ns1__GetMapTabName_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMapTabName(soap, "ns1:GetMapTabName", -1, &a->ns1__GetMapTabName, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMapTabName_ * SOAP_FMAC4 soap_in___ns1__GetMapTabName_(struct soap *soap, const char *tag, struct __ns1__GetMapTabName_ *a, const char *type)
{
	size_t soap_flag_ns1__GetMapTabName = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMapTabName_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMapTabName_, sizeof(struct __ns1__GetMapTabName_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMapTabName_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMapTabName && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMapTabName(soap, "ns1:GetMapTabName", &a->ns1__GetMapTabName, ""))
				{	soap_flag_ns1__GetMapTabName--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMapTabName_ * SOAP_FMAC2 soap_instantiate___ns1__GetMapTabName_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMapTabName_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMapTabName_ *p;
	size_t k = sizeof(struct __ns1__GetMapTabName_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetMapTabName_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetMapTabName_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetMapTabName_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMapTabName_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMapTabName_(struct soap *soap, const struct __ns1__GetMapTabName_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMapTabName_(soap, tag ? tag : "-ns1:GetMapTabName", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMapTabName_ * SOAP_FMAC4 soap_get___ns1__GetMapTabName_(struct soap *soap, struct __ns1__GetMapTabName_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMapTabName_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMapUpdateTime_(struct soap *soap, struct __ns1__GetMapUpdateTime_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMapUpdateTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMapUpdateTime_(struct soap *soap, const struct __ns1__GetMapUpdateTime_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMapUpdateTime(soap, &a->ns1__GetMapUpdateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMapUpdateTime_(struct soap *soap, const char *tag, int id, const struct __ns1__GetMapUpdateTime_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMapUpdateTime(soap, "ns1:GetMapUpdateTime", -1, &a->ns1__GetMapUpdateTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMapUpdateTime_ * SOAP_FMAC4 soap_in___ns1__GetMapUpdateTime_(struct soap *soap, const char *tag, struct __ns1__GetMapUpdateTime_ *a, const char *type)
{
	size_t soap_flag_ns1__GetMapUpdateTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMapUpdateTime_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMapUpdateTime_, sizeof(struct __ns1__GetMapUpdateTime_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMapUpdateTime_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMapUpdateTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMapUpdateTime(soap, "ns1:GetMapUpdateTime", &a->ns1__GetMapUpdateTime, ""))
				{	soap_flag_ns1__GetMapUpdateTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMapUpdateTime_ * SOAP_FMAC2 soap_instantiate___ns1__GetMapUpdateTime_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMapUpdateTime_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMapUpdateTime_ *p;
	size_t k = sizeof(struct __ns1__GetMapUpdateTime_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetMapUpdateTime_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetMapUpdateTime_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetMapUpdateTime_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMapUpdateTime_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMapUpdateTime_(struct soap *soap, const struct __ns1__GetMapUpdateTime_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMapUpdateTime_(soap, tag ? tag : "-ns1:GetMapUpdateTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMapUpdateTime_ * SOAP_FMAC4 soap_get___ns1__GetMapUpdateTime_(struct soap *soap, struct __ns1__GetMapUpdateTime_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMapUpdateTime_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__WriteFile_(struct soap *soap, struct __ns1__WriteFile_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__WriteFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__WriteFile_(struct soap *soap, const struct __ns1__WriteFile_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__WriteFile(soap, &a->ns1__WriteFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__WriteFile_(struct soap *soap, const char *tag, int id, const struct __ns1__WriteFile_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__WriteFile(soap, "ns1:WriteFile", -1, &a->ns1__WriteFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__WriteFile_ * SOAP_FMAC4 soap_in___ns1__WriteFile_(struct soap *soap, const char *tag, struct __ns1__WriteFile_ *a, const char *type)
{
	size_t soap_flag_ns1__WriteFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__WriteFile_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__WriteFile_, sizeof(struct __ns1__WriteFile_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__WriteFile_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__WriteFile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__WriteFile(soap, "ns1:WriteFile", &a->ns1__WriteFile, ""))
				{	soap_flag_ns1__WriteFile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__WriteFile_ * SOAP_FMAC2 soap_instantiate___ns1__WriteFile_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__WriteFile_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__WriteFile_ *p;
	size_t k = sizeof(struct __ns1__WriteFile_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__WriteFile_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__WriteFile_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__WriteFile_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__WriteFile_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__WriteFile_(struct soap *soap, const struct __ns1__WriteFile_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__WriteFile_(soap, tag ? tag : "-ns1:WriteFile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__WriteFile_ * SOAP_FMAC4 soap_get___ns1__WriteFile_(struct soap *soap, struct __ns1__WriteFile_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__WriteFile_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DownLoadFile_(struct soap *soap, struct __ns1__DownLoadFile_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DownLoadFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DownLoadFile_(struct soap *soap, const struct __ns1__DownLoadFile_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DownLoadFile(soap, &a->ns1__DownLoadFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DownLoadFile_(struct soap *soap, const char *tag, int id, const struct __ns1__DownLoadFile_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DownLoadFile(soap, "ns1:DownLoadFile", -1, &a->ns1__DownLoadFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownLoadFile_ * SOAP_FMAC4 soap_in___ns1__DownLoadFile_(struct soap *soap, const char *tag, struct __ns1__DownLoadFile_ *a, const char *type)
{
	size_t soap_flag_ns1__DownLoadFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DownLoadFile_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DownLoadFile_, sizeof(struct __ns1__DownLoadFile_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DownLoadFile_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DownLoadFile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__DownLoadFile(soap, "ns1:DownLoadFile", &a->ns1__DownLoadFile, ""))
				{	soap_flag_ns1__DownLoadFile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DownLoadFile_ * SOAP_FMAC2 soap_instantiate___ns1__DownLoadFile_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DownLoadFile_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DownLoadFile_ *p;
	size_t k = sizeof(struct __ns1__DownLoadFile_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__DownLoadFile_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__DownLoadFile_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__DownLoadFile_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DownLoadFile_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DownLoadFile_(struct soap *soap, const struct __ns1__DownLoadFile_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DownLoadFile_(soap, tag ? tag : "-ns1:DownLoadFile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownLoadFile_ * SOAP_FMAC4 soap_get___ns1__DownLoadFile_(struct soap *soap, struct __ns1__DownLoadFile_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DownLoadFile_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ExecuteSqlForFile_(struct soap *soap, struct __ns1__ExecuteSqlForFile_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ExecuteSqlForFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ExecuteSqlForFile_(struct soap *soap, const struct __ns1__ExecuteSqlForFile_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ExecuteSqlForFile(soap, &a->ns1__ExecuteSqlForFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ExecuteSqlForFile_(struct soap *soap, const char *tag, int id, const struct __ns1__ExecuteSqlForFile_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ExecuteSqlForFile(soap, "ns1:ExecuteSqlForFile", -1, &a->ns1__ExecuteSqlForFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExecuteSqlForFile_ * SOAP_FMAC4 soap_in___ns1__ExecuteSqlForFile_(struct soap *soap, const char *tag, struct __ns1__ExecuteSqlForFile_ *a, const char *type)
{
	size_t soap_flag_ns1__ExecuteSqlForFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ExecuteSqlForFile_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ExecuteSqlForFile_, sizeof(struct __ns1__ExecuteSqlForFile_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ExecuteSqlForFile_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ExecuteSqlForFile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ExecuteSqlForFile(soap, "ns1:ExecuteSqlForFile", &a->ns1__ExecuteSqlForFile, ""))
				{	soap_flag_ns1__ExecuteSqlForFile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ExecuteSqlForFile_ * SOAP_FMAC2 soap_instantiate___ns1__ExecuteSqlForFile_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ExecuteSqlForFile_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ExecuteSqlForFile_ *p;
	size_t k = sizeof(struct __ns1__ExecuteSqlForFile_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ExecuteSqlForFile_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ExecuteSqlForFile_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ExecuteSqlForFile_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ExecuteSqlForFile_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ExecuteSqlForFile_(struct soap *soap, const struct __ns1__ExecuteSqlForFile_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ExecuteSqlForFile_(soap, tag ? tag : "-ns1:ExecuteSqlForFile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExecuteSqlForFile_ * SOAP_FMAC4 soap_get___ns1__ExecuteSqlForFile_(struct soap *soap, struct __ns1__ExecuteSqlForFile_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ExecuteSqlForFile_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetFieldInfo_(struct soap *soap, struct __ns1__GetFieldInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetFieldInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetFieldInfo_(struct soap *soap, const struct __ns1__GetFieldInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetFieldInfo(soap, &a->ns1__GetFieldInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetFieldInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__GetFieldInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetFieldInfo(soap, "ns1:GetFieldInfo", -1, &a->ns1__GetFieldInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFieldInfo_ * SOAP_FMAC4 soap_in___ns1__GetFieldInfo_(struct soap *soap, const char *tag, struct __ns1__GetFieldInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__GetFieldInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetFieldInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetFieldInfo_, sizeof(struct __ns1__GetFieldInfo_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetFieldInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetFieldInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetFieldInfo(soap, "ns1:GetFieldInfo", &a->ns1__GetFieldInfo, ""))
				{	soap_flag_ns1__GetFieldInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetFieldInfo_ * SOAP_FMAC2 soap_instantiate___ns1__GetFieldInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetFieldInfo_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetFieldInfo_ *p;
	size_t k = sizeof(struct __ns1__GetFieldInfo_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetFieldInfo_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetFieldInfo_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetFieldInfo_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetFieldInfo_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetFieldInfo_(struct soap *soap, const struct __ns1__GetFieldInfo_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetFieldInfo_(soap, tag ? tag : "-ns1:GetFieldInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFieldInfo_ * SOAP_FMAC4 soap_get___ns1__GetFieldInfo_(struct soap *soap, struct __ns1__GetFieldInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetFieldInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__IsOracleTable_(struct soap *soap, struct __ns1__IsOracleTable_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__IsOracleTable = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__IsOracleTable_(struct soap *soap, const struct __ns1__IsOracleTable_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__IsOracleTable(soap, &a->ns1__IsOracleTable);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__IsOracleTable_(struct soap *soap, const char *tag, int id, const struct __ns1__IsOracleTable_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__IsOracleTable(soap, "ns1:IsOracleTable", -1, &a->ns1__IsOracleTable, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__IsOracleTable_ * SOAP_FMAC4 soap_in___ns1__IsOracleTable_(struct soap *soap, const char *tag, struct __ns1__IsOracleTable_ *a, const char *type)
{
	size_t soap_flag_ns1__IsOracleTable = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__IsOracleTable_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__IsOracleTable_, sizeof(struct __ns1__IsOracleTable_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__IsOracleTable_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__IsOracleTable && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__IsOracleTable(soap, "ns1:IsOracleTable", &a->ns1__IsOracleTable, ""))
				{	soap_flag_ns1__IsOracleTable--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__IsOracleTable_ * SOAP_FMAC2 soap_instantiate___ns1__IsOracleTable_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__IsOracleTable_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__IsOracleTable_ *p;
	size_t k = sizeof(struct __ns1__IsOracleTable_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__IsOracleTable_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__IsOracleTable_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__IsOracleTable_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__IsOracleTable_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__IsOracleTable_(struct soap *soap, const struct __ns1__IsOracleTable_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__IsOracleTable_(soap, tag ? tag : "-ns1:IsOracleTable", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__IsOracleTable_ * SOAP_FMAC4 soap_get___ns1__IsOracleTable_(struct soap *soap, struct __ns1__IsOracleTable_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__IsOracleTable_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetTabList_(struct soap *soap, struct __ns1__GetTabList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetTabList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetTabList_(struct soap *soap, const struct __ns1__GetTabList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetTabList(soap, &a->ns1__GetTabList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetTabList_(struct soap *soap, const char *tag, int id, const struct __ns1__GetTabList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetTabList(soap, "ns1:GetTabList", -1, &a->ns1__GetTabList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTabList_ * SOAP_FMAC4 soap_in___ns1__GetTabList_(struct soap *soap, const char *tag, struct __ns1__GetTabList_ *a, const char *type)
{
	size_t soap_flag_ns1__GetTabList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetTabList_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetTabList_, sizeof(struct __ns1__GetTabList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetTabList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetTabList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetTabList(soap, "ns1:GetTabList", &a->ns1__GetTabList, ""))
				{	soap_flag_ns1__GetTabList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetTabList_ * SOAP_FMAC2 soap_instantiate___ns1__GetTabList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetTabList_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetTabList_ *p;
	size_t k = sizeof(struct __ns1__GetTabList_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetTabList_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetTabList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetTabList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetTabList_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetTabList_(struct soap *soap, const struct __ns1__GetTabList_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetTabList_(soap, tag ? tag : "-ns1:GetTabList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTabList_ * SOAP_FMAC4 soap_get___ns1__GetTabList_(struct soap *soap, struct __ns1__GetTabList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetTabList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DownCQData_(struct soap *soap, struct __ns1__DownCQData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DownCQData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DownCQData_(struct soap *soap, const struct __ns1__DownCQData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DownCQData(soap, &a->ns1__DownCQData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DownCQData_(struct soap *soap, const char *tag, int id, const struct __ns1__DownCQData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DownCQData(soap, "ns1:DownCQData", -1, &a->ns1__DownCQData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownCQData_ * SOAP_FMAC4 soap_in___ns1__DownCQData_(struct soap *soap, const char *tag, struct __ns1__DownCQData_ *a, const char *type)
{
	size_t soap_flag_ns1__DownCQData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DownCQData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DownCQData_, sizeof(struct __ns1__DownCQData_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DownCQData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DownCQData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__DownCQData(soap, "ns1:DownCQData", &a->ns1__DownCQData, ""))
				{	soap_flag_ns1__DownCQData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DownCQData_ * SOAP_FMAC2 soap_instantiate___ns1__DownCQData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DownCQData_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DownCQData_ *p;
	size_t k = sizeof(struct __ns1__DownCQData_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__DownCQData_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__DownCQData_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__DownCQData_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DownCQData_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DownCQData_(struct soap *soap, const struct __ns1__DownCQData_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DownCQData_(soap, tag ? tag : "-ns1:DownCQData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownCQData_ * SOAP_FMAC4 soap_get___ns1__DownCQData_(struct soap *soap, struct __ns1__DownCQData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DownCQData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__AlterTable_(struct soap *soap, struct __ns1__AlterTable_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AlterTable = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__AlterTable_(struct soap *soap, const struct __ns1__AlterTable_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__AlterTable(soap, &a->ns1__AlterTable);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__AlterTable_(struct soap *soap, const char *tag, int id, const struct __ns1__AlterTable_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__AlterTable(soap, "ns1:AlterTable", -1, &a->ns1__AlterTable, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AlterTable_ * SOAP_FMAC4 soap_in___ns1__AlterTable_(struct soap *soap, const char *tag, struct __ns1__AlterTable_ *a, const char *type)
{
	size_t soap_flag_ns1__AlterTable = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__AlterTable_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__AlterTable_, sizeof(struct __ns1__AlterTable_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__AlterTable_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AlterTable && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__AlterTable(soap, "ns1:AlterTable", &a->ns1__AlterTable, ""))
				{	soap_flag_ns1__AlterTable--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__AlterTable_ * SOAP_FMAC2 soap_instantiate___ns1__AlterTable_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__AlterTable_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__AlterTable_ *p;
	size_t k = sizeof(struct __ns1__AlterTable_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__AlterTable_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__AlterTable_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__AlterTable_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__AlterTable_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__AlterTable_(struct soap *soap, const struct __ns1__AlterTable_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__AlterTable_(soap, tag ? tag : "-ns1:AlterTable", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AlterTable_ * SOAP_FMAC4 soap_get___ns1__AlterTable_(struct soap *soap, struct __ns1__AlterTable_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__AlterTable_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetFileNew_(struct soap *soap, struct __ns1__GetFileNew_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetFileNew = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetFileNew_(struct soap *soap, const struct __ns1__GetFileNew_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetFileNew(soap, &a->ns1__GetFileNew);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetFileNew_(struct soap *soap, const char *tag, int id, const struct __ns1__GetFileNew_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetFileNew(soap, "ns1:GetFileNew", -1, &a->ns1__GetFileNew, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFileNew_ * SOAP_FMAC4 soap_in___ns1__GetFileNew_(struct soap *soap, const char *tag, struct __ns1__GetFileNew_ *a, const char *type)
{
	size_t soap_flag_ns1__GetFileNew = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetFileNew_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetFileNew_, sizeof(struct __ns1__GetFileNew_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetFileNew_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetFileNew && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetFileNew(soap, "ns1:GetFileNew", &a->ns1__GetFileNew, ""))
				{	soap_flag_ns1__GetFileNew--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetFileNew_ * SOAP_FMAC2 soap_instantiate___ns1__GetFileNew_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetFileNew_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetFileNew_ *p;
	size_t k = sizeof(struct __ns1__GetFileNew_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetFileNew_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetFileNew_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetFileNew_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetFileNew_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetFileNew_(struct soap *soap, const struct __ns1__GetFileNew_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetFileNew_(soap, tag ? tag : "-ns1:GetFileNew", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFileNew_ * SOAP_FMAC4 soap_get___ns1__GetFileNew_(struct soap *soap, struct __ns1__GetFileNew_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetFileNew_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DownMapfile_(struct soap *soap, struct __ns1__DownMapfile_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DownMapfile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DownMapfile_(struct soap *soap, const struct __ns1__DownMapfile_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DownMapfile(soap, &a->ns1__DownMapfile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DownMapfile_(struct soap *soap, const char *tag, int id, const struct __ns1__DownMapfile_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DownMapfile(soap, "ns1:DownMapfile", -1, &a->ns1__DownMapfile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownMapfile_ * SOAP_FMAC4 soap_in___ns1__DownMapfile_(struct soap *soap, const char *tag, struct __ns1__DownMapfile_ *a, const char *type)
{
	size_t soap_flag_ns1__DownMapfile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DownMapfile_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DownMapfile_, sizeof(struct __ns1__DownMapfile_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DownMapfile_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DownMapfile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__DownMapfile(soap, "ns1:DownMapfile", &a->ns1__DownMapfile, ""))
				{	soap_flag_ns1__DownMapfile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DownMapfile_ * SOAP_FMAC2 soap_instantiate___ns1__DownMapfile_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DownMapfile_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DownMapfile_ *p;
	size_t k = sizeof(struct __ns1__DownMapfile_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__DownMapfile_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__DownMapfile_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__DownMapfile_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DownMapfile_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DownMapfile_(struct soap *soap, const struct __ns1__DownMapfile_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DownMapfile_(soap, tag ? tag : "-ns1:DownMapfile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownMapfile_ * SOAP_FMAC4 soap_get___ns1__DownMapfile_(struct soap *soap, struct __ns1__DownMapfile_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DownMapfile_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDownFileInfo_(struct soap *soap, struct __ns1__GetDownFileInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDownFileInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDownFileInfo_(struct soap *soap, const struct __ns1__GetDownFileInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetDownFileInfo(soap, &a->ns1__GetDownFileInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDownFileInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__GetDownFileInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetDownFileInfo(soap, "ns1:GetDownFileInfo", -1, &a->ns1__GetDownFileInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDownFileInfo_ * SOAP_FMAC4 soap_in___ns1__GetDownFileInfo_(struct soap *soap, const char *tag, struct __ns1__GetDownFileInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__GetDownFileInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetDownFileInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDownFileInfo_, sizeof(struct __ns1__GetDownFileInfo_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDownFileInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDownFileInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetDownFileInfo(soap, "ns1:GetDownFileInfo", &a->ns1__GetDownFileInfo, ""))
				{	soap_flag_ns1__GetDownFileInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetDownFileInfo_ * SOAP_FMAC2 soap_instantiate___ns1__GetDownFileInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDownFileInfo_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetDownFileInfo_ *p;
	size_t k = sizeof(struct __ns1__GetDownFileInfo_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetDownFileInfo_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetDownFileInfo_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetDownFileInfo_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetDownFileInfo_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDownFileInfo_(struct soap *soap, const struct __ns1__GetDownFileInfo_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetDownFileInfo_(soap, tag ? tag : "-ns1:GetDownFileInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDownFileInfo_ * SOAP_FMAC4 soap_get___ns1__GetDownFileInfo_(struct soap *soap, struct __ns1__GetDownFileInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDownFileInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetGxDeviceData_(struct soap *soap, struct __ns1__GetGxDeviceData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetGxDeviceData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetGxDeviceData_(struct soap *soap, const struct __ns1__GetGxDeviceData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetGxDeviceData(soap, &a->ns1__GetGxDeviceData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetGxDeviceData_(struct soap *soap, const char *tag, int id, const struct __ns1__GetGxDeviceData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetGxDeviceData(soap, "ns1:GetGxDeviceData", -1, &a->ns1__GetGxDeviceData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetGxDeviceData_ * SOAP_FMAC4 soap_in___ns1__GetGxDeviceData_(struct soap *soap, const char *tag, struct __ns1__GetGxDeviceData_ *a, const char *type)
{
	size_t soap_flag_ns1__GetGxDeviceData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetGxDeviceData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetGxDeviceData_, sizeof(struct __ns1__GetGxDeviceData_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetGxDeviceData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetGxDeviceData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetGxDeviceData(soap, "ns1:GetGxDeviceData", &a->ns1__GetGxDeviceData, ""))
				{	soap_flag_ns1__GetGxDeviceData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetGxDeviceData_ * SOAP_FMAC2 soap_instantiate___ns1__GetGxDeviceData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetGxDeviceData_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetGxDeviceData_ *p;
	size_t k = sizeof(struct __ns1__GetGxDeviceData_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetGxDeviceData_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetGxDeviceData_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetGxDeviceData_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetGxDeviceData_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetGxDeviceData_(struct soap *soap, const struct __ns1__GetGxDeviceData_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetGxDeviceData_(soap, tag ? tag : "-ns1:GetGxDeviceData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetGxDeviceData_ * SOAP_FMAC4 soap_get___ns1__GetGxDeviceData_(struct soap *soap, struct __ns1__GetGxDeviceData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetGxDeviceData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMapDeviceType_(struct soap *soap, struct __ns1__GetMapDeviceType_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMapDeviceType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMapDeviceType_(struct soap *soap, const struct __ns1__GetMapDeviceType_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMapDeviceType(soap, &a->ns1__GetMapDeviceType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMapDeviceType_(struct soap *soap, const char *tag, int id, const struct __ns1__GetMapDeviceType_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMapDeviceType(soap, "ns1:GetMapDeviceType", -1, &a->ns1__GetMapDeviceType, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMapDeviceType_ * SOAP_FMAC4 soap_in___ns1__GetMapDeviceType_(struct soap *soap, const char *tag, struct __ns1__GetMapDeviceType_ *a, const char *type)
{
	size_t soap_flag_ns1__GetMapDeviceType = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMapDeviceType_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMapDeviceType_, sizeof(struct __ns1__GetMapDeviceType_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMapDeviceType_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMapDeviceType && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMapDeviceType(soap, "ns1:GetMapDeviceType", &a->ns1__GetMapDeviceType, ""))
				{	soap_flag_ns1__GetMapDeviceType--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMapDeviceType_ * SOAP_FMAC2 soap_instantiate___ns1__GetMapDeviceType_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMapDeviceType_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMapDeviceType_ *p;
	size_t k = sizeof(struct __ns1__GetMapDeviceType_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetMapDeviceType_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetMapDeviceType_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetMapDeviceType_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMapDeviceType_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMapDeviceType_(struct soap *soap, const struct __ns1__GetMapDeviceType_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMapDeviceType_(soap, tag ? tag : "-ns1:GetMapDeviceType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMapDeviceType_ * SOAP_FMAC4 soap_get___ns1__GetMapDeviceType_(struct soap *soap, struct __ns1__GetMapDeviceType_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMapDeviceType_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetXbStationList_(struct soap *soap, struct __ns1__GetXbStationList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetXbStationList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetXbStationList_(struct soap *soap, const struct __ns1__GetXbStationList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetXbStationList(soap, &a->ns1__GetXbStationList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetXbStationList_(struct soap *soap, const char *tag, int id, const struct __ns1__GetXbStationList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetXbStationList(soap, "ns1:GetXbStationList", -1, &a->ns1__GetXbStationList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetXbStationList_ * SOAP_FMAC4 soap_in___ns1__GetXbStationList_(struct soap *soap, const char *tag, struct __ns1__GetXbStationList_ *a, const char *type)
{
	size_t soap_flag_ns1__GetXbStationList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetXbStationList_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetXbStationList_, sizeof(struct __ns1__GetXbStationList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetXbStationList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetXbStationList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetXbStationList(soap, "ns1:GetXbStationList", &a->ns1__GetXbStationList, ""))
				{	soap_flag_ns1__GetXbStationList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetXbStationList_ * SOAP_FMAC2 soap_instantiate___ns1__GetXbStationList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetXbStationList_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetXbStationList_ *p;
	size_t k = sizeof(struct __ns1__GetXbStationList_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetXbStationList_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetXbStationList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetXbStationList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetXbStationList_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetXbStationList_(struct soap *soap, const struct __ns1__GetXbStationList_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetXbStationList_(soap, tag ? tag : "-ns1:GetXbStationList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetXbStationList_ * SOAP_FMAC4 soap_get___ns1__GetXbStationList_(struct soap *soap, struct __ns1__GetXbStationList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetXbStationList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetXbList_(struct soap *soap, struct __ns1__GetXbList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetXbList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetXbList_(struct soap *soap, const struct __ns1__GetXbList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetXbList(soap, &a->ns1__GetXbList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetXbList_(struct soap *soap, const char *tag, int id, const struct __ns1__GetXbList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetXbList(soap, "ns1:GetXbList", -1, &a->ns1__GetXbList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetXbList_ * SOAP_FMAC4 soap_in___ns1__GetXbList_(struct soap *soap, const char *tag, struct __ns1__GetXbList_ *a, const char *type)
{
	size_t soap_flag_ns1__GetXbList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetXbList_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetXbList_, sizeof(struct __ns1__GetXbList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetXbList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetXbList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetXbList(soap, "ns1:GetXbList", &a->ns1__GetXbList, ""))
				{	soap_flag_ns1__GetXbList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetXbList_ * SOAP_FMAC2 soap_instantiate___ns1__GetXbList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetXbList_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetXbList_ *p;
	size_t k = sizeof(struct __ns1__GetXbList_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetXbList_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetXbList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetXbList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetXbList_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetXbList_(struct soap *soap, const struct __ns1__GetXbList_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetXbList_(soap, tag ? tag : "-ns1:GetXbList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetXbList_ * SOAP_FMAC4 soap_get___ns1__GetXbList_(struct soap *soap, struct __ns1__GetXbList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetXbList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetFileSize_(struct soap *soap, struct __ns1__GetFileSize_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetFileSize = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetFileSize_(struct soap *soap, const struct __ns1__GetFileSize_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetFileSize(soap, &a->ns1__GetFileSize);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetFileSize_(struct soap *soap, const char *tag, int id, const struct __ns1__GetFileSize_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetFileSize(soap, "ns1:GetFileSize", -1, &a->ns1__GetFileSize, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFileSize_ * SOAP_FMAC4 soap_in___ns1__GetFileSize_(struct soap *soap, const char *tag, struct __ns1__GetFileSize_ *a, const char *type)
{
	size_t soap_flag_ns1__GetFileSize = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetFileSize_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetFileSize_, sizeof(struct __ns1__GetFileSize_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetFileSize_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetFileSize && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetFileSize(soap, "ns1:GetFileSize", &a->ns1__GetFileSize, ""))
				{	soap_flag_ns1__GetFileSize--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetFileSize_ * SOAP_FMAC2 soap_instantiate___ns1__GetFileSize_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetFileSize_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetFileSize_ *p;
	size_t k = sizeof(struct __ns1__GetFileSize_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetFileSize_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetFileSize_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetFileSize_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetFileSize_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetFileSize_(struct soap *soap, const struct __ns1__GetFileSize_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetFileSize_(soap, tag ? tag : "-ns1:GetFileSize", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFileSize_ * SOAP_FMAC4 soap_get___ns1__GetFileSize_(struct soap *soap, struct __ns1__GetFileSize_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetFileSize_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetUnitPersonInfo_(struct soap *soap, struct __ns1__GetUnitPersonInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetUnitPersonInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetUnitPersonInfo_(struct soap *soap, const struct __ns1__GetUnitPersonInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetUnitPersonInfo(soap, &a->ns1__GetUnitPersonInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetUnitPersonInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__GetUnitPersonInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetUnitPersonInfo(soap, "ns1:GetUnitPersonInfo", -1, &a->ns1__GetUnitPersonInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUnitPersonInfo_ * SOAP_FMAC4 soap_in___ns1__GetUnitPersonInfo_(struct soap *soap, const char *tag, struct __ns1__GetUnitPersonInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__GetUnitPersonInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetUnitPersonInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetUnitPersonInfo_, sizeof(struct __ns1__GetUnitPersonInfo_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetUnitPersonInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetUnitPersonInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetUnitPersonInfo(soap, "ns1:GetUnitPersonInfo", &a->ns1__GetUnitPersonInfo, ""))
				{	soap_flag_ns1__GetUnitPersonInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetUnitPersonInfo_ * SOAP_FMAC2 soap_instantiate___ns1__GetUnitPersonInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetUnitPersonInfo_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetUnitPersonInfo_ *p;
	size_t k = sizeof(struct __ns1__GetUnitPersonInfo_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetUnitPersonInfo_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetUnitPersonInfo_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetUnitPersonInfo_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetUnitPersonInfo_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetUnitPersonInfo_(struct soap *soap, const struct __ns1__GetUnitPersonInfo_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetUnitPersonInfo_(soap, tag ? tag : "-ns1:GetUnitPersonInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUnitPersonInfo_ * SOAP_FMAC4 soap_get___ns1__GetUnitPersonInfo_(struct soap *soap, struct __ns1__GetUnitPersonInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetUnitPersonInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetUnitStruct_(struct soap *soap, struct __ns1__GetUnitStruct_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetUnitStruct = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetUnitStruct_(struct soap *soap, const struct __ns1__GetUnitStruct_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetUnitStruct(soap, &a->ns1__GetUnitStruct);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetUnitStruct_(struct soap *soap, const char *tag, int id, const struct __ns1__GetUnitStruct_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetUnitStruct(soap, "ns1:GetUnitStruct", -1, &a->ns1__GetUnitStruct, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUnitStruct_ * SOAP_FMAC4 soap_in___ns1__GetUnitStruct_(struct soap *soap, const char *tag, struct __ns1__GetUnitStruct_ *a, const char *type)
{
	size_t soap_flag_ns1__GetUnitStruct = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetUnitStruct_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetUnitStruct_, sizeof(struct __ns1__GetUnitStruct_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetUnitStruct_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetUnitStruct && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetUnitStruct(soap, "ns1:GetUnitStruct", &a->ns1__GetUnitStruct, ""))
				{	soap_flag_ns1__GetUnitStruct--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetUnitStruct_ * SOAP_FMAC2 soap_instantiate___ns1__GetUnitStruct_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetUnitStruct_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetUnitStruct_ *p;
	size_t k = sizeof(struct __ns1__GetUnitStruct_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetUnitStruct_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetUnitStruct_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetUnitStruct_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetUnitStruct_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetUnitStruct_(struct soap *soap, const struct __ns1__GetUnitStruct_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetUnitStruct_(soap, tag ? tag : "-ns1:GetUnitStruct", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUnitStruct_ * SOAP_FMAC4 soap_get___ns1__GetUnitStruct_(struct soap *soap, struct __ns1__GetUnitStruct_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetUnitStruct_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetUnitStation_(struct soap *soap, struct __ns1__GetUnitStation_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetUnitStation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetUnitStation_(struct soap *soap, const struct __ns1__GetUnitStation_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetUnitStation(soap, &a->ns1__GetUnitStation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetUnitStation_(struct soap *soap, const char *tag, int id, const struct __ns1__GetUnitStation_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetUnitStation(soap, "ns1:GetUnitStation", -1, &a->ns1__GetUnitStation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUnitStation_ * SOAP_FMAC4 soap_in___ns1__GetUnitStation_(struct soap *soap, const char *tag, struct __ns1__GetUnitStation_ *a, const char *type)
{
	size_t soap_flag_ns1__GetUnitStation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetUnitStation_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetUnitStation_, sizeof(struct __ns1__GetUnitStation_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetUnitStation_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetUnitStation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetUnitStation(soap, "ns1:GetUnitStation", &a->ns1__GetUnitStation, ""))
				{	soap_flag_ns1__GetUnitStation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetUnitStation_ * SOAP_FMAC2 soap_instantiate___ns1__GetUnitStation_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetUnitStation_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetUnitStation_ *p;
	size_t k = sizeof(struct __ns1__GetUnitStation_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetUnitStation_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetUnitStation_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetUnitStation_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetUnitStation_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetUnitStation_(struct soap *soap, const struct __ns1__GetUnitStation_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetUnitStation_(soap, tag ? tag : "-ns1:GetUnitStation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUnitStation_ * SOAP_FMAC4 soap_get___ns1__GetUnitStation_(struct soap *soap, struct __ns1__GetUnitStation_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetUnitStation_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDwList_(struct soap *soap, struct __ns1__GetDwList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDwList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDwList_(struct soap *soap, const struct __ns1__GetDwList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetDwList(soap, &a->ns1__GetDwList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDwList_(struct soap *soap, const char *tag, int id, const struct __ns1__GetDwList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetDwList(soap, "ns1:GetDwList", -1, &a->ns1__GetDwList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDwList_ * SOAP_FMAC4 soap_in___ns1__GetDwList_(struct soap *soap, const char *tag, struct __ns1__GetDwList_ *a, const char *type)
{
	size_t soap_flag_ns1__GetDwList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetDwList_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDwList_, sizeof(struct __ns1__GetDwList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDwList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDwList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetDwList(soap, "ns1:GetDwList", &a->ns1__GetDwList, ""))
				{	soap_flag_ns1__GetDwList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetDwList_ * SOAP_FMAC2 soap_instantiate___ns1__GetDwList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDwList_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetDwList_ *p;
	size_t k = sizeof(struct __ns1__GetDwList_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetDwList_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetDwList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetDwList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetDwList_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDwList_(struct soap *soap, const struct __ns1__GetDwList_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetDwList_(soap, tag ? tag : "-ns1:GetDwList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDwList_ * SOAP_FMAC4 soap_get___ns1__GetDwList_(struct soap *soap, struct __ns1__GetDwList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDwList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetOpenFireInfo_(struct soap *soap, struct __ns1__GetOpenFireInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetOpenFireInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetOpenFireInfo_(struct soap *soap, const struct __ns1__GetOpenFireInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetOpenFireInfo(soap, &a->ns1__GetOpenFireInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetOpenFireInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__GetOpenFireInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetOpenFireInfo(soap, "ns1:GetOpenFireInfo", -1, &a->ns1__GetOpenFireInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetOpenFireInfo_ * SOAP_FMAC4 soap_in___ns1__GetOpenFireInfo_(struct soap *soap, const char *tag, struct __ns1__GetOpenFireInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__GetOpenFireInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetOpenFireInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetOpenFireInfo_, sizeof(struct __ns1__GetOpenFireInfo_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetOpenFireInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetOpenFireInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetOpenFireInfo(soap, "ns1:GetOpenFireInfo", &a->ns1__GetOpenFireInfo, ""))
				{	soap_flag_ns1__GetOpenFireInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetOpenFireInfo_ * SOAP_FMAC2 soap_instantiate___ns1__GetOpenFireInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetOpenFireInfo_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetOpenFireInfo_ *p;
	size_t k = sizeof(struct __ns1__GetOpenFireInfo_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetOpenFireInfo_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetOpenFireInfo_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetOpenFireInfo_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetOpenFireInfo_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetOpenFireInfo_(struct soap *soap, const struct __ns1__GetOpenFireInfo_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetOpenFireInfo_(soap, tag ? tag : "-ns1:GetOpenFireInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetOpenFireInfo_ * SOAP_FMAC4 soap_get___ns1__GetOpenFireInfo_(struct soap *soap, struct __ns1__GetOpenFireInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetOpenFireInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__MobDownLoadData_(struct soap *soap, struct __ns1__MobDownLoadData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__MobDownLoadData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__MobDownLoadData_(struct soap *soap, const struct __ns1__MobDownLoadData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__MobDownLoadData(soap, &a->ns1__MobDownLoadData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__MobDownLoadData_(struct soap *soap, const char *tag, int id, const struct __ns1__MobDownLoadData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__MobDownLoadData(soap, "ns1:MobDownLoadData", -1, &a->ns1__MobDownLoadData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__MobDownLoadData_ * SOAP_FMAC4 soap_in___ns1__MobDownLoadData_(struct soap *soap, const char *tag, struct __ns1__MobDownLoadData_ *a, const char *type)
{
	size_t soap_flag_ns1__MobDownLoadData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__MobDownLoadData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__MobDownLoadData_, sizeof(struct __ns1__MobDownLoadData_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__MobDownLoadData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__MobDownLoadData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__MobDownLoadData(soap, "ns1:MobDownLoadData", &a->ns1__MobDownLoadData, ""))
				{	soap_flag_ns1__MobDownLoadData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__MobDownLoadData_ * SOAP_FMAC2 soap_instantiate___ns1__MobDownLoadData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__MobDownLoadData_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__MobDownLoadData_ *p;
	size_t k = sizeof(struct __ns1__MobDownLoadData_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__MobDownLoadData_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__MobDownLoadData_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__MobDownLoadData_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__MobDownLoadData_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__MobDownLoadData_(struct soap *soap, const struct __ns1__MobDownLoadData_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__MobDownLoadData_(soap, tag ? tag : "-ns1:MobDownLoadData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__MobDownLoadData_ * SOAP_FMAC4 soap_get___ns1__MobDownLoadData_(struct soap *soap, struct __ns1__MobDownLoadData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__MobDownLoadData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DownLoadMobGPSData_(struct soap *soap, struct __ns1__DownLoadMobGPSData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DownLoadMobGPSData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DownLoadMobGPSData_(struct soap *soap, const struct __ns1__DownLoadMobGPSData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DownLoadMobGPSData(soap, &a->ns1__DownLoadMobGPSData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DownLoadMobGPSData_(struct soap *soap, const char *tag, int id, const struct __ns1__DownLoadMobGPSData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DownLoadMobGPSData(soap, "ns1:DownLoadMobGPSData", -1, &a->ns1__DownLoadMobGPSData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownLoadMobGPSData_ * SOAP_FMAC4 soap_in___ns1__DownLoadMobGPSData_(struct soap *soap, const char *tag, struct __ns1__DownLoadMobGPSData_ *a, const char *type)
{
	size_t soap_flag_ns1__DownLoadMobGPSData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DownLoadMobGPSData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DownLoadMobGPSData_, sizeof(struct __ns1__DownLoadMobGPSData_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DownLoadMobGPSData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DownLoadMobGPSData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__DownLoadMobGPSData(soap, "ns1:DownLoadMobGPSData", &a->ns1__DownLoadMobGPSData, ""))
				{	soap_flag_ns1__DownLoadMobGPSData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DownLoadMobGPSData_ * SOAP_FMAC2 soap_instantiate___ns1__DownLoadMobGPSData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DownLoadMobGPSData_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DownLoadMobGPSData_ *p;
	size_t k = sizeof(struct __ns1__DownLoadMobGPSData_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__DownLoadMobGPSData_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__DownLoadMobGPSData_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__DownLoadMobGPSData_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DownLoadMobGPSData_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DownLoadMobGPSData_(struct soap *soap, const struct __ns1__DownLoadMobGPSData_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DownLoadMobGPSData_(soap, tag ? tag : "-ns1:DownLoadMobGPSData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownLoadMobGPSData_ * SOAP_FMAC4 soap_get___ns1__DownLoadMobGPSData_(struct soap *soap, struct __ns1__DownLoadMobGPSData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DownLoadMobGPSData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDcsData_(struct soap *soap, struct __ns1__GetDcsData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDcsData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDcsData_(struct soap *soap, const struct __ns1__GetDcsData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetDcsData(soap, &a->ns1__GetDcsData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDcsData_(struct soap *soap, const char *tag, int id, const struct __ns1__GetDcsData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetDcsData(soap, "ns1:GetDcsData", -1, &a->ns1__GetDcsData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDcsData_ * SOAP_FMAC4 soap_in___ns1__GetDcsData_(struct soap *soap, const char *tag, struct __ns1__GetDcsData_ *a, const char *type)
{
	size_t soap_flag_ns1__GetDcsData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetDcsData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDcsData_, sizeof(struct __ns1__GetDcsData_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDcsData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDcsData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetDcsData(soap, "ns1:GetDcsData", &a->ns1__GetDcsData, ""))
				{	soap_flag_ns1__GetDcsData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetDcsData_ * SOAP_FMAC2 soap_instantiate___ns1__GetDcsData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDcsData_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetDcsData_ *p;
	size_t k = sizeof(struct __ns1__GetDcsData_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetDcsData_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetDcsData_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetDcsData_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetDcsData_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDcsData_(struct soap *soap, const struct __ns1__GetDcsData_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetDcsData_(soap, tag ? tag : "-ns1:GetDcsData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDcsData_ * SOAP_FMAC4 soap_get___ns1__GetDcsData_(struct soap *soap, struct __ns1__GetDcsData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDcsData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetBgImg_(struct soap *soap, struct __ns1__GetBgImg_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetBgImg = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetBgImg_(struct soap *soap, const struct __ns1__GetBgImg_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetBgImg(soap, &a->ns1__GetBgImg);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetBgImg_(struct soap *soap, const char *tag, int id, const struct __ns1__GetBgImg_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetBgImg(soap, "ns1:GetBgImg", -1, &a->ns1__GetBgImg, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetBgImg_ * SOAP_FMAC4 soap_in___ns1__GetBgImg_(struct soap *soap, const char *tag, struct __ns1__GetBgImg_ *a, const char *type)
{
	size_t soap_flag_ns1__GetBgImg = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetBgImg_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetBgImg_, sizeof(struct __ns1__GetBgImg_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetBgImg_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetBgImg && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetBgImg(soap, "ns1:GetBgImg", &a->ns1__GetBgImg, ""))
				{	soap_flag_ns1__GetBgImg--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetBgImg_ * SOAP_FMAC2 soap_instantiate___ns1__GetBgImg_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetBgImg_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetBgImg_ *p;
	size_t k = sizeof(struct __ns1__GetBgImg_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetBgImg_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetBgImg_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetBgImg_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetBgImg_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetBgImg_(struct soap *soap, const struct __ns1__GetBgImg_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetBgImg_(soap, tag ? tag : "-ns1:GetBgImg", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetBgImg_ * SOAP_FMAC4 soap_get___ns1__GetBgImg_(struct soap *soap, struct __ns1__GetBgImg_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetBgImg_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDevPic_(struct soap *soap, struct __ns1__GetDevPic_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDevPic = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDevPic_(struct soap *soap, const struct __ns1__GetDevPic_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetDevPic(soap, &a->ns1__GetDevPic);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDevPic_(struct soap *soap, const char *tag, int id, const struct __ns1__GetDevPic_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetDevPic(soap, "ns1:GetDevPic", -1, &a->ns1__GetDevPic, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDevPic_ * SOAP_FMAC4 soap_in___ns1__GetDevPic_(struct soap *soap, const char *tag, struct __ns1__GetDevPic_ *a, const char *type)
{
	size_t soap_flag_ns1__GetDevPic = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetDevPic_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDevPic_, sizeof(struct __ns1__GetDevPic_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDevPic_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDevPic && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetDevPic(soap, "ns1:GetDevPic", &a->ns1__GetDevPic, ""))
				{	soap_flag_ns1__GetDevPic--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetDevPic_ * SOAP_FMAC2 soap_instantiate___ns1__GetDevPic_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDevPic_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetDevPic_ *p;
	size_t k = sizeof(struct __ns1__GetDevPic_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetDevPic_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetDevPic_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetDevPic_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetDevPic_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDevPic_(struct soap *soap, const struct __ns1__GetDevPic_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetDevPic_(soap, tag ? tag : "-ns1:GetDevPic", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDevPic_ * SOAP_FMAC4 soap_get___ns1__GetDevPic_(struct soap *soap, struct __ns1__GetDevPic_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDevPic_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetJxPic_(struct soap *soap, struct __ns1__GetJxPic_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetJxPic = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetJxPic_(struct soap *soap, const struct __ns1__GetJxPic_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetJxPic(soap, &a->ns1__GetJxPic);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetJxPic_(struct soap *soap, const char *tag, int id, const struct __ns1__GetJxPic_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetJxPic(soap, "ns1:GetJxPic", -1, &a->ns1__GetJxPic, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetJxPic_ * SOAP_FMAC4 soap_in___ns1__GetJxPic_(struct soap *soap, const char *tag, struct __ns1__GetJxPic_ *a, const char *type)
{
	size_t soap_flag_ns1__GetJxPic = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetJxPic_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetJxPic_, sizeof(struct __ns1__GetJxPic_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetJxPic_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetJxPic && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetJxPic(soap, "ns1:GetJxPic", &a->ns1__GetJxPic, ""))
				{	soap_flag_ns1__GetJxPic--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetJxPic_ * SOAP_FMAC2 soap_instantiate___ns1__GetJxPic_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetJxPic_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetJxPic_ *p;
	size_t k = sizeof(struct __ns1__GetJxPic_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetJxPic_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetJxPic_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetJxPic_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetJxPic_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetJxPic_(struct soap *soap, const struct __ns1__GetJxPic_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetJxPic_(soap, tag ? tag : "-ns1:GetJxPic", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetJxPic_ * SOAP_FMAC4 soap_get___ns1__GetJxPic_(struct soap *soap, struct __ns1__GetJxPic_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetJxPic_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetStationJxData_(struct soap *soap, struct __ns1__GetStationJxData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetStationJxData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetStationJxData_(struct soap *soap, const struct __ns1__GetStationJxData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetStationJxData(soap, &a->ns1__GetStationJxData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetStationJxData_(struct soap *soap, const char *tag, int id, const struct __ns1__GetStationJxData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetStationJxData(soap, "ns1:GetStationJxData", -1, &a->ns1__GetStationJxData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetStationJxData_ * SOAP_FMAC4 soap_in___ns1__GetStationJxData_(struct soap *soap, const char *tag, struct __ns1__GetStationJxData_ *a, const char *type)
{
	size_t soap_flag_ns1__GetStationJxData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetStationJxData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetStationJxData_, sizeof(struct __ns1__GetStationJxData_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetStationJxData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetStationJxData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetStationJxData(soap, "ns1:GetStationJxData", &a->ns1__GetStationJxData, ""))
				{	soap_flag_ns1__GetStationJxData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetStationJxData_ * SOAP_FMAC2 soap_instantiate___ns1__GetStationJxData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetStationJxData_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetStationJxData_ *p;
	size_t k = sizeof(struct __ns1__GetStationJxData_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetStationJxData_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetStationJxData_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetStationJxData_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetStationJxData_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetStationJxData_(struct soap *soap, const struct __ns1__GetStationJxData_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetStationJxData_(soap, tag ? tag : "-ns1:GetStationJxData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetStationJxData_ * SOAP_FMAC4 soap_get___ns1__GetStationJxData_(struct soap *soap, struct __ns1__GetStationJxData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetStationJxData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetJxData_(struct soap *soap, struct __ns1__GetJxData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetJxData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetJxData_(struct soap *soap, const struct __ns1__GetJxData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetJxData(soap, &a->ns1__GetJxData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetJxData_(struct soap *soap, const char *tag, int id, const struct __ns1__GetJxData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetJxData(soap, "ns1:GetJxData", -1, &a->ns1__GetJxData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetJxData_ * SOAP_FMAC4 soap_in___ns1__GetJxData_(struct soap *soap, const char *tag, struct __ns1__GetJxData_ *a, const char *type)
{
	size_t soap_flag_ns1__GetJxData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetJxData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetJxData_, sizeof(struct __ns1__GetJxData_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetJxData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetJxData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetJxData(soap, "ns1:GetJxData", &a->ns1__GetJxData, ""))
				{	soap_flag_ns1__GetJxData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetJxData_ * SOAP_FMAC2 soap_instantiate___ns1__GetJxData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetJxData_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetJxData_ *p;
	size_t k = sizeof(struct __ns1__GetJxData_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetJxData_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetJxData_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetJxData_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetJxData_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetJxData_(struct soap *soap, const struct __ns1__GetJxData_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetJxData_(soap, tag ? tag : "-ns1:GetJxData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetJxData_ * SOAP_FMAC4 soap_get___ns1__GetJxData_(struct soap *soap, struct __ns1__GetJxData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetJxData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDeviceXj_(struct soap *soap, struct __ns1__GetDeviceXj_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDeviceXj = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDeviceXj_(struct soap *soap, const struct __ns1__GetDeviceXj_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetDeviceXj(soap, &a->ns1__GetDeviceXj);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDeviceXj_(struct soap *soap, const char *tag, int id, const struct __ns1__GetDeviceXj_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetDeviceXj(soap, "ns1:GetDeviceXj", -1, &a->ns1__GetDeviceXj, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDeviceXj_ * SOAP_FMAC4 soap_in___ns1__GetDeviceXj_(struct soap *soap, const char *tag, struct __ns1__GetDeviceXj_ *a, const char *type)
{
	size_t soap_flag_ns1__GetDeviceXj = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetDeviceXj_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDeviceXj_, sizeof(struct __ns1__GetDeviceXj_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDeviceXj_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDeviceXj && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetDeviceXj(soap, "ns1:GetDeviceXj", &a->ns1__GetDeviceXj, ""))
				{	soap_flag_ns1__GetDeviceXj--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetDeviceXj_ * SOAP_FMAC2 soap_instantiate___ns1__GetDeviceXj_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDeviceXj_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetDeviceXj_ *p;
	size_t k = sizeof(struct __ns1__GetDeviceXj_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetDeviceXj_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetDeviceXj_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetDeviceXj_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetDeviceXj_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDeviceXj_(struct soap *soap, const struct __ns1__GetDeviceXj_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetDeviceXj_(soap, tag ? tag : "-ns1:GetDeviceXj", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDeviceXj_ * SOAP_FMAC4 soap_get___ns1__GetDeviceXj_(struct soap *soap, struct __ns1__GetDeviceXj_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDeviceXj_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDwPic_(struct soap *soap, struct __ns1__GetDwPic_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDwPic = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDwPic_(struct soap *soap, const struct __ns1__GetDwPic_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetDwPic(soap, &a->ns1__GetDwPic);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDwPic_(struct soap *soap, const char *tag, int id, const struct __ns1__GetDwPic_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetDwPic(soap, "ns1:GetDwPic", -1, &a->ns1__GetDwPic, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDwPic_ * SOAP_FMAC4 soap_in___ns1__GetDwPic_(struct soap *soap, const char *tag, struct __ns1__GetDwPic_ *a, const char *type)
{
	size_t soap_flag_ns1__GetDwPic = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetDwPic_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDwPic_, sizeof(struct __ns1__GetDwPic_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDwPic_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDwPic && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetDwPic(soap, "ns1:GetDwPic", &a->ns1__GetDwPic, ""))
				{	soap_flag_ns1__GetDwPic--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetDwPic_ * SOAP_FMAC2 soap_instantiate___ns1__GetDwPic_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDwPic_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetDwPic_ *p;
	size_t k = sizeof(struct __ns1__GetDwPic_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetDwPic_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetDwPic_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetDwPic_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetDwPic_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDwPic_(struct soap *soap, const struct __ns1__GetDwPic_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetDwPic_(soap, tag ? tag : "-ns1:GetDwPic", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDwPic_ * SOAP_FMAC4 soap_get___ns1__GetDwPic_(struct soap *soap, struct __ns1__GetDwPic_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDwPic_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDwInfo_(struct soap *soap, struct __ns1__GetDwInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDwInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDwInfo_(struct soap *soap, const struct __ns1__GetDwInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetDwInfo(soap, &a->ns1__GetDwInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDwInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__GetDwInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetDwInfo(soap, "ns1:GetDwInfo", -1, &a->ns1__GetDwInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDwInfo_ * SOAP_FMAC4 soap_in___ns1__GetDwInfo_(struct soap *soap, const char *tag, struct __ns1__GetDwInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__GetDwInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetDwInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDwInfo_, sizeof(struct __ns1__GetDwInfo_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDwInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDwInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetDwInfo(soap, "ns1:GetDwInfo", &a->ns1__GetDwInfo, ""))
				{	soap_flag_ns1__GetDwInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetDwInfo_ * SOAP_FMAC2 soap_instantiate___ns1__GetDwInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDwInfo_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetDwInfo_ *p;
	size_t k = sizeof(struct __ns1__GetDwInfo_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetDwInfo_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetDwInfo_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetDwInfo_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetDwInfo_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDwInfo_(struct soap *soap, const struct __ns1__GetDwInfo_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetDwInfo_(soap, tag ? tag : "-ns1:GetDwInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDwInfo_ * SOAP_FMAC4 soap_get___ns1__GetDwInfo_(struct soap *soap, struct __ns1__GetDwInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDwInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetPicNames_(struct soap *soap, struct __ns1__GetPicNames_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPicNames = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetPicNames_(struct soap *soap, const struct __ns1__GetPicNames_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetPicNames(soap, &a->ns1__GetPicNames);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetPicNames_(struct soap *soap, const char *tag, int id, const struct __ns1__GetPicNames_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetPicNames(soap, "ns1:GetPicNames", -1, &a->ns1__GetPicNames, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPicNames_ * SOAP_FMAC4 soap_in___ns1__GetPicNames_(struct soap *soap, const char *tag, struct __ns1__GetPicNames_ *a, const char *type)
{
	size_t soap_flag_ns1__GetPicNames = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetPicNames_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetPicNames_, sizeof(struct __ns1__GetPicNames_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetPicNames_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPicNames && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetPicNames(soap, "ns1:GetPicNames", &a->ns1__GetPicNames, ""))
				{	soap_flag_ns1__GetPicNames--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetPicNames_ * SOAP_FMAC2 soap_instantiate___ns1__GetPicNames_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetPicNames_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetPicNames_ *p;
	size_t k = sizeof(struct __ns1__GetPicNames_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetPicNames_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetPicNames_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetPicNames_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetPicNames_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetPicNames_(struct soap *soap, const struct __ns1__GetPicNames_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetPicNames_(soap, tag ? tag : "-ns1:GetPicNames", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPicNames_ * SOAP_FMAC4 soap_get___ns1__GetPicNames_(struct soap *soap, struct __ns1__GetPicNames_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetPicNames_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DownloadPic_(struct soap *soap, struct __ns1__DownloadPic_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DownloadPic = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DownloadPic_(struct soap *soap, const struct __ns1__DownloadPic_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DownloadPic(soap, &a->ns1__DownloadPic);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DownloadPic_(struct soap *soap, const char *tag, int id, const struct __ns1__DownloadPic_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DownloadPic(soap, "ns1:DownloadPic", -1, &a->ns1__DownloadPic, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownloadPic_ * SOAP_FMAC4 soap_in___ns1__DownloadPic_(struct soap *soap, const char *tag, struct __ns1__DownloadPic_ *a, const char *type)
{
	size_t soap_flag_ns1__DownloadPic = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DownloadPic_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DownloadPic_, sizeof(struct __ns1__DownloadPic_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DownloadPic_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DownloadPic && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__DownloadPic(soap, "ns1:DownloadPic", &a->ns1__DownloadPic, ""))
				{	soap_flag_ns1__DownloadPic--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DownloadPic_ * SOAP_FMAC2 soap_instantiate___ns1__DownloadPic_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DownloadPic_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DownloadPic_ *p;
	size_t k = sizeof(struct __ns1__DownloadPic_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__DownloadPic_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__DownloadPic_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__DownloadPic_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DownloadPic_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DownloadPic_(struct soap *soap, const struct __ns1__DownloadPic_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DownloadPic_(soap, tag ? tag : "-ns1:DownloadPic", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownloadPic_ * SOAP_FMAC4 soap_get___ns1__DownloadPic_(struct soap *soap, struct __ns1__DownloadPic_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DownloadPic_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__upPic_(struct soap *soap, struct __ns1__upPic_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__upPic = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__upPic_(struct soap *soap, const struct __ns1__upPic_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__upPic(soap, &a->ns1__upPic);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__upPic_(struct soap *soap, const char *tag, int id, const struct __ns1__upPic_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__upPic(soap, "ns1:upPic", -1, &a->ns1__upPic, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__upPic_ * SOAP_FMAC4 soap_in___ns1__upPic_(struct soap *soap, const char *tag, struct __ns1__upPic_ *a, const char *type)
{
	size_t soap_flag_ns1__upPic = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__upPic_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__upPic_, sizeof(struct __ns1__upPic_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__upPic_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__upPic && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__upPic(soap, "ns1:upPic", &a->ns1__upPic, ""))
				{	soap_flag_ns1__upPic--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__upPic_ * SOAP_FMAC2 soap_instantiate___ns1__upPic_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__upPic_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__upPic_ *p;
	size_t k = sizeof(struct __ns1__upPic_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__upPic_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__upPic_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__upPic_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__upPic_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__upPic_(struct soap *soap, const struct __ns1__upPic_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__upPic_(soap, tag ? tag : "-ns1:upPic", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__upPic_ * SOAP_FMAC4 soap_get___ns1__upPic_(struct soap *soap, struct __ns1__upPic_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__upPic_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpLoadFile_(struct soap *soap, struct __ns1__UpLoadFile_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpLoadFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpLoadFile_(struct soap *soap, const struct __ns1__UpLoadFile_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UpLoadFile(soap, &a->ns1__UpLoadFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpLoadFile_(struct soap *soap, const char *tag, int id, const struct __ns1__UpLoadFile_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UpLoadFile(soap, "ns1:UpLoadFile", -1, &a->ns1__UpLoadFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpLoadFile_ * SOAP_FMAC4 soap_in___ns1__UpLoadFile_(struct soap *soap, const char *tag, struct __ns1__UpLoadFile_ *a, const char *type)
{
	size_t soap_flag_ns1__UpLoadFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UpLoadFile_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpLoadFile_, sizeof(struct __ns1__UpLoadFile_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpLoadFile_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpLoadFile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__UpLoadFile(soap, "ns1:UpLoadFile", &a->ns1__UpLoadFile, ""))
				{	soap_flag_ns1__UpLoadFile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__UpLoadFile_ * SOAP_FMAC2 soap_instantiate___ns1__UpLoadFile_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpLoadFile_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UpLoadFile_ *p;
	size_t k = sizeof(struct __ns1__UpLoadFile_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__UpLoadFile_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__UpLoadFile_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__UpLoadFile_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UpLoadFile_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpLoadFile_(struct soap *soap, const struct __ns1__UpLoadFile_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UpLoadFile_(soap, tag ? tag : "-ns1:UpLoadFile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpLoadFile_ * SOAP_FMAC4 soap_get___ns1__UpLoadFile_(struct soap *soap, struct __ns1__UpLoadFile_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpLoadFile_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAPVupdater_(struct soap *soap, struct __ns1__GetAPVupdater_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAPVupdater = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAPVupdater_(struct soap *soap, const struct __ns1__GetAPVupdater_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetAPVupdater(soap, &a->ns1__GetAPVupdater);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAPVupdater_(struct soap *soap, const char *tag, int id, const struct __ns1__GetAPVupdater_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetAPVupdater(soap, "ns1:GetAPVupdater", -1, &a->ns1__GetAPVupdater, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAPVupdater_ * SOAP_FMAC4 soap_in___ns1__GetAPVupdater_(struct soap *soap, const char *tag, struct __ns1__GetAPVupdater_ *a, const char *type)
{
	size_t soap_flag_ns1__GetAPVupdater = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetAPVupdater_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAPVupdater_, sizeof(struct __ns1__GetAPVupdater_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAPVupdater_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAPVupdater && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetAPVupdater(soap, "ns1:GetAPVupdater", &a->ns1__GetAPVupdater, ""))
				{	soap_flag_ns1__GetAPVupdater--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetAPVupdater_ * SOAP_FMAC2 soap_instantiate___ns1__GetAPVupdater_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAPVupdater_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetAPVupdater_ *p;
	size_t k = sizeof(struct __ns1__GetAPVupdater_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetAPVupdater_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetAPVupdater_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetAPVupdater_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetAPVupdater_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAPVupdater_(struct soap *soap, const struct __ns1__GetAPVupdater_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetAPVupdater_(soap, tag ? tag : "-ns1:GetAPVupdater", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAPVupdater_ * SOAP_FMAC4 soap_get___ns1__GetAPVupdater_(struct soap *soap, struct __ns1__GetAPVupdater_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAPVupdater_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetXHYDGLXTupdater_(struct soap *soap, struct __ns1__GetXHYDGLXTupdater_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetXHYDGLXTupdater = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetXHYDGLXTupdater_(struct soap *soap, const struct __ns1__GetXHYDGLXTupdater_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetXHYDGLXTupdater(soap, &a->ns1__GetXHYDGLXTupdater);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetXHYDGLXTupdater_(struct soap *soap, const char *tag, int id, const struct __ns1__GetXHYDGLXTupdater_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetXHYDGLXTupdater(soap, "ns1:GetXHYDGLXTupdater", -1, &a->ns1__GetXHYDGLXTupdater, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetXHYDGLXTupdater_ * SOAP_FMAC4 soap_in___ns1__GetXHYDGLXTupdater_(struct soap *soap, const char *tag, struct __ns1__GetXHYDGLXTupdater_ *a, const char *type)
{
	size_t soap_flag_ns1__GetXHYDGLXTupdater = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetXHYDGLXTupdater_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetXHYDGLXTupdater_, sizeof(struct __ns1__GetXHYDGLXTupdater_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetXHYDGLXTupdater_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetXHYDGLXTupdater && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetXHYDGLXTupdater(soap, "ns1:GetXHYDGLXTupdater", &a->ns1__GetXHYDGLXTupdater, ""))
				{	soap_flag_ns1__GetXHYDGLXTupdater--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetXHYDGLXTupdater_ * SOAP_FMAC2 soap_instantiate___ns1__GetXHYDGLXTupdater_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetXHYDGLXTupdater_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetXHYDGLXTupdater_ *p;
	size_t k = sizeof(struct __ns1__GetXHYDGLXTupdater_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetXHYDGLXTupdater_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetXHYDGLXTupdater_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetXHYDGLXTupdater_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetXHYDGLXTupdater_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetXHYDGLXTupdater_(struct soap *soap, const struct __ns1__GetXHYDGLXTupdater_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetXHYDGLXTupdater_(soap, tag ? tag : "-ns1:GetXHYDGLXTupdater", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetXHYDGLXTupdater_ * SOAP_FMAC4 soap_get___ns1__GetXHYDGLXTupdater_(struct soap *soap, struct __ns1__GetXHYDGLXTupdater_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetXHYDGLXTupdater_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ExecuteSqlForColb_(struct soap *soap, struct __ns1__ExecuteSqlForColb_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ExecuteSqlForColb = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ExecuteSqlForColb_(struct soap *soap, const struct __ns1__ExecuteSqlForColb_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ExecuteSqlForColb(soap, &a->ns1__ExecuteSqlForColb);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ExecuteSqlForColb_(struct soap *soap, const char *tag, int id, const struct __ns1__ExecuteSqlForColb_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ExecuteSqlForColb(soap, "ns1:ExecuteSqlForColb", -1, &a->ns1__ExecuteSqlForColb, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExecuteSqlForColb_ * SOAP_FMAC4 soap_in___ns1__ExecuteSqlForColb_(struct soap *soap, const char *tag, struct __ns1__ExecuteSqlForColb_ *a, const char *type)
{
	size_t soap_flag_ns1__ExecuteSqlForColb = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ExecuteSqlForColb_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ExecuteSqlForColb_, sizeof(struct __ns1__ExecuteSqlForColb_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ExecuteSqlForColb_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ExecuteSqlForColb && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ExecuteSqlForColb(soap, "ns1:ExecuteSqlForColb", &a->ns1__ExecuteSqlForColb, ""))
				{	soap_flag_ns1__ExecuteSqlForColb--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ExecuteSqlForColb_ * SOAP_FMAC2 soap_instantiate___ns1__ExecuteSqlForColb_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ExecuteSqlForColb_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ExecuteSqlForColb_ *p;
	size_t k = sizeof(struct __ns1__ExecuteSqlForColb_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ExecuteSqlForColb_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ExecuteSqlForColb_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ExecuteSqlForColb_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ExecuteSqlForColb_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ExecuteSqlForColb_(struct soap *soap, const struct __ns1__ExecuteSqlForColb_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ExecuteSqlForColb_(soap, tag ? tag : "-ns1:ExecuteSqlForColb", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExecuteSqlForColb_ * SOAP_FMAC4 soap_get___ns1__ExecuteSqlForColb_(struct soap *soap, struct __ns1__ExecuteSqlForColb_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ExecuteSqlForColb_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpLoadData_(struct soap *soap, struct __ns1__UpLoadData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpLoadData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpLoadData_(struct soap *soap, const struct __ns1__UpLoadData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UpLoadData(soap, &a->ns1__UpLoadData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpLoadData_(struct soap *soap, const char *tag, int id, const struct __ns1__UpLoadData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UpLoadData(soap, "ns1:UpLoadData", -1, &a->ns1__UpLoadData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpLoadData_ * SOAP_FMAC4 soap_in___ns1__UpLoadData_(struct soap *soap, const char *tag, struct __ns1__UpLoadData_ *a, const char *type)
{
	size_t soap_flag_ns1__UpLoadData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UpLoadData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpLoadData_, sizeof(struct __ns1__UpLoadData_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpLoadData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpLoadData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__UpLoadData(soap, "ns1:UpLoadData", &a->ns1__UpLoadData, ""))
				{	soap_flag_ns1__UpLoadData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__UpLoadData_ * SOAP_FMAC2 soap_instantiate___ns1__UpLoadData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpLoadData_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UpLoadData_ *p;
	size_t k = sizeof(struct __ns1__UpLoadData_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__UpLoadData_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__UpLoadData_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__UpLoadData_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UpLoadData_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpLoadData_(struct soap *soap, const struct __ns1__UpLoadData_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UpLoadData_(soap, tag ? tag : "-ns1:UpLoadData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpLoadData_ * SOAP_FMAC4 soap_get___ns1__UpLoadData_(struct soap *soap, struct __ns1__UpLoadData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpLoadData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__TcdSendup_(struct soap *soap, struct __ns1__TcdSendup_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__TcdSendup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__TcdSendup_(struct soap *soap, const struct __ns1__TcdSendup_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__TcdSendup(soap, &a->ns1__TcdSendup);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__TcdSendup_(struct soap *soap, const char *tag, int id, const struct __ns1__TcdSendup_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__TcdSendup(soap, "ns1:TcdSendup", -1, &a->ns1__TcdSendup, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TcdSendup_ * SOAP_FMAC4 soap_in___ns1__TcdSendup_(struct soap *soap, const char *tag, struct __ns1__TcdSendup_ *a, const char *type)
{
	size_t soap_flag_ns1__TcdSendup = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__TcdSendup_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__TcdSendup_, sizeof(struct __ns1__TcdSendup_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__TcdSendup_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__TcdSendup && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__TcdSendup(soap, "ns1:TcdSendup", &a->ns1__TcdSendup, ""))
				{	soap_flag_ns1__TcdSendup--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__TcdSendup_ * SOAP_FMAC2 soap_instantiate___ns1__TcdSendup_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__TcdSendup_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__TcdSendup_ *p;
	size_t k = sizeof(struct __ns1__TcdSendup_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__TcdSendup_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__TcdSendup_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__TcdSendup_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__TcdSendup_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__TcdSendup_(struct soap *soap, const struct __ns1__TcdSendup_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__TcdSendup_(soap, tag ? tag : "-ns1:TcdSendup", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TcdSendup_ * SOAP_FMAC4 soap_get___ns1__TcdSendup_(struct soap *soap, struct __ns1__TcdSendup_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__TcdSendup_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__TcdQuery_(struct soap *soap, struct __ns1__TcdQuery_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__TcdQuery = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__TcdQuery_(struct soap *soap, const struct __ns1__TcdQuery_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__TcdQuery(soap, &a->ns1__TcdQuery);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__TcdQuery_(struct soap *soap, const char *tag, int id, const struct __ns1__TcdQuery_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__TcdQuery(soap, "ns1:TcdQuery", -1, &a->ns1__TcdQuery, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TcdQuery_ * SOAP_FMAC4 soap_in___ns1__TcdQuery_(struct soap *soap, const char *tag, struct __ns1__TcdQuery_ *a, const char *type)
{
	size_t soap_flag_ns1__TcdQuery = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__TcdQuery_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__TcdQuery_, sizeof(struct __ns1__TcdQuery_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__TcdQuery_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__TcdQuery && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__TcdQuery(soap, "ns1:TcdQuery", &a->ns1__TcdQuery, ""))
				{	soap_flag_ns1__TcdQuery--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__TcdQuery_ * SOAP_FMAC2 soap_instantiate___ns1__TcdQuery_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__TcdQuery_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__TcdQuery_ *p;
	size_t k = sizeof(struct __ns1__TcdQuery_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__TcdQuery_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__TcdQuery_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__TcdQuery_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__TcdQuery_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__TcdQuery_(struct soap *soap, const struct __ns1__TcdQuery_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__TcdQuery_(soap, tag ? tag : "-ns1:TcdQuery", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TcdQuery_ * SOAP_FMAC4 soap_get___ns1__TcdQuery_(struct soap *soap, struct __ns1__TcdQuery_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__TcdQuery_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QueryPhotobw_(struct soap *soap, struct __ns1__QueryPhotobw_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QueryPhotobw = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QueryPhotobw_(struct soap *soap, const struct __ns1__QueryPhotobw_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__QueryPhotobw(soap, &a->ns1__QueryPhotobw);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QueryPhotobw_(struct soap *soap, const char *tag, int id, const struct __ns1__QueryPhotobw_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__QueryPhotobw(soap, "ns1:QueryPhotobw", -1, &a->ns1__QueryPhotobw, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QueryPhotobw_ * SOAP_FMAC4 soap_in___ns1__QueryPhotobw_(struct soap *soap, const char *tag, struct __ns1__QueryPhotobw_ *a, const char *type)
{
	size_t soap_flag_ns1__QueryPhotobw = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QueryPhotobw_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__QueryPhotobw_, sizeof(struct __ns1__QueryPhotobw_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QueryPhotobw_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QueryPhotobw && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__QueryPhotobw(soap, "ns1:QueryPhotobw", &a->ns1__QueryPhotobw, ""))
				{	soap_flag_ns1__QueryPhotobw--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QueryPhotobw_ * SOAP_FMAC2 soap_instantiate___ns1__QueryPhotobw_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QueryPhotobw_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QueryPhotobw_ *p;
	size_t k = sizeof(struct __ns1__QueryPhotobw_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__QueryPhotobw_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__QueryPhotobw_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__QueryPhotobw_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QueryPhotobw_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QueryPhotobw_(struct soap *soap, const struct __ns1__QueryPhotobw_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QueryPhotobw_(soap, tag ? tag : "-ns1:QueryPhotobw", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QueryPhotobw_ * SOAP_FMAC4 soap_get___ns1__QueryPhotobw_(struct soap *soap, struct __ns1__QueryPhotobw_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QueryPhotobw_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetOsDateTime_(struct soap *soap, struct __ns1__GetOsDateTime_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetOsDateTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetOsDateTime_(struct soap *soap, const struct __ns1__GetOsDateTime_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetOsDateTime(soap, &a->ns1__GetOsDateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetOsDateTime_(struct soap *soap, const char *tag, int id, const struct __ns1__GetOsDateTime_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetOsDateTime(soap, "ns1:GetOsDateTime", -1, &a->ns1__GetOsDateTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetOsDateTime_ * SOAP_FMAC4 soap_in___ns1__GetOsDateTime_(struct soap *soap, const char *tag, struct __ns1__GetOsDateTime_ *a, const char *type)
{
	size_t soap_flag_ns1__GetOsDateTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetOsDateTime_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetOsDateTime_, sizeof(struct __ns1__GetOsDateTime_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetOsDateTime_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetOsDateTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetOsDateTime(soap, "ns1:GetOsDateTime", &a->ns1__GetOsDateTime, ""))
				{	soap_flag_ns1__GetOsDateTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetOsDateTime_ * SOAP_FMAC2 soap_instantiate___ns1__GetOsDateTime_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetOsDateTime_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetOsDateTime_ *p;
	size_t k = sizeof(struct __ns1__GetOsDateTime_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetOsDateTime_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetOsDateTime_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetOsDateTime_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetOsDateTime_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetOsDateTime_(struct soap *soap, const struct __ns1__GetOsDateTime_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetOsDateTime_(soap, tag ? tag : "-ns1:GetOsDateTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetOsDateTime_ * SOAP_FMAC4 soap_get___ns1__GetOsDateTime_(struct soap *soap, struct __ns1__GetOsDateTime_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetOsDateTime_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__signedUserInfo_(struct soap *soap, struct __ns1__signedUserInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__signedUserInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__signedUserInfo_(struct soap *soap, const struct __ns1__signedUserInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__signedUserInfo(soap, &a->ns1__signedUserInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__signedUserInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__signedUserInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__signedUserInfo(soap, "ns1:signedUserInfo", -1, &a->ns1__signedUserInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__signedUserInfo_ * SOAP_FMAC4 soap_in___ns1__signedUserInfo_(struct soap *soap, const char *tag, struct __ns1__signedUserInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__signedUserInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__signedUserInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__signedUserInfo_, sizeof(struct __ns1__signedUserInfo_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__signedUserInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__signedUserInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__signedUserInfo(soap, "ns1:signedUserInfo", &a->ns1__signedUserInfo, ""))
				{	soap_flag_ns1__signedUserInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__signedUserInfo_ * SOAP_FMAC2 soap_instantiate___ns1__signedUserInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__signedUserInfo_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__signedUserInfo_ *p;
	size_t k = sizeof(struct __ns1__signedUserInfo_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__signedUserInfo_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__signedUserInfo_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__signedUserInfo_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__signedUserInfo_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__signedUserInfo_(struct soap *soap, const struct __ns1__signedUserInfo_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__signedUserInfo_(soap, tag ? tag : "-ns1:signedUserInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__signedUserInfo_ * SOAP_FMAC4 soap_get___ns1__signedUserInfo_(struct soap *soap, struct __ns1__signedUserInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__signedUserInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetGxdataUpTime_(struct soap *soap, struct __ns1__GetGxdataUpTime_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetGxdataUpTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetGxdataUpTime_(struct soap *soap, const struct __ns1__GetGxdataUpTime_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetGxdataUpTime(soap, &a->ns1__GetGxdataUpTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetGxdataUpTime_(struct soap *soap, const char *tag, int id, const struct __ns1__GetGxdataUpTime_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetGxdataUpTime(soap, "ns1:GetGxdataUpTime", -1, &a->ns1__GetGxdataUpTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetGxdataUpTime_ * SOAP_FMAC4 soap_in___ns1__GetGxdataUpTime_(struct soap *soap, const char *tag, struct __ns1__GetGxdataUpTime_ *a, const char *type)
{
	size_t soap_flag_ns1__GetGxdataUpTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetGxdataUpTime_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetGxdataUpTime_, sizeof(struct __ns1__GetGxdataUpTime_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetGxdataUpTime_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetGxdataUpTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetGxdataUpTime(soap, "ns1:GetGxdataUpTime", &a->ns1__GetGxdataUpTime, ""))
				{	soap_flag_ns1__GetGxdataUpTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetGxdataUpTime_ * SOAP_FMAC2 soap_instantiate___ns1__GetGxdataUpTime_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetGxdataUpTime_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetGxdataUpTime_ *p;
	size_t k = sizeof(struct __ns1__GetGxdataUpTime_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetGxdataUpTime_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetGxdataUpTime_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetGxdataUpTime_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetGxdataUpTime_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetGxdataUpTime_(struct soap *soap, const struct __ns1__GetGxdataUpTime_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetGxdataUpTime_(soap, tag ? tag : "-ns1:GetGxdataUpTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetGxdataUpTime_ * SOAP_FMAC4 soap_get___ns1__GetGxdataUpTime_(struct soap *soap, struct __ns1__GetGxdataUpTime_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetGxdataUpTime_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DownAllPic_(struct soap *soap, struct __ns1__DownAllPic_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DownAllPic = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DownAllPic_(struct soap *soap, const struct __ns1__DownAllPic_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DownAllPic(soap, &a->ns1__DownAllPic);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DownAllPic_(struct soap *soap, const char *tag, int id, const struct __ns1__DownAllPic_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DownAllPic(soap, "ns1:DownAllPic", -1, &a->ns1__DownAllPic, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownAllPic_ * SOAP_FMAC4 soap_in___ns1__DownAllPic_(struct soap *soap, const char *tag, struct __ns1__DownAllPic_ *a, const char *type)
{
	size_t soap_flag_ns1__DownAllPic = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DownAllPic_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DownAllPic_, sizeof(struct __ns1__DownAllPic_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DownAllPic_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DownAllPic && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__DownAllPic(soap, "ns1:DownAllPic", &a->ns1__DownAllPic, ""))
				{	soap_flag_ns1__DownAllPic--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DownAllPic_ * SOAP_FMAC2 soap_instantiate___ns1__DownAllPic_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DownAllPic_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DownAllPic_ *p;
	size_t k = sizeof(struct __ns1__DownAllPic_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__DownAllPic_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__DownAllPic_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__DownAllPic_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DownAllPic_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DownAllPic_(struct soap *soap, const struct __ns1__DownAllPic_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DownAllPic_(soap, tag ? tag : "-ns1:DownAllPic", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownAllPic_ * SOAP_FMAC4 soap_get___ns1__DownAllPic_(struct soap *soap, struct __ns1__DownAllPic_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DownAllPic_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DownPic_(struct soap *soap, struct __ns1__DownPic_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DownPic = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DownPic_(struct soap *soap, const struct __ns1__DownPic_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DownPic(soap, &a->ns1__DownPic);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DownPic_(struct soap *soap, const char *tag, int id, const struct __ns1__DownPic_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DownPic(soap, "ns1:DownPic", -1, &a->ns1__DownPic, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownPic_ * SOAP_FMAC4 soap_in___ns1__DownPic_(struct soap *soap, const char *tag, struct __ns1__DownPic_ *a, const char *type)
{
	size_t soap_flag_ns1__DownPic = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DownPic_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DownPic_, sizeof(struct __ns1__DownPic_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DownPic_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DownPic && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__DownPic(soap, "ns1:DownPic", &a->ns1__DownPic, ""))
				{	soap_flag_ns1__DownPic--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DownPic_ * SOAP_FMAC2 soap_instantiate___ns1__DownPic_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DownPic_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DownPic_ *p;
	size_t k = sizeof(struct __ns1__DownPic_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__DownPic_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__DownPic_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__DownPic_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DownPic_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DownPic_(struct soap *soap, const struct __ns1__DownPic_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DownPic_(soap, tag ? tag : "-ns1:DownPic", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownPic_ * SOAP_FMAC4 soap_get___ns1__DownPic_(struct soap *soap, struct __ns1__DownPic_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DownPic_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SaveFileData_(struct soap *soap, struct __ns1__SaveFileData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SaveFileData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SaveFileData_(struct soap *soap, const struct __ns1__SaveFileData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SaveFileData(soap, &a->ns1__SaveFileData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SaveFileData_(struct soap *soap, const char *tag, int id, const struct __ns1__SaveFileData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SaveFileData(soap, "ns1:SaveFileData", -1, &a->ns1__SaveFileData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SaveFileData_ * SOAP_FMAC4 soap_in___ns1__SaveFileData_(struct soap *soap, const char *tag, struct __ns1__SaveFileData_ *a, const char *type)
{
	size_t soap_flag_ns1__SaveFileData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SaveFileData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SaveFileData_, sizeof(struct __ns1__SaveFileData_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SaveFileData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SaveFileData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SaveFileData(soap, "ns1:SaveFileData", &a->ns1__SaveFileData, ""))
				{	soap_flag_ns1__SaveFileData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SaveFileData_ * SOAP_FMAC2 soap_instantiate___ns1__SaveFileData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SaveFileData_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SaveFileData_ *p;
	size_t k = sizeof(struct __ns1__SaveFileData_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__SaveFileData_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__SaveFileData_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__SaveFileData_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SaveFileData_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SaveFileData_(struct soap *soap, const struct __ns1__SaveFileData_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SaveFileData_(soap, tag ? tag : "-ns1:SaveFileData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SaveFileData_ * SOAP_FMAC4 soap_get___ns1__SaveFileData_(struct soap *soap, struct __ns1__SaveFileData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SaveFileData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SaveData_(struct soap *soap, struct __ns1__SaveData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SaveData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SaveData_(struct soap *soap, const struct __ns1__SaveData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SaveData(soap, &a->ns1__SaveData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SaveData_(struct soap *soap, const char *tag, int id, const struct __ns1__SaveData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SaveData(soap, "ns1:SaveData", -1, &a->ns1__SaveData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SaveData_ * SOAP_FMAC4 soap_in___ns1__SaveData_(struct soap *soap, const char *tag, struct __ns1__SaveData_ *a, const char *type)
{
	size_t soap_flag_ns1__SaveData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SaveData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SaveData_, sizeof(struct __ns1__SaveData_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SaveData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SaveData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SaveData(soap, "ns1:SaveData", &a->ns1__SaveData, ""))
				{	soap_flag_ns1__SaveData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SaveData_ * SOAP_FMAC2 soap_instantiate___ns1__SaveData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SaveData_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SaveData_ *p;
	size_t k = sizeof(struct __ns1__SaveData_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__SaveData_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__SaveData_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__SaveData_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SaveData_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SaveData_(struct soap *soap, const struct __ns1__SaveData_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SaveData_(soap, tag ? tag : "-ns1:SaveData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SaveData_ * SOAP_FMAC4 soap_get___ns1__SaveData_(struct soap *soap, struct __ns1__SaveData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SaveData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ExecuteSql_(struct soap *soap, struct __ns1__ExecuteSql_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ExecuteSql = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ExecuteSql_(struct soap *soap, const struct __ns1__ExecuteSql_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ExecuteSql(soap, &a->ns1__ExecuteSql);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ExecuteSql_(struct soap *soap, const char *tag, int id, const struct __ns1__ExecuteSql_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ExecuteSql(soap, "ns1:ExecuteSql", -1, &a->ns1__ExecuteSql, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExecuteSql_ * SOAP_FMAC4 soap_in___ns1__ExecuteSql_(struct soap *soap, const char *tag, struct __ns1__ExecuteSql_ *a, const char *type)
{
	size_t soap_flag_ns1__ExecuteSql = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ExecuteSql_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ExecuteSql_, sizeof(struct __ns1__ExecuteSql_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ExecuteSql_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ExecuteSql && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ExecuteSql(soap, "ns1:ExecuteSql", &a->ns1__ExecuteSql, ""))
				{	soap_flag_ns1__ExecuteSql--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ExecuteSql_ * SOAP_FMAC2 soap_instantiate___ns1__ExecuteSql_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ExecuteSql_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ExecuteSql_ *p;
	size_t k = sizeof(struct __ns1__ExecuteSql_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ExecuteSql_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ExecuteSql_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ExecuteSql_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ExecuteSql_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ExecuteSql_(struct soap *soap, const struct __ns1__ExecuteSql_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ExecuteSql_(soap, tag ? tag : "-ns1:ExecuteSql", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExecuteSql_ * SOAP_FMAC4 soap_get___ns1__ExecuteSql_(struct soap *soap, struct __ns1__ExecuteSql_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ExecuteSql_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QueryDataCount_(struct soap *soap, struct __ns1__QueryDataCount_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QueryDataCount = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QueryDataCount_(struct soap *soap, const struct __ns1__QueryDataCount_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__QueryDataCount(soap, &a->ns1__QueryDataCount);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QueryDataCount_(struct soap *soap, const char *tag, int id, const struct __ns1__QueryDataCount_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__QueryDataCount(soap, "ns1:QueryDataCount", -1, &a->ns1__QueryDataCount, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QueryDataCount_ * SOAP_FMAC4 soap_in___ns1__QueryDataCount_(struct soap *soap, const char *tag, struct __ns1__QueryDataCount_ *a, const char *type)
{
	size_t soap_flag_ns1__QueryDataCount = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QueryDataCount_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__QueryDataCount_, sizeof(struct __ns1__QueryDataCount_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QueryDataCount_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QueryDataCount && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__QueryDataCount(soap, "ns1:QueryDataCount", &a->ns1__QueryDataCount, ""))
				{	soap_flag_ns1__QueryDataCount--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QueryDataCount_ * SOAP_FMAC2 soap_instantiate___ns1__QueryDataCount_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QueryDataCount_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QueryDataCount_ *p;
	size_t k = sizeof(struct __ns1__QueryDataCount_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__QueryDataCount_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__QueryDataCount_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__QueryDataCount_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QueryDataCount_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QueryDataCount_(struct soap *soap, const struct __ns1__QueryDataCount_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QueryDataCount_(soap, tag ? tag : "-ns1:QueryDataCount", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QueryDataCount_ * SOAP_FMAC4 soap_get___ns1__QueryDataCount_(struct soap *soap, struct __ns1__QueryDataCount_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QueryDataCount_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QueryData_(struct soap *soap, struct __ns1__QueryData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QueryData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QueryData_(struct soap *soap, const struct __ns1__QueryData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__QueryData(soap, &a->ns1__QueryData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QueryData_(struct soap *soap, const char *tag, int id, const struct __ns1__QueryData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__QueryData(soap, "ns1:QueryData", -1, &a->ns1__QueryData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QueryData_ * SOAP_FMAC4 soap_in___ns1__QueryData_(struct soap *soap, const char *tag, struct __ns1__QueryData_ *a, const char *type)
{
	size_t soap_flag_ns1__QueryData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QueryData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__QueryData_, sizeof(struct __ns1__QueryData_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QueryData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QueryData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__QueryData(soap, "ns1:QueryData", &a->ns1__QueryData, ""))
				{	soap_flag_ns1__QueryData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QueryData_ * SOAP_FMAC2 soap_instantiate___ns1__QueryData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QueryData_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QueryData_ *p;
	size_t k = sizeof(struct __ns1__QueryData_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__QueryData_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__QueryData_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__QueryData_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QueryData_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QueryData_(struct soap *soap, const struct __ns1__QueryData_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QueryData_(soap, tag ? tag : "-ns1:QueryData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QueryData_ * SOAP_FMAC4 soap_get___ns1__QueryData_(struct soap *soap, struct __ns1__QueryData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QueryData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDBString_(struct soap *soap, struct __ns1__GetDBString_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDBString = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDBString_(struct soap *soap, const struct __ns1__GetDBString_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetDBString(soap, &a->ns1__GetDBString);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDBString_(struct soap *soap, const char *tag, int id, const struct __ns1__GetDBString_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetDBString(soap, "ns1:GetDBString", -1, &a->ns1__GetDBString, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDBString_ * SOAP_FMAC4 soap_in___ns1__GetDBString_(struct soap *soap, const char *tag, struct __ns1__GetDBString_ *a, const char *type)
{
	size_t soap_flag_ns1__GetDBString = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetDBString_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDBString_, sizeof(struct __ns1__GetDBString_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDBString_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDBString && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetDBString(soap, "ns1:GetDBString", &a->ns1__GetDBString, ""))
				{	soap_flag_ns1__GetDBString--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetDBString_ * SOAP_FMAC2 soap_instantiate___ns1__GetDBString_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDBString_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetDBString_ *p;
	size_t k = sizeof(struct __ns1__GetDBString_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetDBString_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetDBString_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetDBString_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetDBString_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDBString_(struct soap *soap, const struct __ns1__GetDBString_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetDBString_(soap, tag ? tag : "-ns1:GetDBString", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDBString_ * SOAP_FMAC4 soap_get___ns1__GetDBString_(struct soap *soap, struct __ns1__GetDBString_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDBString_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__HelloWorld_(struct soap *soap, struct __ns1__HelloWorld_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__HelloWorld = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__HelloWorld_(struct soap *soap, const struct __ns1__HelloWorld_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__HelloWorld(soap, &a->ns1__HelloWorld);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__HelloWorld_(struct soap *soap, const char *tag, int id, const struct __ns1__HelloWorld_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__HelloWorld(soap, "ns1:HelloWorld", -1, &a->ns1__HelloWorld, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__HelloWorld_ * SOAP_FMAC4 soap_in___ns1__HelloWorld_(struct soap *soap, const char *tag, struct __ns1__HelloWorld_ *a, const char *type)
{
	size_t soap_flag_ns1__HelloWorld = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__HelloWorld_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__HelloWorld_, sizeof(struct __ns1__HelloWorld_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__HelloWorld_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__HelloWorld && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__HelloWorld(soap, "ns1:HelloWorld", &a->ns1__HelloWorld, ""))
				{	soap_flag_ns1__HelloWorld--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__HelloWorld_ * SOAP_FMAC2 soap_instantiate___ns1__HelloWorld_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__HelloWorld_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__HelloWorld_ *p;
	size_t k = sizeof(struct __ns1__HelloWorld_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__HelloWorld_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__HelloWorld_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__HelloWorld_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__HelloWorld_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__HelloWorld_(struct soap *soap, const struct __ns1__HelloWorld_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__HelloWorld_(soap, tag ? tag : "-ns1:HelloWorld", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__HelloWorld_ * SOAP_FMAC4 soap_get___ns1__HelloWorld_(struct soap *soap, struct __ns1__HelloWorld_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__HelloWorld_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CheckDevCode_(struct soap *soap, struct __ns1__CheckDevCode_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CheckDevCode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CheckDevCode_(struct soap *soap, const struct __ns1__CheckDevCode_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CheckDevCode(soap, &a->ns1__CheckDevCode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CheckDevCode_(struct soap *soap, const char *tag, int id, const struct __ns1__CheckDevCode_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CheckDevCode(soap, "ns1:CheckDevCode", -1, &a->ns1__CheckDevCode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckDevCode_ * SOAP_FMAC4 soap_in___ns1__CheckDevCode_(struct soap *soap, const char *tag, struct __ns1__CheckDevCode_ *a, const char *type)
{
	size_t soap_flag_ns1__CheckDevCode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CheckDevCode_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CheckDevCode_, sizeof(struct __ns1__CheckDevCode_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CheckDevCode_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CheckDevCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CheckDevCode(soap, "ns1:CheckDevCode", &a->ns1__CheckDevCode, ""))
				{	soap_flag_ns1__CheckDevCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CheckDevCode_ * SOAP_FMAC2 soap_instantiate___ns1__CheckDevCode_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CheckDevCode_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CheckDevCode_ *p;
	size_t k = sizeof(struct __ns1__CheckDevCode_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__CheckDevCode_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__CheckDevCode_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__CheckDevCode_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CheckDevCode_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CheckDevCode_(struct soap *soap, const struct __ns1__CheckDevCode_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CheckDevCode_(soap, tag ? tag : "-ns1:CheckDevCode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckDevCode_ * SOAP_FMAC4 soap_get___ns1__CheckDevCode_(struct soap *soap, struct __ns1__CheckDevCode_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CheckDevCode_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDevCode_(struct soap *soap, struct __ns1__GetDevCode_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDevCode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDevCode_(struct soap *soap, const struct __ns1__GetDevCode_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetDevCode(soap, &a->ns1__GetDevCode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDevCode_(struct soap *soap, const char *tag, int id, const struct __ns1__GetDevCode_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetDevCode(soap, "ns1:GetDevCode", -1, &a->ns1__GetDevCode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDevCode_ * SOAP_FMAC4 soap_in___ns1__GetDevCode_(struct soap *soap, const char *tag, struct __ns1__GetDevCode_ *a, const char *type)
{
	size_t soap_flag_ns1__GetDevCode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetDevCode_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDevCode_, sizeof(struct __ns1__GetDevCode_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDevCode_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDevCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetDevCode(soap, "ns1:GetDevCode", &a->ns1__GetDevCode, ""))
				{	soap_flag_ns1__GetDevCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetDevCode_ * SOAP_FMAC2 soap_instantiate___ns1__GetDevCode_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDevCode_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetDevCode_ *p;
	size_t k = sizeof(struct __ns1__GetDevCode_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetDevCode_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetDevCode_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetDevCode_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetDevCode_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDevCode_(struct soap *soap, const struct __ns1__GetDevCode_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetDevCode_(soap, tag ? tag : "-ns1:GetDevCode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDevCode_ * SOAP_FMAC4 soap_get___ns1__GetDevCode_(struct soap *soap, struct __ns1__GetDevCode_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDevCode_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetRyUnit_(struct soap *soap, struct __ns1__GetRyUnit_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetRyUnit = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetRyUnit_(struct soap *soap, const struct __ns1__GetRyUnit_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetRyUnit(soap, &a->ns1__GetRyUnit);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetRyUnit_(struct soap *soap, const char *tag, int id, const struct __ns1__GetRyUnit_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetRyUnit(soap, "ns1:GetRyUnit", -1, &a->ns1__GetRyUnit, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRyUnit_ * SOAP_FMAC4 soap_in___ns1__GetRyUnit_(struct soap *soap, const char *tag, struct __ns1__GetRyUnit_ *a, const char *type)
{
	size_t soap_flag_ns1__GetRyUnit = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetRyUnit_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetRyUnit_, sizeof(struct __ns1__GetRyUnit_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetRyUnit_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetRyUnit && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetRyUnit(soap, "ns1:GetRyUnit", &a->ns1__GetRyUnit, ""))
				{	soap_flag_ns1__GetRyUnit--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetRyUnit_ * SOAP_FMAC2 soap_instantiate___ns1__GetRyUnit_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetRyUnit_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetRyUnit_ *p;
	size_t k = sizeof(struct __ns1__GetRyUnit_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetRyUnit_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetRyUnit_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetRyUnit_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetRyUnit_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetRyUnit_(struct soap *soap, const struct __ns1__GetRyUnit_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetRyUnit_(soap, tag ? tag : "-ns1:GetRyUnit", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRyUnit_ * SOAP_FMAC4 soap_get___ns1__GetRyUnit_(struct soap *soap, struct __ns1__GetRyUnit_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetRyUnit_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CheckLoginUser_(struct soap *soap, struct __ns1__CheckLoginUser_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CheckLoginUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CheckLoginUser_(struct soap *soap, const struct __ns1__CheckLoginUser_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CheckLoginUser(soap, &a->ns1__CheckLoginUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CheckLoginUser_(struct soap *soap, const char *tag, int id, const struct __ns1__CheckLoginUser_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CheckLoginUser(soap, "ns1:CheckLoginUser", -1, &a->ns1__CheckLoginUser, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckLoginUser_ * SOAP_FMAC4 soap_in___ns1__CheckLoginUser_(struct soap *soap, const char *tag, struct __ns1__CheckLoginUser_ *a, const char *type)
{
	size_t soap_flag_ns1__CheckLoginUser = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CheckLoginUser_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CheckLoginUser_, sizeof(struct __ns1__CheckLoginUser_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CheckLoginUser_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CheckLoginUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CheckLoginUser(soap, "ns1:CheckLoginUser", &a->ns1__CheckLoginUser, ""))
				{	soap_flag_ns1__CheckLoginUser--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CheckLoginUser_ * SOAP_FMAC2 soap_instantiate___ns1__CheckLoginUser_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CheckLoginUser_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CheckLoginUser_ *p;
	size_t k = sizeof(struct __ns1__CheckLoginUser_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__CheckLoginUser_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__CheckLoginUser_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__CheckLoginUser_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CheckLoginUser_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CheckLoginUser_(struct soap *soap, const struct __ns1__CheckLoginUser_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CheckLoginUser_(soap, tag ? tag : "-ns1:CheckLoginUser", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckLoginUser_ * SOAP_FMAC4 soap_get___ns1__CheckLoginUser_(struct soap *soap, struct __ns1__CheckLoginUser_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CheckLoginUser_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetPropName_(struct soap *soap, struct __ns1__GetPropName_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPropName = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetPropName_(struct soap *soap, const struct __ns1__GetPropName_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetPropName(soap, &a->ns1__GetPropName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetPropName_(struct soap *soap, const char *tag, int id, const struct __ns1__GetPropName_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetPropName(soap, "ns1:GetPropName", -1, &a->ns1__GetPropName, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPropName_ * SOAP_FMAC4 soap_in___ns1__GetPropName_(struct soap *soap, const char *tag, struct __ns1__GetPropName_ *a, const char *type)
{
	size_t soap_flag_ns1__GetPropName = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetPropName_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetPropName_, sizeof(struct __ns1__GetPropName_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetPropName_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPropName && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetPropName(soap, "ns1:GetPropName", &a->ns1__GetPropName, ""))
				{	soap_flag_ns1__GetPropName--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetPropName_ * SOAP_FMAC2 soap_instantiate___ns1__GetPropName_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetPropName_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetPropName_ *p;
	size_t k = sizeof(struct __ns1__GetPropName_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetPropName_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetPropName_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetPropName_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetPropName_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetPropName_(struct soap *soap, const struct __ns1__GetPropName_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetPropName_(soap, tag ? tag : "-ns1:GetPropName", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPropName_ * SOAP_FMAC4 soap_get___ns1__GetPropName_(struct soap *soap, struct __ns1__GetPropName_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetPropName_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetPropList_(struct soap *soap, struct __ns1__GetPropList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPropList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetPropList_(struct soap *soap, const struct __ns1__GetPropList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetPropList(soap, &a->ns1__GetPropList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetPropList_(struct soap *soap, const char *tag, int id, const struct __ns1__GetPropList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetPropList(soap, "ns1:GetPropList", -1, &a->ns1__GetPropList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPropList_ * SOAP_FMAC4 soap_in___ns1__GetPropList_(struct soap *soap, const char *tag, struct __ns1__GetPropList_ *a, const char *type)
{
	size_t soap_flag_ns1__GetPropList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetPropList_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetPropList_, sizeof(struct __ns1__GetPropList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetPropList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPropList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetPropList(soap, "ns1:GetPropList", &a->ns1__GetPropList, ""))
				{	soap_flag_ns1__GetPropList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetPropList_ * SOAP_FMAC2 soap_instantiate___ns1__GetPropList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetPropList_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetPropList_ *p;
	size_t k = sizeof(struct __ns1__GetPropList_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetPropList_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetPropList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetPropList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetPropList_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetPropList_(struct soap *soap, const struct __ns1__GetPropList_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetPropList_(soap, tag ? tag : "-ns1:GetPropList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPropList_ * SOAP_FMAC4 soap_get___ns1__GetPropList_(struct soap *soap, struct __ns1__GetPropList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetPropList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetYjzhZskDevFlowChartList_(struct soap *soap, struct __ns1__GetYjzhZskDevFlowChartList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetYjzhZskDevFlowChartList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetYjzhZskDevFlowChartList_(struct soap *soap, const struct __ns1__GetYjzhZskDevFlowChartList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetYjzhZskDevFlowChartList(soap, &a->ns1__GetYjzhZskDevFlowChartList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetYjzhZskDevFlowChartList_(struct soap *soap, const char *tag, int id, const struct __ns1__GetYjzhZskDevFlowChartList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetYjzhZskDevFlowChartList(soap, "ns1:GetYjzhZskDevFlowChartList", -1, &a->ns1__GetYjzhZskDevFlowChartList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetYjzhZskDevFlowChartList_ * SOAP_FMAC4 soap_in___ns1__GetYjzhZskDevFlowChartList_(struct soap *soap, const char *tag, struct __ns1__GetYjzhZskDevFlowChartList_ *a, const char *type)
{
	size_t soap_flag_ns1__GetYjzhZskDevFlowChartList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetYjzhZskDevFlowChartList_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetYjzhZskDevFlowChartList_, sizeof(struct __ns1__GetYjzhZskDevFlowChartList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetYjzhZskDevFlowChartList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetYjzhZskDevFlowChartList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetYjzhZskDevFlowChartList(soap, "ns1:GetYjzhZskDevFlowChartList", &a->ns1__GetYjzhZskDevFlowChartList, ""))
				{	soap_flag_ns1__GetYjzhZskDevFlowChartList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetYjzhZskDevFlowChartList_ * SOAP_FMAC2 soap_instantiate___ns1__GetYjzhZskDevFlowChartList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetYjzhZskDevFlowChartList_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetYjzhZskDevFlowChartList_ *p;
	size_t k = sizeof(struct __ns1__GetYjzhZskDevFlowChartList_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetYjzhZskDevFlowChartList_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetYjzhZskDevFlowChartList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetYjzhZskDevFlowChartList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetYjzhZskDevFlowChartList_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetYjzhZskDevFlowChartList_(struct soap *soap, const struct __ns1__GetYjzhZskDevFlowChartList_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetYjzhZskDevFlowChartList_(soap, tag ? tag : "-ns1:GetYjzhZskDevFlowChartList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetYjzhZskDevFlowChartList_ * SOAP_FMAC4 soap_get___ns1__GetYjzhZskDevFlowChartList_(struct soap *soap, struct __ns1__GetYjzhZskDevFlowChartList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetYjzhZskDevFlowChartList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetYjzhZskOtherFlowChartList_(struct soap *soap, struct __ns1__GetYjzhZskOtherFlowChartList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetYjzhZskOtherFlowChartList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetYjzhZskOtherFlowChartList_(struct soap *soap, const struct __ns1__GetYjzhZskOtherFlowChartList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetYjzhZskOtherFlowChartList(soap, &a->ns1__GetYjzhZskOtherFlowChartList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetYjzhZskOtherFlowChartList_(struct soap *soap, const char *tag, int id, const struct __ns1__GetYjzhZskOtherFlowChartList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetYjzhZskOtherFlowChartList(soap, "ns1:GetYjzhZskOtherFlowChartList", -1, &a->ns1__GetYjzhZskOtherFlowChartList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetYjzhZskOtherFlowChartList_ * SOAP_FMAC4 soap_in___ns1__GetYjzhZskOtherFlowChartList_(struct soap *soap, const char *tag, struct __ns1__GetYjzhZskOtherFlowChartList_ *a, const char *type)
{
	size_t soap_flag_ns1__GetYjzhZskOtherFlowChartList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetYjzhZskOtherFlowChartList_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetYjzhZskOtherFlowChartList_, sizeof(struct __ns1__GetYjzhZskOtherFlowChartList_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetYjzhZskOtherFlowChartList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetYjzhZskOtherFlowChartList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetYjzhZskOtherFlowChartList(soap, "ns1:GetYjzhZskOtherFlowChartList", &a->ns1__GetYjzhZskOtherFlowChartList, ""))
				{	soap_flag_ns1__GetYjzhZskOtherFlowChartList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetYjzhZskOtherFlowChartList_ * SOAP_FMAC2 soap_instantiate___ns1__GetYjzhZskOtherFlowChartList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetYjzhZskOtherFlowChartList_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetYjzhZskOtherFlowChartList_ *p;
	size_t k = sizeof(struct __ns1__GetYjzhZskOtherFlowChartList_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetYjzhZskOtherFlowChartList_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetYjzhZskOtherFlowChartList_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetYjzhZskOtherFlowChartList_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetYjzhZskOtherFlowChartList_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetYjzhZskOtherFlowChartList_(struct soap *soap, const struct __ns1__GetYjzhZskOtherFlowChartList_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetYjzhZskOtherFlowChartList_(soap, tag ? tag : "-ns1:GetYjzhZskOtherFlowChartList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetYjzhZskOtherFlowChartList_ * SOAP_FMAC4 soap_get___ns1__GetYjzhZskOtherFlowChartList_(struct soap *soap, struct __ns1__GetYjzhZskOtherFlowChartList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetYjzhZskOtherFlowChartList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetYjzhZskGzFlow_(struct soap *soap, struct __ns1__GetYjzhZskGzFlow_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetYjzhZskGzFlow = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetYjzhZskGzFlow_(struct soap *soap, const struct __ns1__GetYjzhZskGzFlow_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetYjzhZskGzFlow(soap, &a->ns1__GetYjzhZskGzFlow);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetYjzhZskGzFlow_(struct soap *soap, const char *tag, int id, const struct __ns1__GetYjzhZskGzFlow_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetYjzhZskGzFlow(soap, "ns1:GetYjzhZskGzFlow", -1, &a->ns1__GetYjzhZskGzFlow, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetYjzhZskGzFlow_ * SOAP_FMAC4 soap_in___ns1__GetYjzhZskGzFlow_(struct soap *soap, const char *tag, struct __ns1__GetYjzhZskGzFlow_ *a, const char *type)
{
	size_t soap_flag_ns1__GetYjzhZskGzFlow = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetYjzhZskGzFlow_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetYjzhZskGzFlow_, sizeof(struct __ns1__GetYjzhZskGzFlow_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetYjzhZskGzFlow_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetYjzhZskGzFlow && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetYjzhZskGzFlow(soap, "ns1:GetYjzhZskGzFlow", &a->ns1__GetYjzhZskGzFlow, ""))
				{	soap_flag_ns1__GetYjzhZskGzFlow--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetYjzhZskGzFlow_ * SOAP_FMAC2 soap_instantiate___ns1__GetYjzhZskGzFlow_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetYjzhZskGzFlow_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetYjzhZskGzFlow_ *p;
	size_t k = sizeof(struct __ns1__GetYjzhZskGzFlow_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetYjzhZskGzFlow_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetYjzhZskGzFlow_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetYjzhZskGzFlow_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetYjzhZskGzFlow_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetYjzhZskGzFlow_(struct soap *soap, const struct __ns1__GetYjzhZskGzFlow_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetYjzhZskGzFlow_(soap, tag ? tag : "-ns1:GetYjzhZskGzFlow", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetYjzhZskGzFlow_ * SOAP_FMAC4 soap_get___ns1__GetYjzhZskGzFlow_(struct soap *soap, struct __ns1__GetYjzhZskGzFlow_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetYjzhZskGzFlow_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetYjzhZskAlarmTypes(struct soap *soap, struct __ns1__GetYjzhZskAlarmTypes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetYjzhZskAlarmTypes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetYjzhZskAlarmTypes(struct soap *soap, const struct __ns1__GetYjzhZskAlarmTypes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetYjzhZskAlarmTypes(soap, &a->ns1__GetYjzhZskAlarmTypes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetYjzhZskAlarmTypes(struct soap *soap, const char *tag, int id, const struct __ns1__GetYjzhZskAlarmTypes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetYjzhZskAlarmTypes(soap, "ns1:GetYjzhZskAlarmTypes", -1, &a->ns1__GetYjzhZskAlarmTypes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetYjzhZskAlarmTypes * SOAP_FMAC4 soap_in___ns1__GetYjzhZskAlarmTypes(struct soap *soap, const char *tag, struct __ns1__GetYjzhZskAlarmTypes *a, const char *type)
{
	size_t soap_flag_ns1__GetYjzhZskAlarmTypes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetYjzhZskAlarmTypes *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetYjzhZskAlarmTypes, sizeof(struct __ns1__GetYjzhZskAlarmTypes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetYjzhZskAlarmTypes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetYjzhZskAlarmTypes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetYjzhZskAlarmTypes(soap, "ns1:GetYjzhZskAlarmTypes", &a->ns1__GetYjzhZskAlarmTypes, ""))
				{	soap_flag_ns1__GetYjzhZskAlarmTypes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetYjzhZskAlarmTypes * SOAP_FMAC2 soap_instantiate___ns1__GetYjzhZskAlarmTypes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetYjzhZskAlarmTypes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetYjzhZskAlarmTypes *p;
	size_t k = sizeof(struct __ns1__GetYjzhZskAlarmTypes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetYjzhZskAlarmTypes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetYjzhZskAlarmTypes);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetYjzhZskAlarmTypes, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetYjzhZskAlarmTypes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetYjzhZskAlarmTypes(struct soap *soap, const struct __ns1__GetYjzhZskAlarmTypes *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetYjzhZskAlarmTypes(soap, tag ? tag : "-ns1:GetYjzhZskAlarmTypes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetYjzhZskAlarmTypes * SOAP_FMAC4 soap_get___ns1__GetYjzhZskAlarmTypes(struct soap *soap, struct __ns1__GetYjzhZskAlarmTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetYjzhZskAlarmTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SelectYjzhDevice(struct soap *soap, struct __ns1__SelectYjzhDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SelectYjzhDevice = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SelectYjzhDevice(struct soap *soap, const struct __ns1__SelectYjzhDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SelectYjzhDevice(soap, &a->ns1__SelectYjzhDevice);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SelectYjzhDevice(struct soap *soap, const char *tag, int id, const struct __ns1__SelectYjzhDevice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SelectYjzhDevice(soap, "ns1:SelectYjzhDevice", -1, &a->ns1__SelectYjzhDevice, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SelectYjzhDevice * SOAP_FMAC4 soap_in___ns1__SelectYjzhDevice(struct soap *soap, const char *tag, struct __ns1__SelectYjzhDevice *a, const char *type)
{
	size_t soap_flag_ns1__SelectYjzhDevice = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SelectYjzhDevice *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SelectYjzhDevice, sizeof(struct __ns1__SelectYjzhDevice), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SelectYjzhDevice(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SelectYjzhDevice && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SelectYjzhDevice(soap, "ns1:SelectYjzhDevice", &a->ns1__SelectYjzhDevice, ""))
				{	soap_flag_ns1__SelectYjzhDevice--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SelectYjzhDevice * SOAP_FMAC2 soap_instantiate___ns1__SelectYjzhDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SelectYjzhDevice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SelectYjzhDevice *p;
	size_t k = sizeof(struct __ns1__SelectYjzhDevice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__SelectYjzhDevice, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__SelectYjzhDevice);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__SelectYjzhDevice, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SelectYjzhDevice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SelectYjzhDevice(struct soap *soap, const struct __ns1__SelectYjzhDevice *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SelectYjzhDevice(soap, tag ? tag : "-ns1:SelectYjzhDevice", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SelectYjzhDevice * SOAP_FMAC4 soap_get___ns1__SelectYjzhDevice(struct soap *soap, struct __ns1__SelectYjzhDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SelectYjzhDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SelectYjzhStation(struct soap *soap, struct __ns1__SelectYjzhStation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SelectYjzhStation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SelectYjzhStation(struct soap *soap, const struct __ns1__SelectYjzhStation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SelectYjzhStation(soap, &a->ns1__SelectYjzhStation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SelectYjzhStation(struct soap *soap, const char *tag, int id, const struct __ns1__SelectYjzhStation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SelectYjzhStation(soap, "ns1:SelectYjzhStation", -1, &a->ns1__SelectYjzhStation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SelectYjzhStation * SOAP_FMAC4 soap_in___ns1__SelectYjzhStation(struct soap *soap, const char *tag, struct __ns1__SelectYjzhStation *a, const char *type)
{
	size_t soap_flag_ns1__SelectYjzhStation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SelectYjzhStation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SelectYjzhStation, sizeof(struct __ns1__SelectYjzhStation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SelectYjzhStation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SelectYjzhStation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SelectYjzhStation(soap, "ns1:SelectYjzhStation", &a->ns1__SelectYjzhStation, ""))
				{	soap_flag_ns1__SelectYjzhStation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SelectYjzhStation * SOAP_FMAC2 soap_instantiate___ns1__SelectYjzhStation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SelectYjzhStation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SelectYjzhStation *p;
	size_t k = sizeof(struct __ns1__SelectYjzhStation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__SelectYjzhStation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__SelectYjzhStation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__SelectYjzhStation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SelectYjzhStation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SelectYjzhStation(struct soap *soap, const struct __ns1__SelectYjzhStation *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SelectYjzhStation(soap, tag ? tag : "-ns1:SelectYjzhStation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SelectYjzhStation * SOAP_FMAC4 soap_get___ns1__SelectYjzhStation(struct soap *soap, struct __ns1__SelectYjzhStation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SelectYjzhStation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SaveMapFile(struct soap *soap, struct __ns1__SaveMapFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SaveMapFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SaveMapFile(struct soap *soap, const struct __ns1__SaveMapFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SaveMapFile(soap, &a->ns1__SaveMapFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SaveMapFile(struct soap *soap, const char *tag, int id, const struct __ns1__SaveMapFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SaveMapFile(soap, "ns1:SaveMapFile", -1, &a->ns1__SaveMapFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SaveMapFile * SOAP_FMAC4 soap_in___ns1__SaveMapFile(struct soap *soap, const char *tag, struct __ns1__SaveMapFile *a, const char *type)
{
	size_t soap_flag_ns1__SaveMapFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SaveMapFile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SaveMapFile, sizeof(struct __ns1__SaveMapFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SaveMapFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SaveMapFile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SaveMapFile(soap, "ns1:SaveMapFile", &a->ns1__SaveMapFile, ""))
				{	soap_flag_ns1__SaveMapFile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SaveMapFile * SOAP_FMAC2 soap_instantiate___ns1__SaveMapFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SaveMapFile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SaveMapFile *p;
	size_t k = sizeof(struct __ns1__SaveMapFile);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__SaveMapFile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__SaveMapFile);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__SaveMapFile, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SaveMapFile location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SaveMapFile(struct soap *soap, const struct __ns1__SaveMapFile *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SaveMapFile(soap, tag ? tag : "-ns1:SaveMapFile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SaveMapFile * SOAP_FMAC4 soap_get___ns1__SaveMapFile(struct soap *soap, struct __ns1__SaveMapFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SaveMapFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GzGetDeviceStruct(struct soap *soap, struct __ns1__GzGetDeviceStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GzGetDeviceStruct = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GzGetDeviceStruct(struct soap *soap, const struct __ns1__GzGetDeviceStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GzGetDeviceStruct(soap, &a->ns1__GzGetDeviceStruct);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GzGetDeviceStruct(struct soap *soap, const char *tag, int id, const struct __ns1__GzGetDeviceStruct *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GzGetDeviceStruct(soap, "ns1:GzGetDeviceStruct", -1, &a->ns1__GzGetDeviceStruct, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GzGetDeviceStruct * SOAP_FMAC4 soap_in___ns1__GzGetDeviceStruct(struct soap *soap, const char *tag, struct __ns1__GzGetDeviceStruct *a, const char *type)
{
	size_t soap_flag_ns1__GzGetDeviceStruct = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GzGetDeviceStruct *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GzGetDeviceStruct, sizeof(struct __ns1__GzGetDeviceStruct), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GzGetDeviceStruct(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GzGetDeviceStruct && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GzGetDeviceStruct(soap, "ns1:GzGetDeviceStruct", &a->ns1__GzGetDeviceStruct, ""))
				{	soap_flag_ns1__GzGetDeviceStruct--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GzGetDeviceStruct * SOAP_FMAC2 soap_instantiate___ns1__GzGetDeviceStruct(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GzGetDeviceStruct(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GzGetDeviceStruct *p;
	size_t k = sizeof(struct __ns1__GzGetDeviceStruct);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GzGetDeviceStruct, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GzGetDeviceStruct);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GzGetDeviceStruct, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GzGetDeviceStruct location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GzGetDeviceStruct(struct soap *soap, const struct __ns1__GzGetDeviceStruct *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GzGetDeviceStruct(soap, tag ? tag : "-ns1:GzGetDeviceStruct", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GzGetDeviceStruct * SOAP_FMAC4 soap_get___ns1__GzGetDeviceStruct(struct soap *soap, struct __ns1__GzGetDeviceStruct *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GzGetDeviceStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GzGetTypeList(struct soap *soap, struct __ns1__GzGetTypeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GzGetTypeList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GzGetTypeList(struct soap *soap, const struct __ns1__GzGetTypeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GzGetTypeList(soap, &a->ns1__GzGetTypeList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GzGetTypeList(struct soap *soap, const char *tag, int id, const struct __ns1__GzGetTypeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GzGetTypeList(soap, "ns1:GzGetTypeList", -1, &a->ns1__GzGetTypeList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GzGetTypeList * SOAP_FMAC4 soap_in___ns1__GzGetTypeList(struct soap *soap, const char *tag, struct __ns1__GzGetTypeList *a, const char *type)
{
	size_t soap_flag_ns1__GzGetTypeList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GzGetTypeList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GzGetTypeList, sizeof(struct __ns1__GzGetTypeList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GzGetTypeList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GzGetTypeList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GzGetTypeList(soap, "ns1:GzGetTypeList", &a->ns1__GzGetTypeList, ""))
				{	soap_flag_ns1__GzGetTypeList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GzGetTypeList * SOAP_FMAC2 soap_instantiate___ns1__GzGetTypeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GzGetTypeList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GzGetTypeList *p;
	size_t k = sizeof(struct __ns1__GzGetTypeList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GzGetTypeList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GzGetTypeList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GzGetTypeList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GzGetTypeList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GzGetTypeList(struct soap *soap, const struct __ns1__GzGetTypeList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GzGetTypeList(soap, tag ? tag : "-ns1:GzGetTypeList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GzGetTypeList * SOAP_FMAC4 soap_get___ns1__GzGetTypeList(struct soap *soap, struct __ns1__GzGetTypeList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GzGetTypeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SGCDrawEmf(struct soap *soap, struct __ns1__SGCDrawEmf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SGCDrawEmf = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SGCDrawEmf(struct soap *soap, const struct __ns1__SGCDrawEmf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SGCDrawEmf(soap, &a->ns1__SGCDrawEmf);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SGCDrawEmf(struct soap *soap, const char *tag, int id, const struct __ns1__SGCDrawEmf *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SGCDrawEmf(soap, "ns1:SGCDrawEmf", -1, &a->ns1__SGCDrawEmf, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SGCDrawEmf * SOAP_FMAC4 soap_in___ns1__SGCDrawEmf(struct soap *soap, const char *tag, struct __ns1__SGCDrawEmf *a, const char *type)
{
	size_t soap_flag_ns1__SGCDrawEmf = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SGCDrawEmf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SGCDrawEmf, sizeof(struct __ns1__SGCDrawEmf), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SGCDrawEmf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SGCDrawEmf && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SGCDrawEmf(soap, "ns1:SGCDrawEmf", &a->ns1__SGCDrawEmf, ""))
				{	soap_flag_ns1__SGCDrawEmf--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SGCDrawEmf * SOAP_FMAC2 soap_instantiate___ns1__SGCDrawEmf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SGCDrawEmf(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SGCDrawEmf *p;
	size_t k = sizeof(struct __ns1__SGCDrawEmf);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__SGCDrawEmf, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__SGCDrawEmf);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__SGCDrawEmf, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SGCDrawEmf location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SGCDrawEmf(struct soap *soap, const struct __ns1__SGCDrawEmf *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SGCDrawEmf(soap, tag ? tag : "-ns1:SGCDrawEmf", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SGCDrawEmf * SOAP_FMAC4 soap_get___ns1__SGCDrawEmf(struct soap *soap, struct __ns1__SGCDrawEmf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SGCDrawEmf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__FlowChartEmf(struct soap *soap, struct __ns1__FlowChartEmf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__FlowChartEmf = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__FlowChartEmf(struct soap *soap, const struct __ns1__FlowChartEmf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__FlowChartEmf(soap, &a->ns1__FlowChartEmf);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__FlowChartEmf(struct soap *soap, const char *tag, int id, const struct __ns1__FlowChartEmf *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__FlowChartEmf(soap, "ns1:FlowChartEmf", -1, &a->ns1__FlowChartEmf, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FlowChartEmf * SOAP_FMAC4 soap_in___ns1__FlowChartEmf(struct soap *soap, const char *tag, struct __ns1__FlowChartEmf *a, const char *type)
{
	size_t soap_flag_ns1__FlowChartEmf = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__FlowChartEmf *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__FlowChartEmf, sizeof(struct __ns1__FlowChartEmf), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__FlowChartEmf(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__FlowChartEmf && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__FlowChartEmf(soap, "ns1:FlowChartEmf", &a->ns1__FlowChartEmf, ""))
				{	soap_flag_ns1__FlowChartEmf--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__FlowChartEmf * SOAP_FMAC2 soap_instantiate___ns1__FlowChartEmf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__FlowChartEmf(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__FlowChartEmf *p;
	size_t k = sizeof(struct __ns1__FlowChartEmf);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__FlowChartEmf, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__FlowChartEmf);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__FlowChartEmf, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__FlowChartEmf location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__FlowChartEmf(struct soap *soap, const struct __ns1__FlowChartEmf *a, const char *tag, const char *type)
{
	if (soap_out___ns1__FlowChartEmf(soap, tag ? tag : "-ns1:FlowChartEmf", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FlowChartEmf * SOAP_FMAC4 soap_get___ns1__FlowChartEmf(struct soap *soap, struct __ns1__FlowChartEmf *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__FlowChartEmf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetZhouQi(struct soap *soap, struct __ns1__GetZhouQi *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetZhouQi = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetZhouQi(struct soap *soap, const struct __ns1__GetZhouQi *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetZhouQi(soap, &a->ns1__GetZhouQi);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetZhouQi(struct soap *soap, const char *tag, int id, const struct __ns1__GetZhouQi *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetZhouQi(soap, "ns1:GetZhouQi", -1, &a->ns1__GetZhouQi, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetZhouQi * SOAP_FMAC4 soap_in___ns1__GetZhouQi(struct soap *soap, const char *tag, struct __ns1__GetZhouQi *a, const char *type)
{
	size_t soap_flag_ns1__GetZhouQi = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetZhouQi *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetZhouQi, sizeof(struct __ns1__GetZhouQi), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetZhouQi(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetZhouQi && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetZhouQi(soap, "ns1:GetZhouQi", &a->ns1__GetZhouQi, ""))
				{	soap_flag_ns1__GetZhouQi--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetZhouQi * SOAP_FMAC2 soap_instantiate___ns1__GetZhouQi(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetZhouQi(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetZhouQi *p;
	size_t k = sizeof(struct __ns1__GetZhouQi);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetZhouQi, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetZhouQi);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetZhouQi, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetZhouQi location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetZhouQi(struct soap *soap, const struct __ns1__GetZhouQi *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetZhouQi(soap, tag ? tag : "-ns1:GetZhouQi", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetZhouQi * SOAP_FMAC4 soap_get___ns1__GetZhouQi(struct soap *soap, struct __ns1__GetZhouQi *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetZhouQi(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__JiChaoQi(struct soap *soap, struct __ns1__JiChaoQi *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__JiChaoQi = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__JiChaoQi(struct soap *soap, const struct __ns1__JiChaoQi *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__JiChaoQi(soap, &a->ns1__JiChaoQi);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__JiChaoQi(struct soap *soap, const char *tag, int id, const struct __ns1__JiChaoQi *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__JiChaoQi(soap, "ns1:JiChaoQi", -1, &a->ns1__JiChaoQi, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__JiChaoQi * SOAP_FMAC4 soap_in___ns1__JiChaoQi(struct soap *soap, const char *tag, struct __ns1__JiChaoQi *a, const char *type)
{
	size_t soap_flag_ns1__JiChaoQi = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__JiChaoQi *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__JiChaoQi, sizeof(struct __ns1__JiChaoQi), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__JiChaoQi(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__JiChaoQi && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__JiChaoQi(soap, "ns1:JiChaoQi", &a->ns1__JiChaoQi, ""))
				{	soap_flag_ns1__JiChaoQi--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__JiChaoQi * SOAP_FMAC2 soap_instantiate___ns1__JiChaoQi(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__JiChaoQi(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__JiChaoQi *p;
	size_t k = sizeof(struct __ns1__JiChaoQi);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__JiChaoQi, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__JiChaoQi);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__JiChaoQi, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__JiChaoQi location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__JiChaoQi(struct soap *soap, const struct __ns1__JiChaoQi *a, const char *tag, const char *type)
{
	if (soap_out___ns1__JiChaoQi(soap, tag ? tag : "-ns1:JiChaoQi", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__JiChaoQi * SOAP_FMAC4 soap_get___ns1__JiChaoQi(struct soap *soap, struct __ns1__JiChaoQi *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__JiChaoQi(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ChaoQi(struct soap *soap, struct __ns1__ChaoQi *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ChaoQi = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ChaoQi(struct soap *soap, const struct __ns1__ChaoQi *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ChaoQi(soap, &a->ns1__ChaoQi);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ChaoQi(struct soap *soap, const char *tag, int id, const struct __ns1__ChaoQi *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ChaoQi(soap, "ns1:ChaoQi", -1, &a->ns1__ChaoQi, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChaoQi * SOAP_FMAC4 soap_in___ns1__ChaoQi(struct soap *soap, const char *tag, struct __ns1__ChaoQi *a, const char *type)
{
	size_t soap_flag_ns1__ChaoQi = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ChaoQi *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ChaoQi, sizeof(struct __ns1__ChaoQi), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ChaoQi(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ChaoQi && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ChaoQi(soap, "ns1:ChaoQi", &a->ns1__ChaoQi, ""))
				{	soap_flag_ns1__ChaoQi--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ChaoQi * SOAP_FMAC2 soap_instantiate___ns1__ChaoQi(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ChaoQi(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ChaoQi *p;
	size_t k = sizeof(struct __ns1__ChaoQi);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ChaoQi, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ChaoQi);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ChaoQi, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ChaoQi location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ChaoQi(struct soap *soap, const struct __ns1__ChaoQi *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ChaoQi(soap, tag ? tag : "-ns1:ChaoQi", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ChaoQi * SOAP_FMAC4 soap_get___ns1__ChaoQi(struct soap *soap, struct __ns1__ChaoQi *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ChaoQi(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OpenMapExe(struct soap *soap, struct __ns1__OpenMapExe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OpenMapExe = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OpenMapExe(struct soap *soap, const struct __ns1__OpenMapExe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__OpenMapExe(soap, &a->ns1__OpenMapExe);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OpenMapExe(struct soap *soap, const char *tag, int id, const struct __ns1__OpenMapExe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__OpenMapExe(soap, "ns1:OpenMapExe", -1, &a->ns1__OpenMapExe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OpenMapExe * SOAP_FMAC4 soap_in___ns1__OpenMapExe(struct soap *soap, const char *tag, struct __ns1__OpenMapExe *a, const char *type)
{
	size_t soap_flag_ns1__OpenMapExe = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__OpenMapExe *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OpenMapExe, sizeof(struct __ns1__OpenMapExe), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OpenMapExe(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OpenMapExe && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__OpenMapExe(soap, "ns1:OpenMapExe", &a->ns1__OpenMapExe, ""))
				{	soap_flag_ns1__OpenMapExe--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__OpenMapExe * SOAP_FMAC2 soap_instantiate___ns1__OpenMapExe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__OpenMapExe(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__OpenMapExe *p;
	size_t k = sizeof(struct __ns1__OpenMapExe);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__OpenMapExe, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__OpenMapExe);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__OpenMapExe, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__OpenMapExe location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OpenMapExe(struct soap *soap, const struct __ns1__OpenMapExe *a, const char *tag, const char *type)
{
	if (soap_out___ns1__OpenMapExe(soap, tag ? tag : "-ns1:OpenMapExe", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OpenMapExe * SOAP_FMAC4 soap_get___ns1__OpenMapExe(struct soap *soap, struct __ns1__OpenMapExe *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OpenMapExe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetEmfPngFile(struct soap *soap, struct __ns1__GetEmfPngFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetEmfPngFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetEmfPngFile(struct soap *soap, const struct __ns1__GetEmfPngFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetEmfPngFile(soap, &a->ns1__GetEmfPngFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetEmfPngFile(struct soap *soap, const char *tag, int id, const struct __ns1__GetEmfPngFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetEmfPngFile(soap, "ns1:GetEmfPngFile", -1, &a->ns1__GetEmfPngFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetEmfPngFile * SOAP_FMAC4 soap_in___ns1__GetEmfPngFile(struct soap *soap, const char *tag, struct __ns1__GetEmfPngFile *a, const char *type)
{
	size_t soap_flag_ns1__GetEmfPngFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetEmfPngFile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetEmfPngFile, sizeof(struct __ns1__GetEmfPngFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetEmfPngFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetEmfPngFile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetEmfPngFile(soap, "ns1:GetEmfPngFile", &a->ns1__GetEmfPngFile, ""))
				{	soap_flag_ns1__GetEmfPngFile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetEmfPngFile * SOAP_FMAC2 soap_instantiate___ns1__GetEmfPngFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetEmfPngFile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetEmfPngFile *p;
	size_t k = sizeof(struct __ns1__GetEmfPngFile);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetEmfPngFile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetEmfPngFile);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetEmfPngFile, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetEmfPngFile location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetEmfPngFile(struct soap *soap, const struct __ns1__GetEmfPngFile *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetEmfPngFile(soap, tag ? tag : "-ns1:GetEmfPngFile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetEmfPngFile * SOAP_FMAC4 soap_get___ns1__GetEmfPngFile(struct soap *soap, struct __ns1__GetEmfPngFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetEmfPngFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetEmfPngVer(struct soap *soap, struct __ns1__GetEmfPngVer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetEmfPngVer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetEmfPngVer(struct soap *soap, const struct __ns1__GetEmfPngVer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetEmfPngVer(soap, &a->ns1__GetEmfPngVer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetEmfPngVer(struct soap *soap, const char *tag, int id, const struct __ns1__GetEmfPngVer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetEmfPngVer(soap, "ns1:GetEmfPngVer", -1, &a->ns1__GetEmfPngVer, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetEmfPngVer * SOAP_FMAC4 soap_in___ns1__GetEmfPngVer(struct soap *soap, const char *tag, struct __ns1__GetEmfPngVer *a, const char *type)
{
	size_t soap_flag_ns1__GetEmfPngVer = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetEmfPngVer *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetEmfPngVer, sizeof(struct __ns1__GetEmfPngVer), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetEmfPngVer(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetEmfPngVer && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetEmfPngVer(soap, "ns1:GetEmfPngVer", &a->ns1__GetEmfPngVer, ""))
				{	soap_flag_ns1__GetEmfPngVer--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetEmfPngVer * SOAP_FMAC2 soap_instantiate___ns1__GetEmfPngVer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetEmfPngVer(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetEmfPngVer *p;
	size_t k = sizeof(struct __ns1__GetEmfPngVer);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetEmfPngVer, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetEmfPngVer);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetEmfPngVer, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetEmfPngVer location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetEmfPngVer(struct soap *soap, const struct __ns1__GetEmfPngVer *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetEmfPngVer(soap, tag ? tag : "-ns1:GetEmfPngVer", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetEmfPngVer * SOAP_FMAC4 soap_get___ns1__GetEmfPngVer(struct soap *soap, struct __ns1__GetEmfPngVer *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetEmfPngVer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OpenProcess(struct soap *soap, struct __ns1__OpenProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OpenProcess = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OpenProcess(struct soap *soap, const struct __ns1__OpenProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__OpenProcess(soap, &a->ns1__OpenProcess);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OpenProcess(struct soap *soap, const char *tag, int id, const struct __ns1__OpenProcess *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__OpenProcess(soap, "ns1:OpenProcess", -1, &a->ns1__OpenProcess, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OpenProcess * SOAP_FMAC4 soap_in___ns1__OpenProcess(struct soap *soap, const char *tag, struct __ns1__OpenProcess *a, const char *type)
{
	size_t soap_flag_ns1__OpenProcess = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__OpenProcess *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OpenProcess, sizeof(struct __ns1__OpenProcess), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OpenProcess(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OpenProcess && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__OpenProcess(soap, "ns1:OpenProcess", &a->ns1__OpenProcess, ""))
				{	soap_flag_ns1__OpenProcess--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__OpenProcess * SOAP_FMAC2 soap_instantiate___ns1__OpenProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__OpenProcess(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__OpenProcess *p;
	size_t k = sizeof(struct __ns1__OpenProcess);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__OpenProcess, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__OpenProcess);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__OpenProcess, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__OpenProcess location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OpenProcess(struct soap *soap, const struct __ns1__OpenProcess *a, const char *tag, const char *type)
{
	if (soap_out___ns1__OpenProcess(soap, tag ? tag : "-ns1:OpenProcess", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OpenProcess * SOAP_FMAC4 soap_get___ns1__OpenProcess(struct soap *soap, struct __ns1__OpenProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OpenProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMangeMapUpdate(struct soap *soap, struct __ns1__GetMangeMapUpdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMangeMapUpdate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMangeMapUpdate(struct soap *soap, const struct __ns1__GetMangeMapUpdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMangeMapUpdate(soap, &a->ns1__GetMangeMapUpdate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMangeMapUpdate(struct soap *soap, const char *tag, int id, const struct __ns1__GetMangeMapUpdate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMangeMapUpdate(soap, "ns1:GetMangeMapUpdate", -1, &a->ns1__GetMangeMapUpdate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMangeMapUpdate * SOAP_FMAC4 soap_in___ns1__GetMangeMapUpdate(struct soap *soap, const char *tag, struct __ns1__GetMangeMapUpdate *a, const char *type)
{
	size_t soap_flag_ns1__GetMangeMapUpdate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMangeMapUpdate *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMangeMapUpdate, sizeof(struct __ns1__GetMangeMapUpdate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMangeMapUpdate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMangeMapUpdate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMangeMapUpdate(soap, "ns1:GetMangeMapUpdate", &a->ns1__GetMangeMapUpdate, ""))
				{	soap_flag_ns1__GetMangeMapUpdate--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMangeMapUpdate * SOAP_FMAC2 soap_instantiate___ns1__GetMangeMapUpdate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMangeMapUpdate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMangeMapUpdate *p;
	size_t k = sizeof(struct __ns1__GetMangeMapUpdate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetMangeMapUpdate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetMangeMapUpdate);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetMangeMapUpdate, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMangeMapUpdate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMangeMapUpdate(struct soap *soap, const struct __ns1__GetMangeMapUpdate *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMangeMapUpdate(soap, tag ? tag : "-ns1:GetMangeMapUpdate", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMangeMapUpdate * SOAP_FMAC4 soap_get___ns1__GetMangeMapUpdate(struct soap *soap, struct __ns1__GetMangeMapUpdate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMangeMapUpdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetUnitMapVer(struct soap *soap, struct __ns1__GetUnitMapVer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetUnitMapVer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetUnitMapVer(struct soap *soap, const struct __ns1__GetUnitMapVer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetUnitMapVer(soap, &a->ns1__GetUnitMapVer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetUnitMapVer(struct soap *soap, const char *tag, int id, const struct __ns1__GetUnitMapVer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetUnitMapVer(soap, "ns1:GetUnitMapVer", -1, &a->ns1__GetUnitMapVer, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUnitMapVer * SOAP_FMAC4 soap_in___ns1__GetUnitMapVer(struct soap *soap, const char *tag, struct __ns1__GetUnitMapVer *a, const char *type)
{
	size_t soap_flag_ns1__GetUnitMapVer = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetUnitMapVer *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetUnitMapVer, sizeof(struct __ns1__GetUnitMapVer), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetUnitMapVer(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetUnitMapVer && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetUnitMapVer(soap, "ns1:GetUnitMapVer", &a->ns1__GetUnitMapVer, ""))
				{	soap_flag_ns1__GetUnitMapVer--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetUnitMapVer * SOAP_FMAC2 soap_instantiate___ns1__GetUnitMapVer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetUnitMapVer(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetUnitMapVer *p;
	size_t k = sizeof(struct __ns1__GetUnitMapVer);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetUnitMapVer, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetUnitMapVer);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetUnitMapVer, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetUnitMapVer location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetUnitMapVer(struct soap *soap, const struct __ns1__GetUnitMapVer *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetUnitMapVer(soap, tag ? tag : "-ns1:GetUnitMapVer", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUnitMapVer * SOAP_FMAC4 soap_get___ns1__GetUnitMapVer(struct soap *soap, struct __ns1__GetUnitMapVer *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetUnitMapVer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdateGzclMap(struct soap *soap, struct __ns1__UpdateGzclMap *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateGzclMap = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdateGzclMap(struct soap *soap, const struct __ns1__UpdateGzclMap *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UpdateGzclMap(soap, &a->ns1__UpdateGzclMap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdateGzclMap(struct soap *soap, const char *tag, int id, const struct __ns1__UpdateGzclMap *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UpdateGzclMap(soap, "ns1:UpdateGzclMap", -1, &a->ns1__UpdateGzclMap, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateGzclMap * SOAP_FMAC4 soap_in___ns1__UpdateGzclMap(struct soap *soap, const char *tag, struct __ns1__UpdateGzclMap *a, const char *type)
{
	size_t soap_flag_ns1__UpdateGzclMap = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UpdateGzclMap *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpdateGzclMap, sizeof(struct __ns1__UpdateGzclMap), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdateGzclMap(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateGzclMap && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__UpdateGzclMap(soap, "ns1:UpdateGzclMap", &a->ns1__UpdateGzclMap, ""))
				{	soap_flag_ns1__UpdateGzclMap--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__UpdateGzclMap * SOAP_FMAC2 soap_instantiate___ns1__UpdateGzclMap(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdateGzclMap(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UpdateGzclMap *p;
	size_t k = sizeof(struct __ns1__UpdateGzclMap);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__UpdateGzclMap, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__UpdateGzclMap);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__UpdateGzclMap, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UpdateGzclMap location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdateGzclMap(struct soap *soap, const struct __ns1__UpdateGzclMap *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UpdateGzclMap(soap, tag ? tag : "-ns1:UpdateGzclMap", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateGzclMap * SOAP_FMAC4 soap_get___ns1__UpdateGzclMap(struct soap *soap, struct __ns1__UpdateGzclMap *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdateGzclMap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMapListTime(struct soap *soap, struct __ns1__GetMapListTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMapListTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMapListTime(struct soap *soap, const struct __ns1__GetMapListTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMapListTime(soap, &a->ns1__GetMapListTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMapListTime(struct soap *soap, const char *tag, int id, const struct __ns1__GetMapListTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMapListTime(soap, "ns1:GetMapListTime", -1, &a->ns1__GetMapListTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMapListTime * SOAP_FMAC4 soap_in___ns1__GetMapListTime(struct soap *soap, const char *tag, struct __ns1__GetMapListTime *a, const char *type)
{
	size_t soap_flag_ns1__GetMapListTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMapListTime *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMapListTime, sizeof(struct __ns1__GetMapListTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMapListTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMapListTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMapListTime(soap, "ns1:GetMapListTime", &a->ns1__GetMapListTime, ""))
				{	soap_flag_ns1__GetMapListTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMapListTime * SOAP_FMAC2 soap_instantiate___ns1__GetMapListTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMapListTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMapListTime *p;
	size_t k = sizeof(struct __ns1__GetMapListTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetMapListTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetMapListTime);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetMapListTime, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMapListTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMapListTime(struct soap *soap, const struct __ns1__GetMapListTime *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMapListTime(soap, tag ? tag : "-ns1:GetMapListTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMapListTime * SOAP_FMAC4 soap_get___ns1__GetMapListTime(struct soap *soap, struct __ns1__GetMapListTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMapListTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ServerLevel(struct soap *soap, struct __ns1__ServerLevel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ServerLevel = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ServerLevel(struct soap *soap, const struct __ns1__ServerLevel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ServerLevel(soap, &a->ns1__ServerLevel);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ServerLevel(struct soap *soap, const char *tag, int id, const struct __ns1__ServerLevel *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ServerLevel(soap, "ns1:ServerLevel", -1, &a->ns1__ServerLevel, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ServerLevel * SOAP_FMAC4 soap_in___ns1__ServerLevel(struct soap *soap, const char *tag, struct __ns1__ServerLevel *a, const char *type)
{
	size_t soap_flag_ns1__ServerLevel = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ServerLevel *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ServerLevel, sizeof(struct __ns1__ServerLevel), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ServerLevel(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ServerLevel && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ServerLevel(soap, "ns1:ServerLevel", &a->ns1__ServerLevel, ""))
				{	soap_flag_ns1__ServerLevel--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ServerLevel * SOAP_FMAC2 soap_instantiate___ns1__ServerLevel(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ServerLevel(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ServerLevel *p;
	size_t k = sizeof(struct __ns1__ServerLevel);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ServerLevel, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ServerLevel);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ServerLevel, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ServerLevel location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ServerLevel(struct soap *soap, const struct __ns1__ServerLevel *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ServerLevel(soap, tag ? tag : "-ns1:ServerLevel", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ServerLevel * SOAP_FMAC4 soap_get___ns1__ServerLevel(struct soap *soap, struct __ns1__ServerLevel *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ServerLevel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetTableData(struct soap *soap, struct __ns1__GetTableData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetTableData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetTableData(struct soap *soap, const struct __ns1__GetTableData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetTableData(soap, &a->ns1__GetTableData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetTableData(struct soap *soap, const char *tag, int id, const struct __ns1__GetTableData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetTableData(soap, "ns1:GetTableData", -1, &a->ns1__GetTableData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTableData * SOAP_FMAC4 soap_in___ns1__GetTableData(struct soap *soap, const char *tag, struct __ns1__GetTableData *a, const char *type)
{
	size_t soap_flag_ns1__GetTableData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetTableData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetTableData, sizeof(struct __ns1__GetTableData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetTableData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetTableData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetTableData(soap, "ns1:GetTableData", &a->ns1__GetTableData, ""))
				{	soap_flag_ns1__GetTableData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetTableData * SOAP_FMAC2 soap_instantiate___ns1__GetTableData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetTableData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetTableData *p;
	size_t k = sizeof(struct __ns1__GetTableData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetTableData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetTableData);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetTableData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetTableData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetTableData(struct soap *soap, const struct __ns1__GetTableData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetTableData(soap, tag ? tag : "-ns1:GetTableData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTableData * SOAP_FMAC4 soap_get___ns1__GetTableData(struct soap *soap, struct __ns1__GetTableData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetTableData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMap(struct soap *soap, struct __ns1__GetMap *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMap = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMap(struct soap *soap, const struct __ns1__GetMap *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMap(soap, &a->ns1__GetMap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMap(struct soap *soap, const char *tag, int id, const struct __ns1__GetMap *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMap(soap, "ns1:GetMap", -1, &a->ns1__GetMap, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMap * SOAP_FMAC4 soap_in___ns1__GetMap(struct soap *soap, const char *tag, struct __ns1__GetMap *a, const char *type)
{
	size_t soap_flag_ns1__GetMap = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMap *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMap, sizeof(struct __ns1__GetMap), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMap(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMap && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMap(soap, "ns1:GetMap", &a->ns1__GetMap, ""))
				{	soap_flag_ns1__GetMap--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMap * SOAP_FMAC2 soap_instantiate___ns1__GetMap(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMap(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMap *p;
	size_t k = sizeof(struct __ns1__GetMap);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetMap, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetMap);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetMap, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMap location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMap(struct soap *soap, const struct __ns1__GetMap *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMap(soap, tag ? tag : "-ns1:GetMap", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMap * SOAP_FMAC4 soap_get___ns1__GetMap(struct soap *soap, struct __ns1__GetMap *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CheckMapVer(struct soap *soap, struct __ns1__CheckMapVer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CheckMapVer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CheckMapVer(struct soap *soap, const struct __ns1__CheckMapVer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CheckMapVer(soap, &a->ns1__CheckMapVer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CheckMapVer(struct soap *soap, const char *tag, int id, const struct __ns1__CheckMapVer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CheckMapVer(soap, "ns1:CheckMapVer", -1, &a->ns1__CheckMapVer, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckMapVer * SOAP_FMAC4 soap_in___ns1__CheckMapVer(struct soap *soap, const char *tag, struct __ns1__CheckMapVer *a, const char *type)
{
	size_t soap_flag_ns1__CheckMapVer = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CheckMapVer *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CheckMapVer, sizeof(struct __ns1__CheckMapVer), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CheckMapVer(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CheckMapVer && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CheckMapVer(soap, "ns1:CheckMapVer", &a->ns1__CheckMapVer, ""))
				{	soap_flag_ns1__CheckMapVer--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CheckMapVer * SOAP_FMAC2 soap_instantiate___ns1__CheckMapVer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CheckMapVer(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CheckMapVer *p;
	size_t k = sizeof(struct __ns1__CheckMapVer);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__CheckMapVer, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__CheckMapVer);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__CheckMapVer, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CheckMapVer location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CheckMapVer(struct soap *soap, const struct __ns1__CheckMapVer *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CheckMapVer(soap, tag ? tag : "-ns1:CheckMapVer", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckMapVer * SOAP_FMAC4 soap_get___ns1__CheckMapVer(struct soap *soap, struct __ns1__CheckMapVer *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CheckMapVer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMangeXb(struct soap *soap, struct __ns1__GetMangeXb *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMangeXb = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMangeXb(struct soap *soap, const struct __ns1__GetMangeXb *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMangeXb(soap, &a->ns1__GetMangeXb);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMangeXb(struct soap *soap, const char *tag, int id, const struct __ns1__GetMangeXb *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMangeXb(soap, "ns1:GetMangeXb", -1, &a->ns1__GetMangeXb, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMangeXb * SOAP_FMAC4 soap_in___ns1__GetMangeXb(struct soap *soap, const char *tag, struct __ns1__GetMangeXb *a, const char *type)
{
	size_t soap_flag_ns1__GetMangeXb = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMangeXb *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMangeXb, sizeof(struct __ns1__GetMangeXb), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMangeXb(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMangeXb && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMangeXb(soap, "ns1:GetMangeXb", &a->ns1__GetMangeXb, ""))
				{	soap_flag_ns1__GetMangeXb--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMangeXb * SOAP_FMAC2 soap_instantiate___ns1__GetMangeXb(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMangeXb(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMangeXb *p;
	size_t k = sizeof(struct __ns1__GetMangeXb);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetMangeXb, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetMangeXb);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetMangeXb, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMangeXb location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMangeXb(struct soap *soap, const struct __ns1__GetMangeXb *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMangeXb(soap, tag ? tag : "-ns1:GetMangeXb", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMangeXb * SOAP_FMAC4 soap_get___ns1__GetMangeXb(struct soap *soap, struct __ns1__GetMangeXb *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMangeXb(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMangeUnit(struct soap *soap, struct __ns1__GetMangeUnit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMangeUnit = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMangeUnit(struct soap *soap, const struct __ns1__GetMangeUnit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMangeUnit(soap, &a->ns1__GetMangeUnit);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMangeUnit(struct soap *soap, const char *tag, int id, const struct __ns1__GetMangeUnit *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMangeUnit(soap, "ns1:GetMangeUnit", -1, &a->ns1__GetMangeUnit, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMangeUnit * SOAP_FMAC4 soap_in___ns1__GetMangeUnit(struct soap *soap, const char *tag, struct __ns1__GetMangeUnit *a, const char *type)
{
	size_t soap_flag_ns1__GetMangeUnit = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMangeUnit *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMangeUnit, sizeof(struct __ns1__GetMangeUnit), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMangeUnit(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMangeUnit && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMangeUnit(soap, "ns1:GetMangeUnit", &a->ns1__GetMangeUnit, ""))
				{	soap_flag_ns1__GetMangeUnit--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMangeUnit * SOAP_FMAC2 soap_instantiate___ns1__GetMangeUnit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMangeUnit(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMangeUnit *p;
	size_t k = sizeof(struct __ns1__GetMangeUnit);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetMangeUnit, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetMangeUnit);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetMangeUnit, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMangeUnit location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMangeUnit(struct soap *soap, const struct __ns1__GetMangeUnit *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMangeUnit(soap, tag ? tag : "-ns1:GetMangeUnit", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMangeUnit * SOAP_FMAC4 soap_get___ns1__GetMangeUnit(struct soap *soap, struct __ns1__GetMangeUnit *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMangeUnit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMaList(struct soap *soap, struct __ns1__GetMaList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMaList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMaList(struct soap *soap, const struct __ns1__GetMaList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMaList(soap, &a->ns1__GetMaList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMaList(struct soap *soap, const char *tag, int id, const struct __ns1__GetMaList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMaList(soap, "ns1:GetMaList", -1, &a->ns1__GetMaList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMaList * SOAP_FMAC4 soap_in___ns1__GetMaList(struct soap *soap, const char *tag, struct __ns1__GetMaList *a, const char *type)
{
	size_t soap_flag_ns1__GetMaList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMaList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMaList, sizeof(struct __ns1__GetMaList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMaList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMaList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMaList(soap, "ns1:GetMaList", &a->ns1__GetMaList, ""))
				{	soap_flag_ns1__GetMaList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMaList * SOAP_FMAC2 soap_instantiate___ns1__GetMaList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMaList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMaList *p;
	size_t k = sizeof(struct __ns1__GetMaList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetMaList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetMaList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetMaList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMaList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMaList(struct soap *soap, const struct __ns1__GetMaList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMaList(soap, tag ? tag : "-ns1:GetMaList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMaList * SOAP_FMAC4 soap_get___ns1__GetMaList(struct soap *soap, struct __ns1__GetMaList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMaList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMapDeviceData(struct soap *soap, struct __ns1__GetMapDeviceData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMapDeviceData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMapDeviceData(struct soap *soap, const struct __ns1__GetMapDeviceData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMapDeviceData(soap, &a->ns1__GetMapDeviceData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMapDeviceData(struct soap *soap, const char *tag, int id, const struct __ns1__GetMapDeviceData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMapDeviceData(soap, "ns1:GetMapDeviceData", -1, &a->ns1__GetMapDeviceData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMapDeviceData * SOAP_FMAC4 soap_in___ns1__GetMapDeviceData(struct soap *soap, const char *tag, struct __ns1__GetMapDeviceData *a, const char *type)
{
	size_t soap_flag_ns1__GetMapDeviceData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMapDeviceData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMapDeviceData, sizeof(struct __ns1__GetMapDeviceData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMapDeviceData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMapDeviceData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMapDeviceData(soap, "ns1:GetMapDeviceData", &a->ns1__GetMapDeviceData, ""))
				{	soap_flag_ns1__GetMapDeviceData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMapDeviceData * SOAP_FMAC2 soap_instantiate___ns1__GetMapDeviceData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMapDeviceData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMapDeviceData *p;
	size_t k = sizeof(struct __ns1__GetMapDeviceData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetMapDeviceData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetMapDeviceData);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetMapDeviceData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMapDeviceData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMapDeviceData(struct soap *soap, const struct __ns1__GetMapDeviceData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMapDeviceData(soap, tag ? tag : "-ns1:GetMapDeviceData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMapDeviceData * SOAP_FMAC4 soap_get___ns1__GetMapDeviceData(struct soap *soap, struct __ns1__GetMapDeviceData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMapDeviceData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMapTabName(struct soap *soap, struct __ns1__GetMapTabName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMapTabName = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMapTabName(struct soap *soap, const struct __ns1__GetMapTabName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMapTabName(soap, &a->ns1__GetMapTabName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMapTabName(struct soap *soap, const char *tag, int id, const struct __ns1__GetMapTabName *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMapTabName(soap, "ns1:GetMapTabName", -1, &a->ns1__GetMapTabName, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMapTabName * SOAP_FMAC4 soap_in___ns1__GetMapTabName(struct soap *soap, const char *tag, struct __ns1__GetMapTabName *a, const char *type)
{
	size_t soap_flag_ns1__GetMapTabName = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMapTabName *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMapTabName, sizeof(struct __ns1__GetMapTabName), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMapTabName(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMapTabName && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMapTabName(soap, "ns1:GetMapTabName", &a->ns1__GetMapTabName, ""))
				{	soap_flag_ns1__GetMapTabName--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMapTabName * SOAP_FMAC2 soap_instantiate___ns1__GetMapTabName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMapTabName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMapTabName *p;
	size_t k = sizeof(struct __ns1__GetMapTabName);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetMapTabName, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetMapTabName);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetMapTabName, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMapTabName location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMapTabName(struct soap *soap, const struct __ns1__GetMapTabName *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMapTabName(soap, tag ? tag : "-ns1:GetMapTabName", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMapTabName * SOAP_FMAC4 soap_get___ns1__GetMapTabName(struct soap *soap, struct __ns1__GetMapTabName *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMapTabName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMapUpdateTime(struct soap *soap, struct __ns1__GetMapUpdateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMapUpdateTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMapUpdateTime(struct soap *soap, const struct __ns1__GetMapUpdateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMapUpdateTime(soap, &a->ns1__GetMapUpdateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMapUpdateTime(struct soap *soap, const char *tag, int id, const struct __ns1__GetMapUpdateTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMapUpdateTime(soap, "ns1:GetMapUpdateTime", -1, &a->ns1__GetMapUpdateTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMapUpdateTime * SOAP_FMAC4 soap_in___ns1__GetMapUpdateTime(struct soap *soap, const char *tag, struct __ns1__GetMapUpdateTime *a, const char *type)
{
	size_t soap_flag_ns1__GetMapUpdateTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMapUpdateTime *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMapUpdateTime, sizeof(struct __ns1__GetMapUpdateTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMapUpdateTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMapUpdateTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMapUpdateTime(soap, "ns1:GetMapUpdateTime", &a->ns1__GetMapUpdateTime, ""))
				{	soap_flag_ns1__GetMapUpdateTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMapUpdateTime * SOAP_FMAC2 soap_instantiate___ns1__GetMapUpdateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMapUpdateTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMapUpdateTime *p;
	size_t k = sizeof(struct __ns1__GetMapUpdateTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetMapUpdateTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetMapUpdateTime);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetMapUpdateTime, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMapUpdateTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMapUpdateTime(struct soap *soap, const struct __ns1__GetMapUpdateTime *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMapUpdateTime(soap, tag ? tag : "-ns1:GetMapUpdateTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMapUpdateTime * SOAP_FMAC4 soap_get___ns1__GetMapUpdateTime(struct soap *soap, struct __ns1__GetMapUpdateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMapUpdateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__WriteFile(struct soap *soap, struct __ns1__WriteFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__WriteFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__WriteFile(struct soap *soap, const struct __ns1__WriteFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__WriteFile(soap, &a->ns1__WriteFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__WriteFile(struct soap *soap, const char *tag, int id, const struct __ns1__WriteFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__WriteFile(soap, "ns1:WriteFile", -1, &a->ns1__WriteFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__WriteFile * SOAP_FMAC4 soap_in___ns1__WriteFile(struct soap *soap, const char *tag, struct __ns1__WriteFile *a, const char *type)
{
	size_t soap_flag_ns1__WriteFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__WriteFile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__WriteFile, sizeof(struct __ns1__WriteFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__WriteFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__WriteFile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__WriteFile(soap, "ns1:WriteFile", &a->ns1__WriteFile, ""))
				{	soap_flag_ns1__WriteFile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__WriteFile * SOAP_FMAC2 soap_instantiate___ns1__WriteFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__WriteFile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__WriteFile *p;
	size_t k = sizeof(struct __ns1__WriteFile);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__WriteFile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__WriteFile);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__WriteFile, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__WriteFile location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__WriteFile(struct soap *soap, const struct __ns1__WriteFile *a, const char *tag, const char *type)
{
	if (soap_out___ns1__WriteFile(soap, tag ? tag : "-ns1:WriteFile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__WriteFile * SOAP_FMAC4 soap_get___ns1__WriteFile(struct soap *soap, struct __ns1__WriteFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__WriteFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DownLoadFile(struct soap *soap, struct __ns1__DownLoadFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DownLoadFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DownLoadFile(struct soap *soap, const struct __ns1__DownLoadFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DownLoadFile(soap, &a->ns1__DownLoadFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DownLoadFile(struct soap *soap, const char *tag, int id, const struct __ns1__DownLoadFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DownLoadFile(soap, "ns1:DownLoadFile", -1, &a->ns1__DownLoadFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownLoadFile * SOAP_FMAC4 soap_in___ns1__DownLoadFile(struct soap *soap, const char *tag, struct __ns1__DownLoadFile *a, const char *type)
{
	size_t soap_flag_ns1__DownLoadFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DownLoadFile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DownLoadFile, sizeof(struct __ns1__DownLoadFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DownLoadFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DownLoadFile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__DownLoadFile(soap, "ns1:DownLoadFile", &a->ns1__DownLoadFile, ""))
				{	soap_flag_ns1__DownLoadFile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DownLoadFile * SOAP_FMAC2 soap_instantiate___ns1__DownLoadFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DownLoadFile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DownLoadFile *p;
	size_t k = sizeof(struct __ns1__DownLoadFile);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__DownLoadFile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__DownLoadFile);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__DownLoadFile, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DownLoadFile location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DownLoadFile(struct soap *soap, const struct __ns1__DownLoadFile *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DownLoadFile(soap, tag ? tag : "-ns1:DownLoadFile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownLoadFile * SOAP_FMAC4 soap_get___ns1__DownLoadFile(struct soap *soap, struct __ns1__DownLoadFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DownLoadFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ExecuteSqlForFile(struct soap *soap, struct __ns1__ExecuteSqlForFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ExecuteSqlForFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ExecuteSqlForFile(struct soap *soap, const struct __ns1__ExecuteSqlForFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ExecuteSqlForFile(soap, &a->ns1__ExecuteSqlForFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ExecuteSqlForFile(struct soap *soap, const char *tag, int id, const struct __ns1__ExecuteSqlForFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ExecuteSqlForFile(soap, "ns1:ExecuteSqlForFile", -1, &a->ns1__ExecuteSqlForFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExecuteSqlForFile * SOAP_FMAC4 soap_in___ns1__ExecuteSqlForFile(struct soap *soap, const char *tag, struct __ns1__ExecuteSqlForFile *a, const char *type)
{
	size_t soap_flag_ns1__ExecuteSqlForFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ExecuteSqlForFile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ExecuteSqlForFile, sizeof(struct __ns1__ExecuteSqlForFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ExecuteSqlForFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ExecuteSqlForFile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ExecuteSqlForFile(soap, "ns1:ExecuteSqlForFile", &a->ns1__ExecuteSqlForFile, ""))
				{	soap_flag_ns1__ExecuteSqlForFile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ExecuteSqlForFile * SOAP_FMAC2 soap_instantiate___ns1__ExecuteSqlForFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ExecuteSqlForFile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ExecuteSqlForFile *p;
	size_t k = sizeof(struct __ns1__ExecuteSqlForFile);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ExecuteSqlForFile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ExecuteSqlForFile);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ExecuteSqlForFile, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ExecuteSqlForFile location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ExecuteSqlForFile(struct soap *soap, const struct __ns1__ExecuteSqlForFile *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ExecuteSqlForFile(soap, tag ? tag : "-ns1:ExecuteSqlForFile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExecuteSqlForFile * SOAP_FMAC4 soap_get___ns1__ExecuteSqlForFile(struct soap *soap, struct __ns1__ExecuteSqlForFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ExecuteSqlForFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetFieldInfo(struct soap *soap, struct __ns1__GetFieldInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetFieldInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetFieldInfo(struct soap *soap, const struct __ns1__GetFieldInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetFieldInfo(soap, &a->ns1__GetFieldInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetFieldInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetFieldInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetFieldInfo(soap, "ns1:GetFieldInfo", -1, &a->ns1__GetFieldInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFieldInfo * SOAP_FMAC4 soap_in___ns1__GetFieldInfo(struct soap *soap, const char *tag, struct __ns1__GetFieldInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetFieldInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetFieldInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetFieldInfo, sizeof(struct __ns1__GetFieldInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetFieldInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetFieldInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetFieldInfo(soap, "ns1:GetFieldInfo", &a->ns1__GetFieldInfo, ""))
				{	soap_flag_ns1__GetFieldInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetFieldInfo * SOAP_FMAC2 soap_instantiate___ns1__GetFieldInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetFieldInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetFieldInfo *p;
	size_t k = sizeof(struct __ns1__GetFieldInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetFieldInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetFieldInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetFieldInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetFieldInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetFieldInfo(struct soap *soap, const struct __ns1__GetFieldInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetFieldInfo(soap, tag ? tag : "-ns1:GetFieldInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFieldInfo * SOAP_FMAC4 soap_get___ns1__GetFieldInfo(struct soap *soap, struct __ns1__GetFieldInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetFieldInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__IsOracleTable(struct soap *soap, struct __ns1__IsOracleTable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__IsOracleTable = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__IsOracleTable(struct soap *soap, const struct __ns1__IsOracleTable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__IsOracleTable(soap, &a->ns1__IsOracleTable);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__IsOracleTable(struct soap *soap, const char *tag, int id, const struct __ns1__IsOracleTable *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__IsOracleTable(soap, "ns1:IsOracleTable", -1, &a->ns1__IsOracleTable, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__IsOracleTable * SOAP_FMAC4 soap_in___ns1__IsOracleTable(struct soap *soap, const char *tag, struct __ns1__IsOracleTable *a, const char *type)
{
	size_t soap_flag_ns1__IsOracleTable = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__IsOracleTable *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__IsOracleTable, sizeof(struct __ns1__IsOracleTable), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__IsOracleTable(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__IsOracleTable && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__IsOracleTable(soap, "ns1:IsOracleTable", &a->ns1__IsOracleTable, ""))
				{	soap_flag_ns1__IsOracleTable--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__IsOracleTable * SOAP_FMAC2 soap_instantiate___ns1__IsOracleTable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__IsOracleTable(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__IsOracleTable *p;
	size_t k = sizeof(struct __ns1__IsOracleTable);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__IsOracleTable, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__IsOracleTable);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__IsOracleTable, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__IsOracleTable location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__IsOracleTable(struct soap *soap, const struct __ns1__IsOracleTable *a, const char *tag, const char *type)
{
	if (soap_out___ns1__IsOracleTable(soap, tag ? tag : "-ns1:IsOracleTable", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__IsOracleTable * SOAP_FMAC4 soap_get___ns1__IsOracleTable(struct soap *soap, struct __ns1__IsOracleTable *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__IsOracleTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetTabList(struct soap *soap, struct __ns1__GetTabList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetTabList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetTabList(struct soap *soap, const struct __ns1__GetTabList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetTabList(soap, &a->ns1__GetTabList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetTabList(struct soap *soap, const char *tag, int id, const struct __ns1__GetTabList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetTabList(soap, "ns1:GetTabList", -1, &a->ns1__GetTabList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTabList * SOAP_FMAC4 soap_in___ns1__GetTabList(struct soap *soap, const char *tag, struct __ns1__GetTabList *a, const char *type)
{
	size_t soap_flag_ns1__GetTabList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetTabList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetTabList, sizeof(struct __ns1__GetTabList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetTabList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetTabList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetTabList(soap, "ns1:GetTabList", &a->ns1__GetTabList, ""))
				{	soap_flag_ns1__GetTabList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetTabList * SOAP_FMAC2 soap_instantiate___ns1__GetTabList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetTabList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetTabList *p;
	size_t k = sizeof(struct __ns1__GetTabList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetTabList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetTabList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetTabList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetTabList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetTabList(struct soap *soap, const struct __ns1__GetTabList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetTabList(soap, tag ? tag : "-ns1:GetTabList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTabList * SOAP_FMAC4 soap_get___ns1__GetTabList(struct soap *soap, struct __ns1__GetTabList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetTabList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DownCQData(struct soap *soap, struct __ns1__DownCQData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DownCQData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DownCQData(struct soap *soap, const struct __ns1__DownCQData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DownCQData(soap, &a->ns1__DownCQData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DownCQData(struct soap *soap, const char *tag, int id, const struct __ns1__DownCQData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DownCQData(soap, "ns1:DownCQData", -1, &a->ns1__DownCQData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownCQData * SOAP_FMAC4 soap_in___ns1__DownCQData(struct soap *soap, const char *tag, struct __ns1__DownCQData *a, const char *type)
{
	size_t soap_flag_ns1__DownCQData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DownCQData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DownCQData, sizeof(struct __ns1__DownCQData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DownCQData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DownCQData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__DownCQData(soap, "ns1:DownCQData", &a->ns1__DownCQData, ""))
				{	soap_flag_ns1__DownCQData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DownCQData * SOAP_FMAC2 soap_instantiate___ns1__DownCQData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DownCQData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DownCQData *p;
	size_t k = sizeof(struct __ns1__DownCQData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__DownCQData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__DownCQData);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__DownCQData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DownCQData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DownCQData(struct soap *soap, const struct __ns1__DownCQData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DownCQData(soap, tag ? tag : "-ns1:DownCQData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownCQData * SOAP_FMAC4 soap_get___ns1__DownCQData(struct soap *soap, struct __ns1__DownCQData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DownCQData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__AlterTable(struct soap *soap, struct __ns1__AlterTable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AlterTable = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__AlterTable(struct soap *soap, const struct __ns1__AlterTable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__AlterTable(soap, &a->ns1__AlterTable);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__AlterTable(struct soap *soap, const char *tag, int id, const struct __ns1__AlterTable *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__AlterTable(soap, "ns1:AlterTable", -1, &a->ns1__AlterTable, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AlterTable * SOAP_FMAC4 soap_in___ns1__AlterTable(struct soap *soap, const char *tag, struct __ns1__AlterTable *a, const char *type)
{
	size_t soap_flag_ns1__AlterTable = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__AlterTable *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__AlterTable, sizeof(struct __ns1__AlterTable), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__AlterTable(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AlterTable && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__AlterTable(soap, "ns1:AlterTable", &a->ns1__AlterTable, ""))
				{	soap_flag_ns1__AlterTable--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__AlterTable * SOAP_FMAC2 soap_instantiate___ns1__AlterTable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__AlterTable(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__AlterTable *p;
	size_t k = sizeof(struct __ns1__AlterTable);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__AlterTable, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__AlterTable);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__AlterTable, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__AlterTable location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__AlterTable(struct soap *soap, const struct __ns1__AlterTable *a, const char *tag, const char *type)
{
	if (soap_out___ns1__AlterTable(soap, tag ? tag : "-ns1:AlterTable", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AlterTable * SOAP_FMAC4 soap_get___ns1__AlterTable(struct soap *soap, struct __ns1__AlterTable *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__AlterTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetFileNew(struct soap *soap, struct __ns1__GetFileNew *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetFileNew = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetFileNew(struct soap *soap, const struct __ns1__GetFileNew *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetFileNew(soap, &a->ns1__GetFileNew);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetFileNew(struct soap *soap, const char *tag, int id, const struct __ns1__GetFileNew *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetFileNew(soap, "ns1:GetFileNew", -1, &a->ns1__GetFileNew, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFileNew * SOAP_FMAC4 soap_in___ns1__GetFileNew(struct soap *soap, const char *tag, struct __ns1__GetFileNew *a, const char *type)
{
	size_t soap_flag_ns1__GetFileNew = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetFileNew *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetFileNew, sizeof(struct __ns1__GetFileNew), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetFileNew(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetFileNew && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetFileNew(soap, "ns1:GetFileNew", &a->ns1__GetFileNew, ""))
				{	soap_flag_ns1__GetFileNew--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetFileNew * SOAP_FMAC2 soap_instantiate___ns1__GetFileNew(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetFileNew(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetFileNew *p;
	size_t k = sizeof(struct __ns1__GetFileNew);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetFileNew, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetFileNew);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetFileNew, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetFileNew location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetFileNew(struct soap *soap, const struct __ns1__GetFileNew *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetFileNew(soap, tag ? tag : "-ns1:GetFileNew", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFileNew * SOAP_FMAC4 soap_get___ns1__GetFileNew(struct soap *soap, struct __ns1__GetFileNew *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetFileNew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DownMapfile(struct soap *soap, struct __ns1__DownMapfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DownMapfile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DownMapfile(struct soap *soap, const struct __ns1__DownMapfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DownMapfile(soap, &a->ns1__DownMapfile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DownMapfile(struct soap *soap, const char *tag, int id, const struct __ns1__DownMapfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DownMapfile(soap, "ns1:DownMapfile", -1, &a->ns1__DownMapfile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownMapfile * SOAP_FMAC4 soap_in___ns1__DownMapfile(struct soap *soap, const char *tag, struct __ns1__DownMapfile *a, const char *type)
{
	size_t soap_flag_ns1__DownMapfile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DownMapfile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DownMapfile, sizeof(struct __ns1__DownMapfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DownMapfile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DownMapfile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__DownMapfile(soap, "ns1:DownMapfile", &a->ns1__DownMapfile, ""))
				{	soap_flag_ns1__DownMapfile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DownMapfile * SOAP_FMAC2 soap_instantiate___ns1__DownMapfile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DownMapfile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DownMapfile *p;
	size_t k = sizeof(struct __ns1__DownMapfile);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__DownMapfile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__DownMapfile);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__DownMapfile, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DownMapfile location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DownMapfile(struct soap *soap, const struct __ns1__DownMapfile *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DownMapfile(soap, tag ? tag : "-ns1:DownMapfile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownMapfile * SOAP_FMAC4 soap_get___ns1__DownMapfile(struct soap *soap, struct __ns1__DownMapfile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DownMapfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDownFileInfo(struct soap *soap, struct __ns1__GetDownFileInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDownFileInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDownFileInfo(struct soap *soap, const struct __ns1__GetDownFileInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetDownFileInfo(soap, &a->ns1__GetDownFileInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDownFileInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetDownFileInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetDownFileInfo(soap, "ns1:GetDownFileInfo", -1, &a->ns1__GetDownFileInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDownFileInfo * SOAP_FMAC4 soap_in___ns1__GetDownFileInfo(struct soap *soap, const char *tag, struct __ns1__GetDownFileInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetDownFileInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetDownFileInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDownFileInfo, sizeof(struct __ns1__GetDownFileInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDownFileInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDownFileInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetDownFileInfo(soap, "ns1:GetDownFileInfo", &a->ns1__GetDownFileInfo, ""))
				{	soap_flag_ns1__GetDownFileInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetDownFileInfo * SOAP_FMAC2 soap_instantiate___ns1__GetDownFileInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDownFileInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetDownFileInfo *p;
	size_t k = sizeof(struct __ns1__GetDownFileInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetDownFileInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetDownFileInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetDownFileInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetDownFileInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDownFileInfo(struct soap *soap, const struct __ns1__GetDownFileInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetDownFileInfo(soap, tag ? tag : "-ns1:GetDownFileInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDownFileInfo * SOAP_FMAC4 soap_get___ns1__GetDownFileInfo(struct soap *soap, struct __ns1__GetDownFileInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDownFileInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetGxDeviceData(struct soap *soap, struct __ns1__GetGxDeviceData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetGxDeviceData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetGxDeviceData(struct soap *soap, const struct __ns1__GetGxDeviceData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetGxDeviceData(soap, &a->ns1__GetGxDeviceData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetGxDeviceData(struct soap *soap, const char *tag, int id, const struct __ns1__GetGxDeviceData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetGxDeviceData(soap, "ns1:GetGxDeviceData", -1, &a->ns1__GetGxDeviceData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetGxDeviceData * SOAP_FMAC4 soap_in___ns1__GetGxDeviceData(struct soap *soap, const char *tag, struct __ns1__GetGxDeviceData *a, const char *type)
{
	size_t soap_flag_ns1__GetGxDeviceData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetGxDeviceData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetGxDeviceData, sizeof(struct __ns1__GetGxDeviceData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetGxDeviceData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetGxDeviceData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetGxDeviceData(soap, "ns1:GetGxDeviceData", &a->ns1__GetGxDeviceData, ""))
				{	soap_flag_ns1__GetGxDeviceData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetGxDeviceData * SOAP_FMAC2 soap_instantiate___ns1__GetGxDeviceData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetGxDeviceData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetGxDeviceData *p;
	size_t k = sizeof(struct __ns1__GetGxDeviceData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetGxDeviceData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetGxDeviceData);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetGxDeviceData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetGxDeviceData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetGxDeviceData(struct soap *soap, const struct __ns1__GetGxDeviceData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetGxDeviceData(soap, tag ? tag : "-ns1:GetGxDeviceData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetGxDeviceData * SOAP_FMAC4 soap_get___ns1__GetGxDeviceData(struct soap *soap, struct __ns1__GetGxDeviceData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetGxDeviceData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetMapDeviceType(struct soap *soap, struct __ns1__GetMapDeviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetMapDeviceType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetMapDeviceType(struct soap *soap, const struct __ns1__GetMapDeviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetMapDeviceType(soap, &a->ns1__GetMapDeviceType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetMapDeviceType(struct soap *soap, const char *tag, int id, const struct __ns1__GetMapDeviceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetMapDeviceType(soap, "ns1:GetMapDeviceType", -1, &a->ns1__GetMapDeviceType, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMapDeviceType * SOAP_FMAC4 soap_in___ns1__GetMapDeviceType(struct soap *soap, const char *tag, struct __ns1__GetMapDeviceType *a, const char *type)
{
	size_t soap_flag_ns1__GetMapDeviceType = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetMapDeviceType *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetMapDeviceType, sizeof(struct __ns1__GetMapDeviceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetMapDeviceType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetMapDeviceType && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetMapDeviceType(soap, "ns1:GetMapDeviceType", &a->ns1__GetMapDeviceType, ""))
				{	soap_flag_ns1__GetMapDeviceType--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetMapDeviceType * SOAP_FMAC2 soap_instantiate___ns1__GetMapDeviceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetMapDeviceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetMapDeviceType *p;
	size_t k = sizeof(struct __ns1__GetMapDeviceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetMapDeviceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetMapDeviceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetMapDeviceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetMapDeviceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetMapDeviceType(struct soap *soap, const struct __ns1__GetMapDeviceType *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetMapDeviceType(soap, tag ? tag : "-ns1:GetMapDeviceType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetMapDeviceType * SOAP_FMAC4 soap_get___ns1__GetMapDeviceType(struct soap *soap, struct __ns1__GetMapDeviceType *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetMapDeviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetXbStationList(struct soap *soap, struct __ns1__GetXbStationList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetXbStationList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetXbStationList(struct soap *soap, const struct __ns1__GetXbStationList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetXbStationList(soap, &a->ns1__GetXbStationList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetXbStationList(struct soap *soap, const char *tag, int id, const struct __ns1__GetXbStationList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetXbStationList(soap, "ns1:GetXbStationList", -1, &a->ns1__GetXbStationList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetXbStationList * SOAP_FMAC4 soap_in___ns1__GetXbStationList(struct soap *soap, const char *tag, struct __ns1__GetXbStationList *a, const char *type)
{
	size_t soap_flag_ns1__GetXbStationList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetXbStationList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetXbStationList, sizeof(struct __ns1__GetXbStationList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetXbStationList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetXbStationList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetXbStationList(soap, "ns1:GetXbStationList", &a->ns1__GetXbStationList, ""))
				{	soap_flag_ns1__GetXbStationList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetXbStationList * SOAP_FMAC2 soap_instantiate___ns1__GetXbStationList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetXbStationList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetXbStationList *p;
	size_t k = sizeof(struct __ns1__GetXbStationList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetXbStationList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetXbStationList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetXbStationList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetXbStationList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetXbStationList(struct soap *soap, const struct __ns1__GetXbStationList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetXbStationList(soap, tag ? tag : "-ns1:GetXbStationList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetXbStationList * SOAP_FMAC4 soap_get___ns1__GetXbStationList(struct soap *soap, struct __ns1__GetXbStationList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetXbStationList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetXbList(struct soap *soap, struct __ns1__GetXbList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetXbList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetXbList(struct soap *soap, const struct __ns1__GetXbList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetXbList(soap, &a->ns1__GetXbList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetXbList(struct soap *soap, const char *tag, int id, const struct __ns1__GetXbList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetXbList(soap, "ns1:GetXbList", -1, &a->ns1__GetXbList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetXbList * SOAP_FMAC4 soap_in___ns1__GetXbList(struct soap *soap, const char *tag, struct __ns1__GetXbList *a, const char *type)
{
	size_t soap_flag_ns1__GetXbList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetXbList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetXbList, sizeof(struct __ns1__GetXbList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetXbList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetXbList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetXbList(soap, "ns1:GetXbList", &a->ns1__GetXbList, ""))
				{	soap_flag_ns1__GetXbList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetXbList * SOAP_FMAC2 soap_instantiate___ns1__GetXbList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetXbList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetXbList *p;
	size_t k = sizeof(struct __ns1__GetXbList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetXbList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetXbList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetXbList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetXbList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetXbList(struct soap *soap, const struct __ns1__GetXbList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetXbList(soap, tag ? tag : "-ns1:GetXbList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetXbList * SOAP_FMAC4 soap_get___ns1__GetXbList(struct soap *soap, struct __ns1__GetXbList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetXbList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetFileSize(struct soap *soap, struct __ns1__GetFileSize *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetFileSize = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetFileSize(struct soap *soap, const struct __ns1__GetFileSize *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetFileSize(soap, &a->ns1__GetFileSize);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetFileSize(struct soap *soap, const char *tag, int id, const struct __ns1__GetFileSize *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetFileSize(soap, "ns1:GetFileSize", -1, &a->ns1__GetFileSize, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFileSize * SOAP_FMAC4 soap_in___ns1__GetFileSize(struct soap *soap, const char *tag, struct __ns1__GetFileSize *a, const char *type)
{
	size_t soap_flag_ns1__GetFileSize = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetFileSize *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetFileSize, sizeof(struct __ns1__GetFileSize), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetFileSize(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetFileSize && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetFileSize(soap, "ns1:GetFileSize", &a->ns1__GetFileSize, ""))
				{	soap_flag_ns1__GetFileSize--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetFileSize * SOAP_FMAC2 soap_instantiate___ns1__GetFileSize(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetFileSize(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetFileSize *p;
	size_t k = sizeof(struct __ns1__GetFileSize);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetFileSize, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetFileSize);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetFileSize, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetFileSize location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetFileSize(struct soap *soap, const struct __ns1__GetFileSize *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetFileSize(soap, tag ? tag : "-ns1:GetFileSize", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFileSize * SOAP_FMAC4 soap_get___ns1__GetFileSize(struct soap *soap, struct __ns1__GetFileSize *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetFileSize(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetUnitPersonInfo(struct soap *soap, struct __ns1__GetUnitPersonInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetUnitPersonInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetUnitPersonInfo(struct soap *soap, const struct __ns1__GetUnitPersonInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetUnitPersonInfo(soap, &a->ns1__GetUnitPersonInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetUnitPersonInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetUnitPersonInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetUnitPersonInfo(soap, "ns1:GetUnitPersonInfo", -1, &a->ns1__GetUnitPersonInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUnitPersonInfo * SOAP_FMAC4 soap_in___ns1__GetUnitPersonInfo(struct soap *soap, const char *tag, struct __ns1__GetUnitPersonInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetUnitPersonInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetUnitPersonInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetUnitPersonInfo, sizeof(struct __ns1__GetUnitPersonInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetUnitPersonInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetUnitPersonInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetUnitPersonInfo(soap, "ns1:GetUnitPersonInfo", &a->ns1__GetUnitPersonInfo, ""))
				{	soap_flag_ns1__GetUnitPersonInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetUnitPersonInfo * SOAP_FMAC2 soap_instantiate___ns1__GetUnitPersonInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetUnitPersonInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetUnitPersonInfo *p;
	size_t k = sizeof(struct __ns1__GetUnitPersonInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetUnitPersonInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetUnitPersonInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetUnitPersonInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetUnitPersonInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetUnitPersonInfo(struct soap *soap, const struct __ns1__GetUnitPersonInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetUnitPersonInfo(soap, tag ? tag : "-ns1:GetUnitPersonInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUnitPersonInfo * SOAP_FMAC4 soap_get___ns1__GetUnitPersonInfo(struct soap *soap, struct __ns1__GetUnitPersonInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetUnitPersonInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetUnitStruct(struct soap *soap, struct __ns1__GetUnitStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetUnitStruct = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetUnitStruct(struct soap *soap, const struct __ns1__GetUnitStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetUnitStruct(soap, &a->ns1__GetUnitStruct);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetUnitStruct(struct soap *soap, const char *tag, int id, const struct __ns1__GetUnitStruct *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetUnitStruct(soap, "ns1:GetUnitStruct", -1, &a->ns1__GetUnitStruct, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUnitStruct * SOAP_FMAC4 soap_in___ns1__GetUnitStruct(struct soap *soap, const char *tag, struct __ns1__GetUnitStruct *a, const char *type)
{
	size_t soap_flag_ns1__GetUnitStruct = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetUnitStruct *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetUnitStruct, sizeof(struct __ns1__GetUnitStruct), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetUnitStruct(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetUnitStruct && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetUnitStruct(soap, "ns1:GetUnitStruct", &a->ns1__GetUnitStruct, ""))
				{	soap_flag_ns1__GetUnitStruct--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetUnitStruct * SOAP_FMAC2 soap_instantiate___ns1__GetUnitStruct(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetUnitStruct(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetUnitStruct *p;
	size_t k = sizeof(struct __ns1__GetUnitStruct);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetUnitStruct, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetUnitStruct);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetUnitStruct, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetUnitStruct location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetUnitStruct(struct soap *soap, const struct __ns1__GetUnitStruct *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetUnitStruct(soap, tag ? tag : "-ns1:GetUnitStruct", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUnitStruct * SOAP_FMAC4 soap_get___ns1__GetUnitStruct(struct soap *soap, struct __ns1__GetUnitStruct *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetUnitStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetUnitStation(struct soap *soap, struct __ns1__GetUnitStation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetUnitStation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetUnitStation(struct soap *soap, const struct __ns1__GetUnitStation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetUnitStation(soap, &a->ns1__GetUnitStation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetUnitStation(struct soap *soap, const char *tag, int id, const struct __ns1__GetUnitStation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetUnitStation(soap, "ns1:GetUnitStation", -1, &a->ns1__GetUnitStation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUnitStation * SOAP_FMAC4 soap_in___ns1__GetUnitStation(struct soap *soap, const char *tag, struct __ns1__GetUnitStation *a, const char *type)
{
	size_t soap_flag_ns1__GetUnitStation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetUnitStation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetUnitStation, sizeof(struct __ns1__GetUnitStation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetUnitStation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetUnitStation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetUnitStation(soap, "ns1:GetUnitStation", &a->ns1__GetUnitStation, ""))
				{	soap_flag_ns1__GetUnitStation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetUnitStation * SOAP_FMAC2 soap_instantiate___ns1__GetUnitStation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetUnitStation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetUnitStation *p;
	size_t k = sizeof(struct __ns1__GetUnitStation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetUnitStation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetUnitStation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetUnitStation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetUnitStation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetUnitStation(struct soap *soap, const struct __ns1__GetUnitStation *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetUnitStation(soap, tag ? tag : "-ns1:GetUnitStation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUnitStation * SOAP_FMAC4 soap_get___ns1__GetUnitStation(struct soap *soap, struct __ns1__GetUnitStation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetUnitStation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDwList(struct soap *soap, struct __ns1__GetDwList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDwList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDwList(struct soap *soap, const struct __ns1__GetDwList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetDwList(soap, &a->ns1__GetDwList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDwList(struct soap *soap, const char *tag, int id, const struct __ns1__GetDwList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetDwList(soap, "ns1:GetDwList", -1, &a->ns1__GetDwList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDwList * SOAP_FMAC4 soap_in___ns1__GetDwList(struct soap *soap, const char *tag, struct __ns1__GetDwList *a, const char *type)
{
	size_t soap_flag_ns1__GetDwList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetDwList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDwList, sizeof(struct __ns1__GetDwList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDwList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDwList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetDwList(soap, "ns1:GetDwList", &a->ns1__GetDwList, ""))
				{	soap_flag_ns1__GetDwList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetDwList * SOAP_FMAC2 soap_instantiate___ns1__GetDwList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDwList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetDwList *p;
	size_t k = sizeof(struct __ns1__GetDwList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetDwList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetDwList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetDwList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetDwList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDwList(struct soap *soap, const struct __ns1__GetDwList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetDwList(soap, tag ? tag : "-ns1:GetDwList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDwList * SOAP_FMAC4 soap_get___ns1__GetDwList(struct soap *soap, struct __ns1__GetDwList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDwList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetOpenFireInfo(struct soap *soap, struct __ns1__GetOpenFireInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetOpenFireInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetOpenFireInfo(struct soap *soap, const struct __ns1__GetOpenFireInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetOpenFireInfo(soap, &a->ns1__GetOpenFireInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetOpenFireInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetOpenFireInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetOpenFireInfo(soap, "ns1:GetOpenFireInfo", -1, &a->ns1__GetOpenFireInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetOpenFireInfo * SOAP_FMAC4 soap_in___ns1__GetOpenFireInfo(struct soap *soap, const char *tag, struct __ns1__GetOpenFireInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetOpenFireInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetOpenFireInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetOpenFireInfo, sizeof(struct __ns1__GetOpenFireInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetOpenFireInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetOpenFireInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetOpenFireInfo(soap, "ns1:GetOpenFireInfo", &a->ns1__GetOpenFireInfo, ""))
				{	soap_flag_ns1__GetOpenFireInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetOpenFireInfo * SOAP_FMAC2 soap_instantiate___ns1__GetOpenFireInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetOpenFireInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetOpenFireInfo *p;
	size_t k = sizeof(struct __ns1__GetOpenFireInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetOpenFireInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetOpenFireInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetOpenFireInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetOpenFireInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetOpenFireInfo(struct soap *soap, const struct __ns1__GetOpenFireInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetOpenFireInfo(soap, tag ? tag : "-ns1:GetOpenFireInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetOpenFireInfo * SOAP_FMAC4 soap_get___ns1__GetOpenFireInfo(struct soap *soap, struct __ns1__GetOpenFireInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetOpenFireInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__MobDownLoadData(struct soap *soap, struct __ns1__MobDownLoadData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__MobDownLoadData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__MobDownLoadData(struct soap *soap, const struct __ns1__MobDownLoadData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__MobDownLoadData(soap, &a->ns1__MobDownLoadData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__MobDownLoadData(struct soap *soap, const char *tag, int id, const struct __ns1__MobDownLoadData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__MobDownLoadData(soap, "ns1:MobDownLoadData", -1, &a->ns1__MobDownLoadData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__MobDownLoadData * SOAP_FMAC4 soap_in___ns1__MobDownLoadData(struct soap *soap, const char *tag, struct __ns1__MobDownLoadData *a, const char *type)
{
	size_t soap_flag_ns1__MobDownLoadData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__MobDownLoadData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__MobDownLoadData, sizeof(struct __ns1__MobDownLoadData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__MobDownLoadData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__MobDownLoadData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__MobDownLoadData(soap, "ns1:MobDownLoadData", &a->ns1__MobDownLoadData, ""))
				{	soap_flag_ns1__MobDownLoadData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__MobDownLoadData * SOAP_FMAC2 soap_instantiate___ns1__MobDownLoadData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__MobDownLoadData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__MobDownLoadData *p;
	size_t k = sizeof(struct __ns1__MobDownLoadData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__MobDownLoadData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__MobDownLoadData);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__MobDownLoadData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__MobDownLoadData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__MobDownLoadData(struct soap *soap, const struct __ns1__MobDownLoadData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__MobDownLoadData(soap, tag ? tag : "-ns1:MobDownLoadData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__MobDownLoadData * SOAP_FMAC4 soap_get___ns1__MobDownLoadData(struct soap *soap, struct __ns1__MobDownLoadData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__MobDownLoadData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DownLoadMobGPSData(struct soap *soap, struct __ns1__DownLoadMobGPSData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DownLoadMobGPSData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DownLoadMobGPSData(struct soap *soap, const struct __ns1__DownLoadMobGPSData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DownLoadMobGPSData(soap, &a->ns1__DownLoadMobGPSData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DownLoadMobGPSData(struct soap *soap, const char *tag, int id, const struct __ns1__DownLoadMobGPSData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DownLoadMobGPSData(soap, "ns1:DownLoadMobGPSData", -1, &a->ns1__DownLoadMobGPSData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownLoadMobGPSData * SOAP_FMAC4 soap_in___ns1__DownLoadMobGPSData(struct soap *soap, const char *tag, struct __ns1__DownLoadMobGPSData *a, const char *type)
{
	size_t soap_flag_ns1__DownLoadMobGPSData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DownLoadMobGPSData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DownLoadMobGPSData, sizeof(struct __ns1__DownLoadMobGPSData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DownLoadMobGPSData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DownLoadMobGPSData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__DownLoadMobGPSData(soap, "ns1:DownLoadMobGPSData", &a->ns1__DownLoadMobGPSData, ""))
				{	soap_flag_ns1__DownLoadMobGPSData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DownLoadMobGPSData * SOAP_FMAC2 soap_instantiate___ns1__DownLoadMobGPSData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DownLoadMobGPSData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DownLoadMobGPSData *p;
	size_t k = sizeof(struct __ns1__DownLoadMobGPSData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__DownLoadMobGPSData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__DownLoadMobGPSData);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__DownLoadMobGPSData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DownLoadMobGPSData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DownLoadMobGPSData(struct soap *soap, const struct __ns1__DownLoadMobGPSData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DownLoadMobGPSData(soap, tag ? tag : "-ns1:DownLoadMobGPSData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownLoadMobGPSData * SOAP_FMAC4 soap_get___ns1__DownLoadMobGPSData(struct soap *soap, struct __ns1__DownLoadMobGPSData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DownLoadMobGPSData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDcsData(struct soap *soap, struct __ns1__GetDcsData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDcsData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDcsData(struct soap *soap, const struct __ns1__GetDcsData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetDcsData(soap, &a->ns1__GetDcsData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDcsData(struct soap *soap, const char *tag, int id, const struct __ns1__GetDcsData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetDcsData(soap, "ns1:GetDcsData", -1, &a->ns1__GetDcsData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDcsData * SOAP_FMAC4 soap_in___ns1__GetDcsData(struct soap *soap, const char *tag, struct __ns1__GetDcsData *a, const char *type)
{
	size_t soap_flag_ns1__GetDcsData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetDcsData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDcsData, sizeof(struct __ns1__GetDcsData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDcsData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDcsData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetDcsData(soap, "ns1:GetDcsData", &a->ns1__GetDcsData, ""))
				{	soap_flag_ns1__GetDcsData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetDcsData * SOAP_FMAC2 soap_instantiate___ns1__GetDcsData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDcsData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetDcsData *p;
	size_t k = sizeof(struct __ns1__GetDcsData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetDcsData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetDcsData);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetDcsData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetDcsData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDcsData(struct soap *soap, const struct __ns1__GetDcsData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetDcsData(soap, tag ? tag : "-ns1:GetDcsData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDcsData * SOAP_FMAC4 soap_get___ns1__GetDcsData(struct soap *soap, struct __ns1__GetDcsData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDcsData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetBgImg(struct soap *soap, struct __ns1__GetBgImg *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetBgImg = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetBgImg(struct soap *soap, const struct __ns1__GetBgImg *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetBgImg(soap, &a->ns1__GetBgImg);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetBgImg(struct soap *soap, const char *tag, int id, const struct __ns1__GetBgImg *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetBgImg(soap, "ns1:GetBgImg", -1, &a->ns1__GetBgImg, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetBgImg * SOAP_FMAC4 soap_in___ns1__GetBgImg(struct soap *soap, const char *tag, struct __ns1__GetBgImg *a, const char *type)
{
	size_t soap_flag_ns1__GetBgImg = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetBgImg *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetBgImg, sizeof(struct __ns1__GetBgImg), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetBgImg(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetBgImg && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetBgImg(soap, "ns1:GetBgImg", &a->ns1__GetBgImg, ""))
				{	soap_flag_ns1__GetBgImg--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetBgImg * SOAP_FMAC2 soap_instantiate___ns1__GetBgImg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetBgImg(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetBgImg *p;
	size_t k = sizeof(struct __ns1__GetBgImg);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetBgImg, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetBgImg);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetBgImg, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetBgImg location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetBgImg(struct soap *soap, const struct __ns1__GetBgImg *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetBgImg(soap, tag ? tag : "-ns1:GetBgImg", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetBgImg * SOAP_FMAC4 soap_get___ns1__GetBgImg(struct soap *soap, struct __ns1__GetBgImg *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetBgImg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDevPic(struct soap *soap, struct __ns1__GetDevPic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDevPic = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDevPic(struct soap *soap, const struct __ns1__GetDevPic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetDevPic(soap, &a->ns1__GetDevPic);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDevPic(struct soap *soap, const char *tag, int id, const struct __ns1__GetDevPic *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetDevPic(soap, "ns1:GetDevPic", -1, &a->ns1__GetDevPic, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDevPic * SOAP_FMAC4 soap_in___ns1__GetDevPic(struct soap *soap, const char *tag, struct __ns1__GetDevPic *a, const char *type)
{
	size_t soap_flag_ns1__GetDevPic = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetDevPic *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDevPic, sizeof(struct __ns1__GetDevPic), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDevPic(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDevPic && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetDevPic(soap, "ns1:GetDevPic", &a->ns1__GetDevPic, ""))
				{	soap_flag_ns1__GetDevPic--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetDevPic * SOAP_FMAC2 soap_instantiate___ns1__GetDevPic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDevPic(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetDevPic *p;
	size_t k = sizeof(struct __ns1__GetDevPic);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetDevPic, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetDevPic);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetDevPic, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetDevPic location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDevPic(struct soap *soap, const struct __ns1__GetDevPic *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetDevPic(soap, tag ? tag : "-ns1:GetDevPic", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDevPic * SOAP_FMAC4 soap_get___ns1__GetDevPic(struct soap *soap, struct __ns1__GetDevPic *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDevPic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetJxPic(struct soap *soap, struct __ns1__GetJxPic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetJxPic = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetJxPic(struct soap *soap, const struct __ns1__GetJxPic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetJxPic(soap, &a->ns1__GetJxPic);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetJxPic(struct soap *soap, const char *tag, int id, const struct __ns1__GetJxPic *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetJxPic(soap, "ns1:GetJxPic", -1, &a->ns1__GetJxPic, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetJxPic * SOAP_FMAC4 soap_in___ns1__GetJxPic(struct soap *soap, const char *tag, struct __ns1__GetJxPic *a, const char *type)
{
	size_t soap_flag_ns1__GetJxPic = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetJxPic *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetJxPic, sizeof(struct __ns1__GetJxPic), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetJxPic(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetJxPic && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetJxPic(soap, "ns1:GetJxPic", &a->ns1__GetJxPic, ""))
				{	soap_flag_ns1__GetJxPic--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetJxPic * SOAP_FMAC2 soap_instantiate___ns1__GetJxPic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetJxPic(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetJxPic *p;
	size_t k = sizeof(struct __ns1__GetJxPic);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetJxPic, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetJxPic);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetJxPic, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetJxPic location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetJxPic(struct soap *soap, const struct __ns1__GetJxPic *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetJxPic(soap, tag ? tag : "-ns1:GetJxPic", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetJxPic * SOAP_FMAC4 soap_get___ns1__GetJxPic(struct soap *soap, struct __ns1__GetJxPic *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetJxPic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetStationJxData(struct soap *soap, struct __ns1__GetStationJxData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetStationJxData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetStationJxData(struct soap *soap, const struct __ns1__GetStationJxData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetStationJxData(soap, &a->ns1__GetStationJxData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetStationJxData(struct soap *soap, const char *tag, int id, const struct __ns1__GetStationJxData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetStationJxData(soap, "ns1:GetStationJxData", -1, &a->ns1__GetStationJxData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetStationJxData * SOAP_FMAC4 soap_in___ns1__GetStationJxData(struct soap *soap, const char *tag, struct __ns1__GetStationJxData *a, const char *type)
{
	size_t soap_flag_ns1__GetStationJxData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetStationJxData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetStationJxData, sizeof(struct __ns1__GetStationJxData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetStationJxData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetStationJxData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetStationJxData(soap, "ns1:GetStationJxData", &a->ns1__GetStationJxData, ""))
				{	soap_flag_ns1__GetStationJxData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetStationJxData * SOAP_FMAC2 soap_instantiate___ns1__GetStationJxData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetStationJxData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetStationJxData *p;
	size_t k = sizeof(struct __ns1__GetStationJxData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetStationJxData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetStationJxData);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetStationJxData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetStationJxData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetStationJxData(struct soap *soap, const struct __ns1__GetStationJxData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetStationJxData(soap, tag ? tag : "-ns1:GetStationJxData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetStationJxData * SOAP_FMAC4 soap_get___ns1__GetStationJxData(struct soap *soap, struct __ns1__GetStationJxData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetStationJxData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetJxData(struct soap *soap, struct __ns1__GetJxData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetJxData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetJxData(struct soap *soap, const struct __ns1__GetJxData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetJxData(soap, &a->ns1__GetJxData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetJxData(struct soap *soap, const char *tag, int id, const struct __ns1__GetJxData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetJxData(soap, "ns1:GetJxData", -1, &a->ns1__GetJxData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetJxData * SOAP_FMAC4 soap_in___ns1__GetJxData(struct soap *soap, const char *tag, struct __ns1__GetJxData *a, const char *type)
{
	size_t soap_flag_ns1__GetJxData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetJxData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetJxData, sizeof(struct __ns1__GetJxData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetJxData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetJxData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetJxData(soap, "ns1:GetJxData", &a->ns1__GetJxData, ""))
				{	soap_flag_ns1__GetJxData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetJxData * SOAP_FMAC2 soap_instantiate___ns1__GetJxData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetJxData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetJxData *p;
	size_t k = sizeof(struct __ns1__GetJxData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetJxData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetJxData);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetJxData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetJxData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetJxData(struct soap *soap, const struct __ns1__GetJxData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetJxData(soap, tag ? tag : "-ns1:GetJxData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetJxData * SOAP_FMAC4 soap_get___ns1__GetJxData(struct soap *soap, struct __ns1__GetJxData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetJxData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDeviceXj(struct soap *soap, struct __ns1__GetDeviceXj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDeviceXj = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDeviceXj(struct soap *soap, const struct __ns1__GetDeviceXj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetDeviceXj(soap, &a->ns1__GetDeviceXj);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDeviceXj(struct soap *soap, const char *tag, int id, const struct __ns1__GetDeviceXj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetDeviceXj(soap, "ns1:GetDeviceXj", -1, &a->ns1__GetDeviceXj, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDeviceXj * SOAP_FMAC4 soap_in___ns1__GetDeviceXj(struct soap *soap, const char *tag, struct __ns1__GetDeviceXj *a, const char *type)
{
	size_t soap_flag_ns1__GetDeviceXj = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetDeviceXj *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDeviceXj, sizeof(struct __ns1__GetDeviceXj), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDeviceXj(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDeviceXj && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetDeviceXj(soap, "ns1:GetDeviceXj", &a->ns1__GetDeviceXj, ""))
				{	soap_flag_ns1__GetDeviceXj--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetDeviceXj * SOAP_FMAC2 soap_instantiate___ns1__GetDeviceXj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDeviceXj(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetDeviceXj *p;
	size_t k = sizeof(struct __ns1__GetDeviceXj);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetDeviceXj, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetDeviceXj);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetDeviceXj, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetDeviceXj location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDeviceXj(struct soap *soap, const struct __ns1__GetDeviceXj *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetDeviceXj(soap, tag ? tag : "-ns1:GetDeviceXj", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDeviceXj * SOAP_FMAC4 soap_get___ns1__GetDeviceXj(struct soap *soap, struct __ns1__GetDeviceXj *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDeviceXj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDwPic(struct soap *soap, struct __ns1__GetDwPic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDwPic = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDwPic(struct soap *soap, const struct __ns1__GetDwPic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetDwPic(soap, &a->ns1__GetDwPic);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDwPic(struct soap *soap, const char *tag, int id, const struct __ns1__GetDwPic *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetDwPic(soap, "ns1:GetDwPic", -1, &a->ns1__GetDwPic, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDwPic * SOAP_FMAC4 soap_in___ns1__GetDwPic(struct soap *soap, const char *tag, struct __ns1__GetDwPic *a, const char *type)
{
	size_t soap_flag_ns1__GetDwPic = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetDwPic *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDwPic, sizeof(struct __ns1__GetDwPic), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDwPic(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDwPic && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetDwPic(soap, "ns1:GetDwPic", &a->ns1__GetDwPic, ""))
				{	soap_flag_ns1__GetDwPic--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetDwPic * SOAP_FMAC2 soap_instantiate___ns1__GetDwPic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDwPic(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetDwPic *p;
	size_t k = sizeof(struct __ns1__GetDwPic);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetDwPic, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetDwPic);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetDwPic, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetDwPic location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDwPic(struct soap *soap, const struct __ns1__GetDwPic *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetDwPic(soap, tag ? tag : "-ns1:GetDwPic", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDwPic * SOAP_FMAC4 soap_get___ns1__GetDwPic(struct soap *soap, struct __ns1__GetDwPic *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDwPic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDwInfo(struct soap *soap, struct __ns1__GetDwInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDwInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDwInfo(struct soap *soap, const struct __ns1__GetDwInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetDwInfo(soap, &a->ns1__GetDwInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDwInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetDwInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetDwInfo(soap, "ns1:GetDwInfo", -1, &a->ns1__GetDwInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDwInfo * SOAP_FMAC4 soap_in___ns1__GetDwInfo(struct soap *soap, const char *tag, struct __ns1__GetDwInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetDwInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetDwInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDwInfo, sizeof(struct __ns1__GetDwInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDwInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDwInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetDwInfo(soap, "ns1:GetDwInfo", &a->ns1__GetDwInfo, ""))
				{	soap_flag_ns1__GetDwInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetDwInfo * SOAP_FMAC2 soap_instantiate___ns1__GetDwInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDwInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetDwInfo *p;
	size_t k = sizeof(struct __ns1__GetDwInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetDwInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetDwInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetDwInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetDwInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDwInfo(struct soap *soap, const struct __ns1__GetDwInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetDwInfo(soap, tag ? tag : "-ns1:GetDwInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDwInfo * SOAP_FMAC4 soap_get___ns1__GetDwInfo(struct soap *soap, struct __ns1__GetDwInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDwInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetPicNames(struct soap *soap, struct __ns1__GetPicNames *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPicNames = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetPicNames(struct soap *soap, const struct __ns1__GetPicNames *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetPicNames(soap, &a->ns1__GetPicNames);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetPicNames(struct soap *soap, const char *tag, int id, const struct __ns1__GetPicNames *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetPicNames(soap, "ns1:GetPicNames", -1, &a->ns1__GetPicNames, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPicNames * SOAP_FMAC4 soap_in___ns1__GetPicNames(struct soap *soap, const char *tag, struct __ns1__GetPicNames *a, const char *type)
{
	size_t soap_flag_ns1__GetPicNames = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetPicNames *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetPicNames, sizeof(struct __ns1__GetPicNames), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetPicNames(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPicNames && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetPicNames(soap, "ns1:GetPicNames", &a->ns1__GetPicNames, ""))
				{	soap_flag_ns1__GetPicNames--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetPicNames * SOAP_FMAC2 soap_instantiate___ns1__GetPicNames(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetPicNames(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetPicNames *p;
	size_t k = sizeof(struct __ns1__GetPicNames);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetPicNames, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetPicNames);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetPicNames, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetPicNames location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetPicNames(struct soap *soap, const struct __ns1__GetPicNames *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetPicNames(soap, tag ? tag : "-ns1:GetPicNames", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPicNames * SOAP_FMAC4 soap_get___ns1__GetPicNames(struct soap *soap, struct __ns1__GetPicNames *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetPicNames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DownloadPic(struct soap *soap, struct __ns1__DownloadPic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DownloadPic = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DownloadPic(struct soap *soap, const struct __ns1__DownloadPic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DownloadPic(soap, &a->ns1__DownloadPic);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DownloadPic(struct soap *soap, const char *tag, int id, const struct __ns1__DownloadPic *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DownloadPic(soap, "ns1:DownloadPic", -1, &a->ns1__DownloadPic, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownloadPic * SOAP_FMAC4 soap_in___ns1__DownloadPic(struct soap *soap, const char *tag, struct __ns1__DownloadPic *a, const char *type)
{
	size_t soap_flag_ns1__DownloadPic = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DownloadPic *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DownloadPic, sizeof(struct __ns1__DownloadPic), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DownloadPic(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DownloadPic && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__DownloadPic(soap, "ns1:DownloadPic", &a->ns1__DownloadPic, ""))
				{	soap_flag_ns1__DownloadPic--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DownloadPic * SOAP_FMAC2 soap_instantiate___ns1__DownloadPic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DownloadPic(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DownloadPic *p;
	size_t k = sizeof(struct __ns1__DownloadPic);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__DownloadPic, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__DownloadPic);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__DownloadPic, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DownloadPic location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DownloadPic(struct soap *soap, const struct __ns1__DownloadPic *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DownloadPic(soap, tag ? tag : "-ns1:DownloadPic", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownloadPic * SOAP_FMAC4 soap_get___ns1__DownloadPic(struct soap *soap, struct __ns1__DownloadPic *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DownloadPic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__upPic(struct soap *soap, struct __ns1__upPic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__upPic = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__upPic(struct soap *soap, const struct __ns1__upPic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__upPic(soap, &a->ns1__upPic);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__upPic(struct soap *soap, const char *tag, int id, const struct __ns1__upPic *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__upPic(soap, "ns1:upPic", -1, &a->ns1__upPic, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__upPic * SOAP_FMAC4 soap_in___ns1__upPic(struct soap *soap, const char *tag, struct __ns1__upPic *a, const char *type)
{
	size_t soap_flag_ns1__upPic = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__upPic *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__upPic, sizeof(struct __ns1__upPic), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__upPic(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__upPic && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__upPic(soap, "ns1:upPic", &a->ns1__upPic, ""))
				{	soap_flag_ns1__upPic--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__upPic * SOAP_FMAC2 soap_instantiate___ns1__upPic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__upPic(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__upPic *p;
	size_t k = sizeof(struct __ns1__upPic);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__upPic, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__upPic);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__upPic, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__upPic location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__upPic(struct soap *soap, const struct __ns1__upPic *a, const char *tag, const char *type)
{
	if (soap_out___ns1__upPic(soap, tag ? tag : "-ns1:upPic", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__upPic * SOAP_FMAC4 soap_get___ns1__upPic(struct soap *soap, struct __ns1__upPic *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__upPic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpLoadFile(struct soap *soap, struct __ns1__UpLoadFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpLoadFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpLoadFile(struct soap *soap, const struct __ns1__UpLoadFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UpLoadFile(soap, &a->ns1__UpLoadFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpLoadFile(struct soap *soap, const char *tag, int id, const struct __ns1__UpLoadFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UpLoadFile(soap, "ns1:UpLoadFile", -1, &a->ns1__UpLoadFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpLoadFile * SOAP_FMAC4 soap_in___ns1__UpLoadFile(struct soap *soap, const char *tag, struct __ns1__UpLoadFile *a, const char *type)
{
	size_t soap_flag_ns1__UpLoadFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UpLoadFile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpLoadFile, sizeof(struct __ns1__UpLoadFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpLoadFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpLoadFile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__UpLoadFile(soap, "ns1:UpLoadFile", &a->ns1__UpLoadFile, ""))
				{	soap_flag_ns1__UpLoadFile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__UpLoadFile * SOAP_FMAC2 soap_instantiate___ns1__UpLoadFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpLoadFile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UpLoadFile *p;
	size_t k = sizeof(struct __ns1__UpLoadFile);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__UpLoadFile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__UpLoadFile);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__UpLoadFile, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UpLoadFile location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpLoadFile(struct soap *soap, const struct __ns1__UpLoadFile *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UpLoadFile(soap, tag ? tag : "-ns1:UpLoadFile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpLoadFile * SOAP_FMAC4 soap_get___ns1__UpLoadFile(struct soap *soap, struct __ns1__UpLoadFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpLoadFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAPVupdater(struct soap *soap, struct __ns1__GetAPVupdater *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAPVupdater = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAPVupdater(struct soap *soap, const struct __ns1__GetAPVupdater *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetAPVupdater(soap, &a->ns1__GetAPVupdater);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAPVupdater(struct soap *soap, const char *tag, int id, const struct __ns1__GetAPVupdater *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetAPVupdater(soap, "ns1:GetAPVupdater", -1, &a->ns1__GetAPVupdater, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAPVupdater * SOAP_FMAC4 soap_in___ns1__GetAPVupdater(struct soap *soap, const char *tag, struct __ns1__GetAPVupdater *a, const char *type)
{
	size_t soap_flag_ns1__GetAPVupdater = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetAPVupdater *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAPVupdater, sizeof(struct __ns1__GetAPVupdater), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAPVupdater(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAPVupdater && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetAPVupdater(soap, "ns1:GetAPVupdater", &a->ns1__GetAPVupdater, ""))
				{	soap_flag_ns1__GetAPVupdater--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetAPVupdater * SOAP_FMAC2 soap_instantiate___ns1__GetAPVupdater(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAPVupdater(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetAPVupdater *p;
	size_t k = sizeof(struct __ns1__GetAPVupdater);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetAPVupdater, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetAPVupdater);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetAPVupdater, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetAPVupdater location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAPVupdater(struct soap *soap, const struct __ns1__GetAPVupdater *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetAPVupdater(soap, tag ? tag : "-ns1:GetAPVupdater", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAPVupdater * SOAP_FMAC4 soap_get___ns1__GetAPVupdater(struct soap *soap, struct __ns1__GetAPVupdater *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAPVupdater(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetXHYDGLXTupdater(struct soap *soap, struct __ns1__GetXHYDGLXTupdater *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetXHYDGLXTupdater = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetXHYDGLXTupdater(struct soap *soap, const struct __ns1__GetXHYDGLXTupdater *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetXHYDGLXTupdater(soap, &a->ns1__GetXHYDGLXTupdater);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetXHYDGLXTupdater(struct soap *soap, const char *tag, int id, const struct __ns1__GetXHYDGLXTupdater *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetXHYDGLXTupdater(soap, "ns1:GetXHYDGLXTupdater", -1, &a->ns1__GetXHYDGLXTupdater, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetXHYDGLXTupdater * SOAP_FMAC4 soap_in___ns1__GetXHYDGLXTupdater(struct soap *soap, const char *tag, struct __ns1__GetXHYDGLXTupdater *a, const char *type)
{
	size_t soap_flag_ns1__GetXHYDGLXTupdater = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetXHYDGLXTupdater *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetXHYDGLXTupdater, sizeof(struct __ns1__GetXHYDGLXTupdater), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetXHYDGLXTupdater(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetXHYDGLXTupdater && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetXHYDGLXTupdater(soap, "ns1:GetXHYDGLXTupdater", &a->ns1__GetXHYDGLXTupdater, ""))
				{	soap_flag_ns1__GetXHYDGLXTupdater--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetXHYDGLXTupdater * SOAP_FMAC2 soap_instantiate___ns1__GetXHYDGLXTupdater(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetXHYDGLXTupdater(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetXHYDGLXTupdater *p;
	size_t k = sizeof(struct __ns1__GetXHYDGLXTupdater);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetXHYDGLXTupdater, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetXHYDGLXTupdater);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetXHYDGLXTupdater, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetXHYDGLXTupdater location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetXHYDGLXTupdater(struct soap *soap, const struct __ns1__GetXHYDGLXTupdater *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetXHYDGLXTupdater(soap, tag ? tag : "-ns1:GetXHYDGLXTupdater", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetXHYDGLXTupdater * SOAP_FMAC4 soap_get___ns1__GetXHYDGLXTupdater(struct soap *soap, struct __ns1__GetXHYDGLXTupdater *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetXHYDGLXTupdater(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ExecuteSqlForColb(struct soap *soap, struct __ns1__ExecuteSqlForColb *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ExecuteSqlForColb = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ExecuteSqlForColb(struct soap *soap, const struct __ns1__ExecuteSqlForColb *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ExecuteSqlForColb(soap, &a->ns1__ExecuteSqlForColb);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ExecuteSqlForColb(struct soap *soap, const char *tag, int id, const struct __ns1__ExecuteSqlForColb *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ExecuteSqlForColb(soap, "ns1:ExecuteSqlForColb", -1, &a->ns1__ExecuteSqlForColb, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExecuteSqlForColb * SOAP_FMAC4 soap_in___ns1__ExecuteSqlForColb(struct soap *soap, const char *tag, struct __ns1__ExecuteSqlForColb *a, const char *type)
{
	size_t soap_flag_ns1__ExecuteSqlForColb = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ExecuteSqlForColb *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ExecuteSqlForColb, sizeof(struct __ns1__ExecuteSqlForColb), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ExecuteSqlForColb(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ExecuteSqlForColb && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ExecuteSqlForColb(soap, "ns1:ExecuteSqlForColb", &a->ns1__ExecuteSqlForColb, ""))
				{	soap_flag_ns1__ExecuteSqlForColb--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ExecuteSqlForColb * SOAP_FMAC2 soap_instantiate___ns1__ExecuteSqlForColb(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ExecuteSqlForColb(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ExecuteSqlForColb *p;
	size_t k = sizeof(struct __ns1__ExecuteSqlForColb);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ExecuteSqlForColb, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ExecuteSqlForColb);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ExecuteSqlForColb, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ExecuteSqlForColb location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ExecuteSqlForColb(struct soap *soap, const struct __ns1__ExecuteSqlForColb *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ExecuteSqlForColb(soap, tag ? tag : "-ns1:ExecuteSqlForColb", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExecuteSqlForColb * SOAP_FMAC4 soap_get___ns1__ExecuteSqlForColb(struct soap *soap, struct __ns1__ExecuteSqlForColb *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ExecuteSqlForColb(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpLoadData(struct soap *soap, struct __ns1__UpLoadData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpLoadData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpLoadData(struct soap *soap, const struct __ns1__UpLoadData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UpLoadData(soap, &a->ns1__UpLoadData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpLoadData(struct soap *soap, const char *tag, int id, const struct __ns1__UpLoadData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UpLoadData(soap, "ns1:UpLoadData", -1, &a->ns1__UpLoadData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpLoadData * SOAP_FMAC4 soap_in___ns1__UpLoadData(struct soap *soap, const char *tag, struct __ns1__UpLoadData *a, const char *type)
{
	size_t soap_flag_ns1__UpLoadData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UpLoadData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpLoadData, sizeof(struct __ns1__UpLoadData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpLoadData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpLoadData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__UpLoadData(soap, "ns1:UpLoadData", &a->ns1__UpLoadData, ""))
				{	soap_flag_ns1__UpLoadData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__UpLoadData * SOAP_FMAC2 soap_instantiate___ns1__UpLoadData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpLoadData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UpLoadData *p;
	size_t k = sizeof(struct __ns1__UpLoadData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__UpLoadData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__UpLoadData);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__UpLoadData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UpLoadData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpLoadData(struct soap *soap, const struct __ns1__UpLoadData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UpLoadData(soap, tag ? tag : "-ns1:UpLoadData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpLoadData * SOAP_FMAC4 soap_get___ns1__UpLoadData(struct soap *soap, struct __ns1__UpLoadData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpLoadData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__TcdSendup(struct soap *soap, struct __ns1__TcdSendup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__TcdSendup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__TcdSendup(struct soap *soap, const struct __ns1__TcdSendup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__TcdSendup(soap, &a->ns1__TcdSendup);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__TcdSendup(struct soap *soap, const char *tag, int id, const struct __ns1__TcdSendup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__TcdSendup(soap, "ns1:TcdSendup", -1, &a->ns1__TcdSendup, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TcdSendup * SOAP_FMAC4 soap_in___ns1__TcdSendup(struct soap *soap, const char *tag, struct __ns1__TcdSendup *a, const char *type)
{
	size_t soap_flag_ns1__TcdSendup = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__TcdSendup *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__TcdSendup, sizeof(struct __ns1__TcdSendup), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__TcdSendup(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__TcdSendup && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__TcdSendup(soap, "ns1:TcdSendup", &a->ns1__TcdSendup, ""))
				{	soap_flag_ns1__TcdSendup--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__TcdSendup * SOAP_FMAC2 soap_instantiate___ns1__TcdSendup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__TcdSendup(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__TcdSendup *p;
	size_t k = sizeof(struct __ns1__TcdSendup);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__TcdSendup, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__TcdSendup);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__TcdSendup, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__TcdSendup location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__TcdSendup(struct soap *soap, const struct __ns1__TcdSendup *a, const char *tag, const char *type)
{
	if (soap_out___ns1__TcdSendup(soap, tag ? tag : "-ns1:TcdSendup", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TcdSendup * SOAP_FMAC4 soap_get___ns1__TcdSendup(struct soap *soap, struct __ns1__TcdSendup *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__TcdSendup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__TcdQuery(struct soap *soap, struct __ns1__TcdQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__TcdQuery = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__TcdQuery(struct soap *soap, const struct __ns1__TcdQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__TcdQuery(soap, &a->ns1__TcdQuery);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__TcdQuery(struct soap *soap, const char *tag, int id, const struct __ns1__TcdQuery *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__TcdQuery(soap, "ns1:TcdQuery", -1, &a->ns1__TcdQuery, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TcdQuery * SOAP_FMAC4 soap_in___ns1__TcdQuery(struct soap *soap, const char *tag, struct __ns1__TcdQuery *a, const char *type)
{
	size_t soap_flag_ns1__TcdQuery = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__TcdQuery *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__TcdQuery, sizeof(struct __ns1__TcdQuery), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__TcdQuery(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__TcdQuery && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__TcdQuery(soap, "ns1:TcdQuery", &a->ns1__TcdQuery, ""))
				{	soap_flag_ns1__TcdQuery--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__TcdQuery * SOAP_FMAC2 soap_instantiate___ns1__TcdQuery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__TcdQuery(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__TcdQuery *p;
	size_t k = sizeof(struct __ns1__TcdQuery);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__TcdQuery, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__TcdQuery);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__TcdQuery, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__TcdQuery location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__TcdQuery(struct soap *soap, const struct __ns1__TcdQuery *a, const char *tag, const char *type)
{
	if (soap_out___ns1__TcdQuery(soap, tag ? tag : "-ns1:TcdQuery", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TcdQuery * SOAP_FMAC4 soap_get___ns1__TcdQuery(struct soap *soap, struct __ns1__TcdQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__TcdQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QueryPhotobw(struct soap *soap, struct __ns1__QueryPhotobw *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QueryPhotobw = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QueryPhotobw(struct soap *soap, const struct __ns1__QueryPhotobw *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__QueryPhotobw(soap, &a->ns1__QueryPhotobw);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QueryPhotobw(struct soap *soap, const char *tag, int id, const struct __ns1__QueryPhotobw *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__QueryPhotobw(soap, "ns1:QueryPhotobw", -1, &a->ns1__QueryPhotobw, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QueryPhotobw * SOAP_FMAC4 soap_in___ns1__QueryPhotobw(struct soap *soap, const char *tag, struct __ns1__QueryPhotobw *a, const char *type)
{
	size_t soap_flag_ns1__QueryPhotobw = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QueryPhotobw *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__QueryPhotobw, sizeof(struct __ns1__QueryPhotobw), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QueryPhotobw(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QueryPhotobw && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__QueryPhotobw(soap, "ns1:QueryPhotobw", &a->ns1__QueryPhotobw, ""))
				{	soap_flag_ns1__QueryPhotobw--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QueryPhotobw * SOAP_FMAC2 soap_instantiate___ns1__QueryPhotobw(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QueryPhotobw(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QueryPhotobw *p;
	size_t k = sizeof(struct __ns1__QueryPhotobw);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__QueryPhotobw, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__QueryPhotobw);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__QueryPhotobw, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QueryPhotobw location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QueryPhotobw(struct soap *soap, const struct __ns1__QueryPhotobw *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QueryPhotobw(soap, tag ? tag : "-ns1:QueryPhotobw", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QueryPhotobw * SOAP_FMAC4 soap_get___ns1__QueryPhotobw(struct soap *soap, struct __ns1__QueryPhotobw *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QueryPhotobw(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetOsDateTime(struct soap *soap, struct __ns1__GetOsDateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetOsDateTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetOsDateTime(struct soap *soap, const struct __ns1__GetOsDateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetOsDateTime(soap, &a->ns1__GetOsDateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetOsDateTime(struct soap *soap, const char *tag, int id, const struct __ns1__GetOsDateTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetOsDateTime(soap, "ns1:GetOsDateTime", -1, &a->ns1__GetOsDateTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetOsDateTime * SOAP_FMAC4 soap_in___ns1__GetOsDateTime(struct soap *soap, const char *tag, struct __ns1__GetOsDateTime *a, const char *type)
{
	size_t soap_flag_ns1__GetOsDateTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetOsDateTime *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetOsDateTime, sizeof(struct __ns1__GetOsDateTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetOsDateTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetOsDateTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetOsDateTime(soap, "ns1:GetOsDateTime", &a->ns1__GetOsDateTime, ""))
				{	soap_flag_ns1__GetOsDateTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetOsDateTime * SOAP_FMAC2 soap_instantiate___ns1__GetOsDateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetOsDateTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetOsDateTime *p;
	size_t k = sizeof(struct __ns1__GetOsDateTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetOsDateTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetOsDateTime);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetOsDateTime, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetOsDateTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetOsDateTime(struct soap *soap, const struct __ns1__GetOsDateTime *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetOsDateTime(soap, tag ? tag : "-ns1:GetOsDateTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetOsDateTime * SOAP_FMAC4 soap_get___ns1__GetOsDateTime(struct soap *soap, struct __ns1__GetOsDateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetOsDateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__signedUserInfo(struct soap *soap, struct __ns1__signedUserInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__signedUserInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__signedUserInfo(struct soap *soap, const struct __ns1__signedUserInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__signedUserInfo(soap, &a->ns1__signedUserInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__signedUserInfo(struct soap *soap, const char *tag, int id, const struct __ns1__signedUserInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__signedUserInfo(soap, "ns1:signedUserInfo", -1, &a->ns1__signedUserInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__signedUserInfo * SOAP_FMAC4 soap_in___ns1__signedUserInfo(struct soap *soap, const char *tag, struct __ns1__signedUserInfo *a, const char *type)
{
	size_t soap_flag_ns1__signedUserInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__signedUserInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__signedUserInfo, sizeof(struct __ns1__signedUserInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__signedUserInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__signedUserInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__signedUserInfo(soap, "ns1:signedUserInfo", &a->ns1__signedUserInfo, ""))
				{	soap_flag_ns1__signedUserInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__signedUserInfo * SOAP_FMAC2 soap_instantiate___ns1__signedUserInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__signedUserInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__signedUserInfo *p;
	size_t k = sizeof(struct __ns1__signedUserInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__signedUserInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__signedUserInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__signedUserInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__signedUserInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__signedUserInfo(struct soap *soap, const struct __ns1__signedUserInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__signedUserInfo(soap, tag ? tag : "-ns1:signedUserInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__signedUserInfo * SOAP_FMAC4 soap_get___ns1__signedUserInfo(struct soap *soap, struct __ns1__signedUserInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__signedUserInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetGxdataUpTime(struct soap *soap, struct __ns1__GetGxdataUpTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetGxdataUpTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetGxdataUpTime(struct soap *soap, const struct __ns1__GetGxdataUpTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetGxdataUpTime(soap, &a->ns1__GetGxdataUpTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetGxdataUpTime(struct soap *soap, const char *tag, int id, const struct __ns1__GetGxdataUpTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetGxdataUpTime(soap, "ns1:GetGxdataUpTime", -1, &a->ns1__GetGxdataUpTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetGxdataUpTime * SOAP_FMAC4 soap_in___ns1__GetGxdataUpTime(struct soap *soap, const char *tag, struct __ns1__GetGxdataUpTime *a, const char *type)
{
	size_t soap_flag_ns1__GetGxdataUpTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetGxdataUpTime *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetGxdataUpTime, sizeof(struct __ns1__GetGxdataUpTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetGxdataUpTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetGxdataUpTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetGxdataUpTime(soap, "ns1:GetGxdataUpTime", &a->ns1__GetGxdataUpTime, ""))
				{	soap_flag_ns1__GetGxdataUpTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetGxdataUpTime * SOAP_FMAC2 soap_instantiate___ns1__GetGxdataUpTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetGxdataUpTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetGxdataUpTime *p;
	size_t k = sizeof(struct __ns1__GetGxdataUpTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetGxdataUpTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetGxdataUpTime);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetGxdataUpTime, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetGxdataUpTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetGxdataUpTime(struct soap *soap, const struct __ns1__GetGxdataUpTime *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetGxdataUpTime(soap, tag ? tag : "-ns1:GetGxdataUpTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetGxdataUpTime * SOAP_FMAC4 soap_get___ns1__GetGxdataUpTime(struct soap *soap, struct __ns1__GetGxdataUpTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetGxdataUpTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DownAllPic(struct soap *soap, struct __ns1__DownAllPic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DownAllPic = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DownAllPic(struct soap *soap, const struct __ns1__DownAllPic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DownAllPic(soap, &a->ns1__DownAllPic);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DownAllPic(struct soap *soap, const char *tag, int id, const struct __ns1__DownAllPic *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DownAllPic(soap, "ns1:DownAllPic", -1, &a->ns1__DownAllPic, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownAllPic * SOAP_FMAC4 soap_in___ns1__DownAllPic(struct soap *soap, const char *tag, struct __ns1__DownAllPic *a, const char *type)
{
	size_t soap_flag_ns1__DownAllPic = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DownAllPic *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DownAllPic, sizeof(struct __ns1__DownAllPic), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DownAllPic(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DownAllPic && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__DownAllPic(soap, "ns1:DownAllPic", &a->ns1__DownAllPic, ""))
				{	soap_flag_ns1__DownAllPic--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DownAllPic * SOAP_FMAC2 soap_instantiate___ns1__DownAllPic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DownAllPic(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DownAllPic *p;
	size_t k = sizeof(struct __ns1__DownAllPic);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__DownAllPic, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__DownAllPic);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__DownAllPic, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DownAllPic location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DownAllPic(struct soap *soap, const struct __ns1__DownAllPic *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DownAllPic(soap, tag ? tag : "-ns1:DownAllPic", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownAllPic * SOAP_FMAC4 soap_get___ns1__DownAllPic(struct soap *soap, struct __ns1__DownAllPic *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DownAllPic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DownPic(struct soap *soap, struct __ns1__DownPic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DownPic = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DownPic(struct soap *soap, const struct __ns1__DownPic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DownPic(soap, &a->ns1__DownPic);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DownPic(struct soap *soap, const char *tag, int id, const struct __ns1__DownPic *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DownPic(soap, "ns1:DownPic", -1, &a->ns1__DownPic, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownPic * SOAP_FMAC4 soap_in___ns1__DownPic(struct soap *soap, const char *tag, struct __ns1__DownPic *a, const char *type)
{
	size_t soap_flag_ns1__DownPic = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DownPic *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DownPic, sizeof(struct __ns1__DownPic), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DownPic(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DownPic && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__DownPic(soap, "ns1:DownPic", &a->ns1__DownPic, ""))
				{	soap_flag_ns1__DownPic--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DownPic * SOAP_FMAC2 soap_instantiate___ns1__DownPic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DownPic(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DownPic *p;
	size_t k = sizeof(struct __ns1__DownPic);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__DownPic, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__DownPic);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__DownPic, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DownPic location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DownPic(struct soap *soap, const struct __ns1__DownPic *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DownPic(soap, tag ? tag : "-ns1:DownPic", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownPic * SOAP_FMAC4 soap_get___ns1__DownPic(struct soap *soap, struct __ns1__DownPic *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DownPic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SaveFileData(struct soap *soap, struct __ns1__SaveFileData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SaveFileData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SaveFileData(struct soap *soap, const struct __ns1__SaveFileData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SaveFileData(soap, &a->ns1__SaveFileData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SaveFileData(struct soap *soap, const char *tag, int id, const struct __ns1__SaveFileData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SaveFileData(soap, "ns1:SaveFileData", -1, &a->ns1__SaveFileData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SaveFileData * SOAP_FMAC4 soap_in___ns1__SaveFileData(struct soap *soap, const char *tag, struct __ns1__SaveFileData *a, const char *type)
{
	size_t soap_flag_ns1__SaveFileData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SaveFileData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SaveFileData, sizeof(struct __ns1__SaveFileData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SaveFileData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SaveFileData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SaveFileData(soap, "ns1:SaveFileData", &a->ns1__SaveFileData, ""))
				{	soap_flag_ns1__SaveFileData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SaveFileData * SOAP_FMAC2 soap_instantiate___ns1__SaveFileData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SaveFileData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SaveFileData *p;
	size_t k = sizeof(struct __ns1__SaveFileData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__SaveFileData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__SaveFileData);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__SaveFileData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SaveFileData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SaveFileData(struct soap *soap, const struct __ns1__SaveFileData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SaveFileData(soap, tag ? tag : "-ns1:SaveFileData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SaveFileData * SOAP_FMAC4 soap_get___ns1__SaveFileData(struct soap *soap, struct __ns1__SaveFileData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SaveFileData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SaveData(struct soap *soap, struct __ns1__SaveData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SaveData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SaveData(struct soap *soap, const struct __ns1__SaveData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SaveData(soap, &a->ns1__SaveData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SaveData(struct soap *soap, const char *tag, int id, const struct __ns1__SaveData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SaveData(soap, "ns1:SaveData", -1, &a->ns1__SaveData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SaveData * SOAP_FMAC4 soap_in___ns1__SaveData(struct soap *soap, const char *tag, struct __ns1__SaveData *a, const char *type)
{
	size_t soap_flag_ns1__SaveData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SaveData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SaveData, sizeof(struct __ns1__SaveData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SaveData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SaveData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SaveData(soap, "ns1:SaveData", &a->ns1__SaveData, ""))
				{	soap_flag_ns1__SaveData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SaveData * SOAP_FMAC2 soap_instantiate___ns1__SaveData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SaveData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SaveData *p;
	size_t k = sizeof(struct __ns1__SaveData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__SaveData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__SaveData);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__SaveData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SaveData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SaveData(struct soap *soap, const struct __ns1__SaveData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SaveData(soap, tag ? tag : "-ns1:SaveData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SaveData * SOAP_FMAC4 soap_get___ns1__SaveData(struct soap *soap, struct __ns1__SaveData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SaveData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ExecuteSql(struct soap *soap, struct __ns1__ExecuteSql *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ExecuteSql = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ExecuteSql(struct soap *soap, const struct __ns1__ExecuteSql *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ExecuteSql(soap, &a->ns1__ExecuteSql);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ExecuteSql(struct soap *soap, const char *tag, int id, const struct __ns1__ExecuteSql *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ExecuteSql(soap, "ns1:ExecuteSql", -1, &a->ns1__ExecuteSql, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExecuteSql * SOAP_FMAC4 soap_in___ns1__ExecuteSql(struct soap *soap, const char *tag, struct __ns1__ExecuteSql *a, const char *type)
{
	size_t soap_flag_ns1__ExecuteSql = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ExecuteSql *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ExecuteSql, sizeof(struct __ns1__ExecuteSql), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ExecuteSql(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ExecuteSql && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ExecuteSql(soap, "ns1:ExecuteSql", &a->ns1__ExecuteSql, ""))
				{	soap_flag_ns1__ExecuteSql--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ExecuteSql * SOAP_FMAC2 soap_instantiate___ns1__ExecuteSql(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ExecuteSql(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ExecuteSql *p;
	size_t k = sizeof(struct __ns1__ExecuteSql);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ExecuteSql, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ExecuteSql);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ExecuteSql, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ExecuteSql location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ExecuteSql(struct soap *soap, const struct __ns1__ExecuteSql *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ExecuteSql(soap, tag ? tag : "-ns1:ExecuteSql", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExecuteSql * SOAP_FMAC4 soap_get___ns1__ExecuteSql(struct soap *soap, struct __ns1__ExecuteSql *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ExecuteSql(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QueryDataCount(struct soap *soap, struct __ns1__QueryDataCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QueryDataCount = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QueryDataCount(struct soap *soap, const struct __ns1__QueryDataCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__QueryDataCount(soap, &a->ns1__QueryDataCount);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QueryDataCount(struct soap *soap, const char *tag, int id, const struct __ns1__QueryDataCount *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__QueryDataCount(soap, "ns1:QueryDataCount", -1, &a->ns1__QueryDataCount, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QueryDataCount * SOAP_FMAC4 soap_in___ns1__QueryDataCount(struct soap *soap, const char *tag, struct __ns1__QueryDataCount *a, const char *type)
{
	size_t soap_flag_ns1__QueryDataCount = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QueryDataCount *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__QueryDataCount, sizeof(struct __ns1__QueryDataCount), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QueryDataCount(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QueryDataCount && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__QueryDataCount(soap, "ns1:QueryDataCount", &a->ns1__QueryDataCount, ""))
				{	soap_flag_ns1__QueryDataCount--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QueryDataCount * SOAP_FMAC2 soap_instantiate___ns1__QueryDataCount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QueryDataCount(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QueryDataCount *p;
	size_t k = sizeof(struct __ns1__QueryDataCount);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__QueryDataCount, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__QueryDataCount);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__QueryDataCount, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QueryDataCount location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QueryDataCount(struct soap *soap, const struct __ns1__QueryDataCount *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QueryDataCount(soap, tag ? tag : "-ns1:QueryDataCount", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QueryDataCount * SOAP_FMAC4 soap_get___ns1__QueryDataCount(struct soap *soap, struct __ns1__QueryDataCount *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QueryDataCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__QueryData(struct soap *soap, struct __ns1__QueryData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QueryData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__QueryData(struct soap *soap, const struct __ns1__QueryData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__QueryData(soap, &a->ns1__QueryData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__QueryData(struct soap *soap, const char *tag, int id, const struct __ns1__QueryData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__QueryData(soap, "ns1:QueryData", -1, &a->ns1__QueryData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QueryData * SOAP_FMAC4 soap_in___ns1__QueryData(struct soap *soap, const char *tag, struct __ns1__QueryData *a, const char *type)
{
	size_t soap_flag_ns1__QueryData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__QueryData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__QueryData, sizeof(struct __ns1__QueryData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__QueryData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QueryData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__QueryData(soap, "ns1:QueryData", &a->ns1__QueryData, ""))
				{	soap_flag_ns1__QueryData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__QueryData * SOAP_FMAC2 soap_instantiate___ns1__QueryData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__QueryData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__QueryData *p;
	size_t k = sizeof(struct __ns1__QueryData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__QueryData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__QueryData);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__QueryData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__QueryData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__QueryData(struct soap *soap, const struct __ns1__QueryData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__QueryData(soap, tag ? tag : "-ns1:QueryData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__QueryData * SOAP_FMAC4 soap_get___ns1__QueryData(struct soap *soap, struct __ns1__QueryData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__QueryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDBString(struct soap *soap, struct __ns1__GetDBString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDBString = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDBString(struct soap *soap, const struct __ns1__GetDBString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetDBString(soap, &a->ns1__GetDBString);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDBString(struct soap *soap, const char *tag, int id, const struct __ns1__GetDBString *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetDBString(soap, "ns1:GetDBString", -1, &a->ns1__GetDBString, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDBString * SOAP_FMAC4 soap_in___ns1__GetDBString(struct soap *soap, const char *tag, struct __ns1__GetDBString *a, const char *type)
{
	size_t soap_flag_ns1__GetDBString = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetDBString *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDBString, sizeof(struct __ns1__GetDBString), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDBString(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDBString && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetDBString(soap, "ns1:GetDBString", &a->ns1__GetDBString, ""))
				{	soap_flag_ns1__GetDBString--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetDBString * SOAP_FMAC2 soap_instantiate___ns1__GetDBString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDBString(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetDBString *p;
	size_t k = sizeof(struct __ns1__GetDBString);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetDBString, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetDBString);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetDBString, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetDBString location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDBString(struct soap *soap, const struct __ns1__GetDBString *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetDBString(soap, tag ? tag : "-ns1:GetDBString", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDBString * SOAP_FMAC4 soap_get___ns1__GetDBString(struct soap *soap, struct __ns1__GetDBString *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDBString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__HelloWorld(struct soap *soap, struct __ns1__HelloWorld *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__HelloWorld = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__HelloWorld(struct soap *soap, const struct __ns1__HelloWorld *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__HelloWorld(soap, &a->ns1__HelloWorld);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__HelloWorld(struct soap *soap, const char *tag, int id, const struct __ns1__HelloWorld *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__HelloWorld(soap, "ns1:HelloWorld", -1, &a->ns1__HelloWorld, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__HelloWorld * SOAP_FMAC4 soap_in___ns1__HelloWorld(struct soap *soap, const char *tag, struct __ns1__HelloWorld *a, const char *type)
{
	size_t soap_flag_ns1__HelloWorld = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__HelloWorld *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__HelloWorld, sizeof(struct __ns1__HelloWorld), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__HelloWorld(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__HelloWorld && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__HelloWorld(soap, "ns1:HelloWorld", &a->ns1__HelloWorld, ""))
				{	soap_flag_ns1__HelloWorld--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__HelloWorld * SOAP_FMAC2 soap_instantiate___ns1__HelloWorld(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__HelloWorld(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__HelloWorld *p;
	size_t k = sizeof(struct __ns1__HelloWorld);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__HelloWorld, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__HelloWorld);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__HelloWorld, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__HelloWorld location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__HelloWorld(struct soap *soap, const struct __ns1__HelloWorld *a, const char *tag, const char *type)
{
	if (soap_out___ns1__HelloWorld(soap, tag ? tag : "-ns1:HelloWorld", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__HelloWorld * SOAP_FMAC4 soap_get___ns1__HelloWorld(struct soap *soap, struct __ns1__HelloWorld *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__HelloWorld(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CheckDevCode(struct soap *soap, struct __ns1__CheckDevCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CheckDevCode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CheckDevCode(struct soap *soap, const struct __ns1__CheckDevCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CheckDevCode(soap, &a->ns1__CheckDevCode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CheckDevCode(struct soap *soap, const char *tag, int id, const struct __ns1__CheckDevCode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CheckDevCode(soap, "ns1:CheckDevCode", -1, &a->ns1__CheckDevCode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckDevCode * SOAP_FMAC4 soap_in___ns1__CheckDevCode(struct soap *soap, const char *tag, struct __ns1__CheckDevCode *a, const char *type)
{
	size_t soap_flag_ns1__CheckDevCode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CheckDevCode *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CheckDevCode, sizeof(struct __ns1__CheckDevCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CheckDevCode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CheckDevCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CheckDevCode(soap, "ns1:CheckDevCode", &a->ns1__CheckDevCode, ""))
				{	soap_flag_ns1__CheckDevCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CheckDevCode * SOAP_FMAC2 soap_instantiate___ns1__CheckDevCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CheckDevCode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CheckDevCode *p;
	size_t k = sizeof(struct __ns1__CheckDevCode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__CheckDevCode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__CheckDevCode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__CheckDevCode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CheckDevCode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CheckDevCode(struct soap *soap, const struct __ns1__CheckDevCode *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CheckDevCode(soap, tag ? tag : "-ns1:CheckDevCode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckDevCode * SOAP_FMAC4 soap_get___ns1__CheckDevCode(struct soap *soap, struct __ns1__CheckDevCode *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CheckDevCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDevCode(struct soap *soap, struct __ns1__GetDevCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDevCode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDevCode(struct soap *soap, const struct __ns1__GetDevCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetDevCode(soap, &a->ns1__GetDevCode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDevCode(struct soap *soap, const char *tag, int id, const struct __ns1__GetDevCode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetDevCode(soap, "ns1:GetDevCode", -1, &a->ns1__GetDevCode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDevCode * SOAP_FMAC4 soap_in___ns1__GetDevCode(struct soap *soap, const char *tag, struct __ns1__GetDevCode *a, const char *type)
{
	size_t soap_flag_ns1__GetDevCode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetDevCode *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDevCode, sizeof(struct __ns1__GetDevCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDevCode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDevCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetDevCode(soap, "ns1:GetDevCode", &a->ns1__GetDevCode, ""))
				{	soap_flag_ns1__GetDevCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetDevCode * SOAP_FMAC2 soap_instantiate___ns1__GetDevCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDevCode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetDevCode *p;
	size_t k = sizeof(struct __ns1__GetDevCode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetDevCode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetDevCode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetDevCode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetDevCode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDevCode(struct soap *soap, const struct __ns1__GetDevCode *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetDevCode(soap, tag ? tag : "-ns1:GetDevCode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDevCode * SOAP_FMAC4 soap_get___ns1__GetDevCode(struct soap *soap, struct __ns1__GetDevCode *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDevCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetRyUnit(struct soap *soap, struct __ns1__GetRyUnit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetRyUnit = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetRyUnit(struct soap *soap, const struct __ns1__GetRyUnit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetRyUnit(soap, &a->ns1__GetRyUnit);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetRyUnit(struct soap *soap, const char *tag, int id, const struct __ns1__GetRyUnit *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetRyUnit(soap, "ns1:GetRyUnit", -1, &a->ns1__GetRyUnit, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRyUnit * SOAP_FMAC4 soap_in___ns1__GetRyUnit(struct soap *soap, const char *tag, struct __ns1__GetRyUnit *a, const char *type)
{
	size_t soap_flag_ns1__GetRyUnit = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetRyUnit *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetRyUnit, sizeof(struct __ns1__GetRyUnit), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetRyUnit(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetRyUnit && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetRyUnit(soap, "ns1:GetRyUnit", &a->ns1__GetRyUnit, ""))
				{	soap_flag_ns1__GetRyUnit--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetRyUnit * SOAP_FMAC2 soap_instantiate___ns1__GetRyUnit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetRyUnit(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetRyUnit *p;
	size_t k = sizeof(struct __ns1__GetRyUnit);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetRyUnit, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetRyUnit);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetRyUnit, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetRyUnit location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetRyUnit(struct soap *soap, const struct __ns1__GetRyUnit *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetRyUnit(soap, tag ? tag : "-ns1:GetRyUnit", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRyUnit * SOAP_FMAC4 soap_get___ns1__GetRyUnit(struct soap *soap, struct __ns1__GetRyUnit *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetRyUnit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CheckLoginUser(struct soap *soap, struct __ns1__CheckLoginUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CheckLoginUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CheckLoginUser(struct soap *soap, const struct __ns1__CheckLoginUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CheckLoginUser(soap, &a->ns1__CheckLoginUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CheckLoginUser(struct soap *soap, const char *tag, int id, const struct __ns1__CheckLoginUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CheckLoginUser(soap, "ns1:CheckLoginUser", -1, &a->ns1__CheckLoginUser, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckLoginUser * SOAP_FMAC4 soap_in___ns1__CheckLoginUser(struct soap *soap, const char *tag, struct __ns1__CheckLoginUser *a, const char *type)
{
	size_t soap_flag_ns1__CheckLoginUser = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CheckLoginUser *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CheckLoginUser, sizeof(struct __ns1__CheckLoginUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CheckLoginUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CheckLoginUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CheckLoginUser(soap, "ns1:CheckLoginUser", &a->ns1__CheckLoginUser, ""))
				{	soap_flag_ns1__CheckLoginUser--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CheckLoginUser * SOAP_FMAC2 soap_instantiate___ns1__CheckLoginUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CheckLoginUser(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CheckLoginUser *p;
	size_t k = sizeof(struct __ns1__CheckLoginUser);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__CheckLoginUser, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__CheckLoginUser);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__CheckLoginUser, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CheckLoginUser location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CheckLoginUser(struct soap *soap, const struct __ns1__CheckLoginUser *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CheckLoginUser(soap, tag ? tag : "-ns1:CheckLoginUser", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckLoginUser * SOAP_FMAC4 soap_get___ns1__CheckLoginUser(struct soap *soap, struct __ns1__CheckLoginUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CheckLoginUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetPropName(struct soap *soap, struct __ns1__GetPropName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPropName = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetPropName(struct soap *soap, const struct __ns1__GetPropName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetPropName(soap, &a->ns1__GetPropName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetPropName(struct soap *soap, const char *tag, int id, const struct __ns1__GetPropName *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetPropName(soap, "ns1:GetPropName", -1, &a->ns1__GetPropName, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPropName * SOAP_FMAC4 soap_in___ns1__GetPropName(struct soap *soap, const char *tag, struct __ns1__GetPropName *a, const char *type)
{
	size_t soap_flag_ns1__GetPropName = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetPropName *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetPropName, sizeof(struct __ns1__GetPropName), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetPropName(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPropName && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetPropName(soap, "ns1:GetPropName", &a->ns1__GetPropName, ""))
				{	soap_flag_ns1__GetPropName--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetPropName * SOAP_FMAC2 soap_instantiate___ns1__GetPropName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetPropName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetPropName *p;
	size_t k = sizeof(struct __ns1__GetPropName);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetPropName, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetPropName);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetPropName, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetPropName location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetPropName(struct soap *soap, const struct __ns1__GetPropName *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetPropName(soap, tag ? tag : "-ns1:GetPropName", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPropName * SOAP_FMAC4 soap_get___ns1__GetPropName(struct soap *soap, struct __ns1__GetPropName *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetPropName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetPropList(struct soap *soap, struct __ns1__GetPropList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPropList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetPropList(struct soap *soap, const struct __ns1__GetPropList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetPropList(soap, &a->ns1__GetPropList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetPropList(struct soap *soap, const char *tag, int id, const struct __ns1__GetPropList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetPropList(soap, "ns1:GetPropList", -1, &a->ns1__GetPropList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPropList * SOAP_FMAC4 soap_in___ns1__GetPropList(struct soap *soap, const char *tag, struct __ns1__GetPropList *a, const char *type)
{
	size_t soap_flag_ns1__GetPropList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetPropList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetPropList, sizeof(struct __ns1__GetPropList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetPropList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPropList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetPropList(soap, "ns1:GetPropList", &a->ns1__GetPropList, ""))
				{	soap_flag_ns1__GetPropList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetPropList * SOAP_FMAC2 soap_instantiate___ns1__GetPropList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetPropList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetPropList *p;
	size_t k = sizeof(struct __ns1__GetPropList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetPropList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetPropList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetPropList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetPropList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetPropList(struct soap *soap, const struct __ns1__GetPropList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetPropList(soap, tag ? tag : "-ns1:GetPropList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPropList * SOAP_FMAC4 soap_get___ns1__GetPropList(struct soap *soap, struct __ns1__GetPropList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetPropList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetYjzhZskDevFlowChartList(struct soap *soap, struct __ns1__GetYjzhZskDevFlowChartList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetYjzhZskDevFlowChartList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetYjzhZskDevFlowChartList(struct soap *soap, const struct __ns1__GetYjzhZskDevFlowChartList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetYjzhZskDevFlowChartList(soap, &a->ns1__GetYjzhZskDevFlowChartList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetYjzhZskDevFlowChartList(struct soap *soap, const char *tag, int id, const struct __ns1__GetYjzhZskDevFlowChartList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetYjzhZskDevFlowChartList(soap, "ns1:GetYjzhZskDevFlowChartList", -1, &a->ns1__GetYjzhZskDevFlowChartList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetYjzhZskDevFlowChartList * SOAP_FMAC4 soap_in___ns1__GetYjzhZskDevFlowChartList(struct soap *soap, const char *tag, struct __ns1__GetYjzhZskDevFlowChartList *a, const char *type)
{
	size_t soap_flag_ns1__GetYjzhZskDevFlowChartList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetYjzhZskDevFlowChartList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetYjzhZskDevFlowChartList, sizeof(struct __ns1__GetYjzhZskDevFlowChartList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetYjzhZskDevFlowChartList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetYjzhZskDevFlowChartList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetYjzhZskDevFlowChartList(soap, "ns1:GetYjzhZskDevFlowChartList", &a->ns1__GetYjzhZskDevFlowChartList, ""))
				{	soap_flag_ns1__GetYjzhZskDevFlowChartList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetYjzhZskDevFlowChartList * SOAP_FMAC2 soap_instantiate___ns1__GetYjzhZskDevFlowChartList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetYjzhZskDevFlowChartList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetYjzhZskDevFlowChartList *p;
	size_t k = sizeof(struct __ns1__GetYjzhZskDevFlowChartList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetYjzhZskDevFlowChartList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetYjzhZskDevFlowChartList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetYjzhZskDevFlowChartList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetYjzhZskDevFlowChartList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetYjzhZskDevFlowChartList(struct soap *soap, const struct __ns1__GetYjzhZskDevFlowChartList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetYjzhZskDevFlowChartList(soap, tag ? tag : "-ns1:GetYjzhZskDevFlowChartList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetYjzhZskDevFlowChartList * SOAP_FMAC4 soap_get___ns1__GetYjzhZskDevFlowChartList(struct soap *soap, struct __ns1__GetYjzhZskDevFlowChartList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetYjzhZskDevFlowChartList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetYjzhZskOtherFlowChartList(struct soap *soap, struct __ns1__GetYjzhZskOtherFlowChartList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetYjzhZskOtherFlowChartList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetYjzhZskOtherFlowChartList(struct soap *soap, const struct __ns1__GetYjzhZskOtherFlowChartList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetYjzhZskOtherFlowChartList(soap, &a->ns1__GetYjzhZskOtherFlowChartList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetYjzhZskOtherFlowChartList(struct soap *soap, const char *tag, int id, const struct __ns1__GetYjzhZskOtherFlowChartList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetYjzhZskOtherFlowChartList(soap, "ns1:GetYjzhZskOtherFlowChartList", -1, &a->ns1__GetYjzhZskOtherFlowChartList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetYjzhZskOtherFlowChartList * SOAP_FMAC4 soap_in___ns1__GetYjzhZskOtherFlowChartList(struct soap *soap, const char *tag, struct __ns1__GetYjzhZskOtherFlowChartList *a, const char *type)
{
	size_t soap_flag_ns1__GetYjzhZskOtherFlowChartList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetYjzhZskOtherFlowChartList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetYjzhZskOtherFlowChartList, sizeof(struct __ns1__GetYjzhZskOtherFlowChartList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetYjzhZskOtherFlowChartList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetYjzhZskOtherFlowChartList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetYjzhZskOtherFlowChartList(soap, "ns1:GetYjzhZskOtherFlowChartList", &a->ns1__GetYjzhZskOtherFlowChartList, ""))
				{	soap_flag_ns1__GetYjzhZskOtherFlowChartList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetYjzhZskOtherFlowChartList * SOAP_FMAC2 soap_instantiate___ns1__GetYjzhZskOtherFlowChartList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetYjzhZskOtherFlowChartList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetYjzhZskOtherFlowChartList *p;
	size_t k = sizeof(struct __ns1__GetYjzhZskOtherFlowChartList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetYjzhZskOtherFlowChartList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetYjzhZskOtherFlowChartList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetYjzhZskOtherFlowChartList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetYjzhZskOtherFlowChartList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetYjzhZskOtherFlowChartList(struct soap *soap, const struct __ns1__GetYjzhZskOtherFlowChartList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetYjzhZskOtherFlowChartList(soap, tag ? tag : "-ns1:GetYjzhZskOtherFlowChartList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetYjzhZskOtherFlowChartList * SOAP_FMAC4 soap_get___ns1__GetYjzhZskOtherFlowChartList(struct soap *soap, struct __ns1__GetYjzhZskOtherFlowChartList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetYjzhZskOtherFlowChartList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetYjzhZskGzFlow(struct soap *soap, struct __ns1__GetYjzhZskGzFlow *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetYjzhZskGzFlow = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetYjzhZskGzFlow(struct soap *soap, const struct __ns1__GetYjzhZskGzFlow *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetYjzhZskGzFlow(soap, &a->ns1__GetYjzhZskGzFlow);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetYjzhZskGzFlow(struct soap *soap, const char *tag, int id, const struct __ns1__GetYjzhZskGzFlow *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetYjzhZskGzFlow(soap, "ns1:GetYjzhZskGzFlow", -1, &a->ns1__GetYjzhZskGzFlow, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetYjzhZskGzFlow * SOAP_FMAC4 soap_in___ns1__GetYjzhZskGzFlow(struct soap *soap, const char *tag, struct __ns1__GetYjzhZskGzFlow *a, const char *type)
{
	size_t soap_flag_ns1__GetYjzhZskGzFlow = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetYjzhZskGzFlow *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetYjzhZskGzFlow, sizeof(struct __ns1__GetYjzhZskGzFlow), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetYjzhZskGzFlow(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetYjzhZskGzFlow && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetYjzhZskGzFlow(soap, "ns1:GetYjzhZskGzFlow", &a->ns1__GetYjzhZskGzFlow, ""))
				{	soap_flag_ns1__GetYjzhZskGzFlow--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetYjzhZskGzFlow * SOAP_FMAC2 soap_instantiate___ns1__GetYjzhZskGzFlow(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetYjzhZskGzFlow(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetYjzhZskGzFlow *p;
	size_t k = sizeof(struct __ns1__GetYjzhZskGzFlow);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetYjzhZskGzFlow, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetYjzhZskGzFlow);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetYjzhZskGzFlow, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetYjzhZskGzFlow location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetYjzhZskGzFlow(struct soap *soap, const struct __ns1__GetYjzhZskGzFlow *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetYjzhZskGzFlow(soap, tag ? tag : "-ns1:GetYjzhZskGzFlow", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetYjzhZskGzFlow * SOAP_FMAC4 soap_get___ns1__GetYjzhZskGzFlow(struct soap *soap, struct __ns1__GetYjzhZskGzFlow *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetYjzhZskGzFlow(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetYjzhZskAlarmTypes(struct soap *soap, _ns1__GetYjzhZskAlarmTypes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetYjzhZskAlarmTypes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetYjzhZskAlarmTypes(struct soap *soap, const char *tag, int id, _ns1__GetYjzhZskAlarmTypes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetYjzhZskAlarmTypes, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetYjzhZskAlarmTypes ? type : NULL);
}

SOAP_FMAC3 _ns1__GetYjzhZskAlarmTypes ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetYjzhZskAlarmTypes(struct soap *soap, const char *tag, _ns1__GetYjzhZskAlarmTypes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetYjzhZskAlarmTypes **)soap_malloc(soap, sizeof(_ns1__GetYjzhZskAlarmTypes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetYjzhZskAlarmTypes *)soap_instantiate__ns1__GetYjzhZskAlarmTypes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetYjzhZskAlarmTypes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetYjzhZskAlarmTypes, sizeof(_ns1__GetYjzhZskAlarmTypes), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetYjzhZskAlarmTypes(struct soap *soap, _ns1__GetYjzhZskAlarmTypes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetYjzhZskAlarmTypes(soap, tag ? tag : "ns1:GetYjzhZskAlarmTypes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetYjzhZskAlarmTypes ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetYjzhZskAlarmTypes(struct soap *soap, _ns1__GetYjzhZskAlarmTypes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetYjzhZskAlarmTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SelectYjzhDevice(struct soap *soap, _ns1__SelectYjzhDevice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SelectYjzhDevice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SelectYjzhDevice(struct soap *soap, const char *tag, int id, _ns1__SelectYjzhDevice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SelectYjzhDevice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SelectYjzhDevice ? type : NULL);
}

SOAP_FMAC3 _ns1__SelectYjzhDevice ** SOAP_FMAC4 soap_in_PointerTo_ns1__SelectYjzhDevice(struct soap *soap, const char *tag, _ns1__SelectYjzhDevice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SelectYjzhDevice **)soap_malloc(soap, sizeof(_ns1__SelectYjzhDevice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SelectYjzhDevice *)soap_instantiate__ns1__SelectYjzhDevice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SelectYjzhDevice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SelectYjzhDevice, sizeof(_ns1__SelectYjzhDevice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SelectYjzhDevice(struct soap *soap, _ns1__SelectYjzhDevice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SelectYjzhDevice(soap, tag ? tag : "ns1:SelectYjzhDevice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SelectYjzhDevice ** SOAP_FMAC4 soap_get_PointerTo_ns1__SelectYjzhDevice(struct soap *soap, _ns1__SelectYjzhDevice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SelectYjzhDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SelectYjzhStation(struct soap *soap, _ns1__SelectYjzhStation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SelectYjzhStation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SelectYjzhStation(struct soap *soap, const char *tag, int id, _ns1__SelectYjzhStation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SelectYjzhStation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SelectYjzhStation ? type : NULL);
}

SOAP_FMAC3 _ns1__SelectYjzhStation ** SOAP_FMAC4 soap_in_PointerTo_ns1__SelectYjzhStation(struct soap *soap, const char *tag, _ns1__SelectYjzhStation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SelectYjzhStation **)soap_malloc(soap, sizeof(_ns1__SelectYjzhStation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SelectYjzhStation *)soap_instantiate__ns1__SelectYjzhStation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SelectYjzhStation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SelectYjzhStation, sizeof(_ns1__SelectYjzhStation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SelectYjzhStation(struct soap *soap, _ns1__SelectYjzhStation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SelectYjzhStation(soap, tag ? tag : "ns1:SelectYjzhStation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SelectYjzhStation ** SOAP_FMAC4 soap_get_PointerTo_ns1__SelectYjzhStation(struct soap *soap, _ns1__SelectYjzhStation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SelectYjzhStation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SaveMapFile(struct soap *soap, _ns1__SaveMapFile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SaveMapFile))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SaveMapFile(struct soap *soap, const char *tag, int id, _ns1__SaveMapFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SaveMapFile, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SaveMapFile ? type : NULL);
}

SOAP_FMAC3 _ns1__SaveMapFile ** SOAP_FMAC4 soap_in_PointerTo_ns1__SaveMapFile(struct soap *soap, const char *tag, _ns1__SaveMapFile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SaveMapFile **)soap_malloc(soap, sizeof(_ns1__SaveMapFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SaveMapFile *)soap_instantiate__ns1__SaveMapFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SaveMapFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SaveMapFile, sizeof(_ns1__SaveMapFile), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SaveMapFile(struct soap *soap, _ns1__SaveMapFile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SaveMapFile(soap, tag ? tag : "ns1:SaveMapFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SaveMapFile ** SOAP_FMAC4 soap_get_PointerTo_ns1__SaveMapFile(struct soap *soap, _ns1__SaveMapFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SaveMapFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GzGetDeviceStruct(struct soap *soap, _ns1__GzGetDeviceStruct *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GzGetDeviceStruct))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GzGetDeviceStruct(struct soap *soap, const char *tag, int id, _ns1__GzGetDeviceStruct *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GzGetDeviceStruct, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GzGetDeviceStruct ? type : NULL);
}

SOAP_FMAC3 _ns1__GzGetDeviceStruct ** SOAP_FMAC4 soap_in_PointerTo_ns1__GzGetDeviceStruct(struct soap *soap, const char *tag, _ns1__GzGetDeviceStruct **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GzGetDeviceStruct **)soap_malloc(soap, sizeof(_ns1__GzGetDeviceStruct *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GzGetDeviceStruct *)soap_instantiate__ns1__GzGetDeviceStruct(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GzGetDeviceStruct **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GzGetDeviceStruct, sizeof(_ns1__GzGetDeviceStruct), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GzGetDeviceStruct(struct soap *soap, _ns1__GzGetDeviceStruct *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GzGetDeviceStruct(soap, tag ? tag : "ns1:GzGetDeviceStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GzGetDeviceStruct ** SOAP_FMAC4 soap_get_PointerTo_ns1__GzGetDeviceStruct(struct soap *soap, _ns1__GzGetDeviceStruct **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GzGetDeviceStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GzGetTypeList(struct soap *soap, _ns1__GzGetTypeList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GzGetTypeList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GzGetTypeList(struct soap *soap, const char *tag, int id, _ns1__GzGetTypeList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GzGetTypeList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GzGetTypeList ? type : NULL);
}

SOAP_FMAC3 _ns1__GzGetTypeList ** SOAP_FMAC4 soap_in_PointerTo_ns1__GzGetTypeList(struct soap *soap, const char *tag, _ns1__GzGetTypeList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GzGetTypeList **)soap_malloc(soap, sizeof(_ns1__GzGetTypeList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GzGetTypeList *)soap_instantiate__ns1__GzGetTypeList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GzGetTypeList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GzGetTypeList, sizeof(_ns1__GzGetTypeList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GzGetTypeList(struct soap *soap, _ns1__GzGetTypeList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GzGetTypeList(soap, tag ? tag : "ns1:GzGetTypeList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GzGetTypeList ** SOAP_FMAC4 soap_get_PointerTo_ns1__GzGetTypeList(struct soap *soap, _ns1__GzGetTypeList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GzGetTypeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SGCDrawEmf(struct soap *soap, _ns1__SGCDrawEmf *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SGCDrawEmf))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SGCDrawEmf(struct soap *soap, const char *tag, int id, _ns1__SGCDrawEmf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SGCDrawEmf, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SGCDrawEmf ? type : NULL);
}

SOAP_FMAC3 _ns1__SGCDrawEmf ** SOAP_FMAC4 soap_in_PointerTo_ns1__SGCDrawEmf(struct soap *soap, const char *tag, _ns1__SGCDrawEmf **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SGCDrawEmf **)soap_malloc(soap, sizeof(_ns1__SGCDrawEmf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SGCDrawEmf *)soap_instantiate__ns1__SGCDrawEmf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SGCDrawEmf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SGCDrawEmf, sizeof(_ns1__SGCDrawEmf), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SGCDrawEmf(struct soap *soap, _ns1__SGCDrawEmf *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SGCDrawEmf(soap, tag ? tag : "ns1:SGCDrawEmf", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SGCDrawEmf ** SOAP_FMAC4 soap_get_PointerTo_ns1__SGCDrawEmf(struct soap *soap, _ns1__SGCDrawEmf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SGCDrawEmf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__FlowChartEmf(struct soap *soap, _ns1__FlowChartEmf *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__FlowChartEmf))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__FlowChartEmf(struct soap *soap, const char *tag, int id, _ns1__FlowChartEmf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__FlowChartEmf, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__FlowChartEmf ? type : NULL);
}

SOAP_FMAC3 _ns1__FlowChartEmf ** SOAP_FMAC4 soap_in_PointerTo_ns1__FlowChartEmf(struct soap *soap, const char *tag, _ns1__FlowChartEmf **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__FlowChartEmf **)soap_malloc(soap, sizeof(_ns1__FlowChartEmf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__FlowChartEmf *)soap_instantiate__ns1__FlowChartEmf(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__FlowChartEmf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__FlowChartEmf, sizeof(_ns1__FlowChartEmf), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__FlowChartEmf(struct soap *soap, _ns1__FlowChartEmf *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__FlowChartEmf(soap, tag ? tag : "ns1:FlowChartEmf", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__FlowChartEmf ** SOAP_FMAC4 soap_get_PointerTo_ns1__FlowChartEmf(struct soap *soap, _ns1__FlowChartEmf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__FlowChartEmf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetZhouQi(struct soap *soap, _ns1__GetZhouQi *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetZhouQi))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetZhouQi(struct soap *soap, const char *tag, int id, _ns1__GetZhouQi *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetZhouQi, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetZhouQi ? type : NULL);
}

SOAP_FMAC3 _ns1__GetZhouQi ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetZhouQi(struct soap *soap, const char *tag, _ns1__GetZhouQi **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetZhouQi **)soap_malloc(soap, sizeof(_ns1__GetZhouQi *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetZhouQi *)soap_instantiate__ns1__GetZhouQi(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetZhouQi **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetZhouQi, sizeof(_ns1__GetZhouQi), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetZhouQi(struct soap *soap, _ns1__GetZhouQi *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetZhouQi(soap, tag ? tag : "ns1:GetZhouQi", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetZhouQi ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetZhouQi(struct soap *soap, _ns1__GetZhouQi **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetZhouQi(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__JiChaoQi(struct soap *soap, _ns1__JiChaoQi *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__JiChaoQi))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__JiChaoQi(struct soap *soap, const char *tag, int id, _ns1__JiChaoQi *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__JiChaoQi, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__JiChaoQi ? type : NULL);
}

SOAP_FMAC3 _ns1__JiChaoQi ** SOAP_FMAC4 soap_in_PointerTo_ns1__JiChaoQi(struct soap *soap, const char *tag, _ns1__JiChaoQi **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__JiChaoQi **)soap_malloc(soap, sizeof(_ns1__JiChaoQi *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__JiChaoQi *)soap_instantiate__ns1__JiChaoQi(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__JiChaoQi **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__JiChaoQi, sizeof(_ns1__JiChaoQi), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__JiChaoQi(struct soap *soap, _ns1__JiChaoQi *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__JiChaoQi(soap, tag ? tag : "ns1:JiChaoQi", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__JiChaoQi ** SOAP_FMAC4 soap_get_PointerTo_ns1__JiChaoQi(struct soap *soap, _ns1__JiChaoQi **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__JiChaoQi(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ChaoQi(struct soap *soap, _ns1__ChaoQi *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ChaoQi))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ChaoQi(struct soap *soap, const char *tag, int id, _ns1__ChaoQi *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ChaoQi, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__ChaoQi ? type : NULL);
}

SOAP_FMAC3 _ns1__ChaoQi ** SOAP_FMAC4 soap_in_PointerTo_ns1__ChaoQi(struct soap *soap, const char *tag, _ns1__ChaoQi **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ChaoQi **)soap_malloc(soap, sizeof(_ns1__ChaoQi *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ChaoQi *)soap_instantiate__ns1__ChaoQi(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ChaoQi **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ChaoQi, sizeof(_ns1__ChaoQi), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ChaoQi(struct soap *soap, _ns1__ChaoQi *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ChaoQi(soap, tag ? tag : "ns1:ChaoQi", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ChaoQi ** SOAP_FMAC4 soap_get_PointerTo_ns1__ChaoQi(struct soap *soap, _ns1__ChaoQi **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ChaoQi(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__OpenMapExe(struct soap *soap, _ns1__OpenMapExe *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__OpenMapExe))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__OpenMapExe(struct soap *soap, const char *tag, int id, _ns1__OpenMapExe *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__OpenMapExe, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__OpenMapExe ? type : NULL);
}

SOAP_FMAC3 _ns1__OpenMapExe ** SOAP_FMAC4 soap_in_PointerTo_ns1__OpenMapExe(struct soap *soap, const char *tag, _ns1__OpenMapExe **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__OpenMapExe **)soap_malloc(soap, sizeof(_ns1__OpenMapExe *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__OpenMapExe *)soap_instantiate__ns1__OpenMapExe(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__OpenMapExe **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__OpenMapExe, sizeof(_ns1__OpenMapExe), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__OpenMapExe(struct soap *soap, _ns1__OpenMapExe *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__OpenMapExe(soap, tag ? tag : "ns1:OpenMapExe", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__OpenMapExe ** SOAP_FMAC4 soap_get_PointerTo_ns1__OpenMapExe(struct soap *soap, _ns1__OpenMapExe **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__OpenMapExe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetEmfPngFile(struct soap *soap, _ns1__GetEmfPngFile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetEmfPngFile))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetEmfPngFile(struct soap *soap, const char *tag, int id, _ns1__GetEmfPngFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetEmfPngFile, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetEmfPngFile ? type : NULL);
}

SOAP_FMAC3 _ns1__GetEmfPngFile ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetEmfPngFile(struct soap *soap, const char *tag, _ns1__GetEmfPngFile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetEmfPngFile **)soap_malloc(soap, sizeof(_ns1__GetEmfPngFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetEmfPngFile *)soap_instantiate__ns1__GetEmfPngFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetEmfPngFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetEmfPngFile, sizeof(_ns1__GetEmfPngFile), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetEmfPngFile(struct soap *soap, _ns1__GetEmfPngFile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetEmfPngFile(soap, tag ? tag : "ns1:GetEmfPngFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetEmfPngFile ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetEmfPngFile(struct soap *soap, _ns1__GetEmfPngFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetEmfPngFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetEmfPngVer(struct soap *soap, _ns1__GetEmfPngVer *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetEmfPngVer))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetEmfPngVer(struct soap *soap, const char *tag, int id, _ns1__GetEmfPngVer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetEmfPngVer, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetEmfPngVer ? type : NULL);
}

SOAP_FMAC3 _ns1__GetEmfPngVer ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetEmfPngVer(struct soap *soap, const char *tag, _ns1__GetEmfPngVer **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetEmfPngVer **)soap_malloc(soap, sizeof(_ns1__GetEmfPngVer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetEmfPngVer *)soap_instantiate__ns1__GetEmfPngVer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetEmfPngVer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetEmfPngVer, sizeof(_ns1__GetEmfPngVer), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetEmfPngVer(struct soap *soap, _ns1__GetEmfPngVer *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetEmfPngVer(soap, tag ? tag : "ns1:GetEmfPngVer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetEmfPngVer ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetEmfPngVer(struct soap *soap, _ns1__GetEmfPngVer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetEmfPngVer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__OpenProcess(struct soap *soap, _ns1__OpenProcess *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__OpenProcess))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__OpenProcess(struct soap *soap, const char *tag, int id, _ns1__OpenProcess *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__OpenProcess, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__OpenProcess ? type : NULL);
}

SOAP_FMAC3 _ns1__OpenProcess ** SOAP_FMAC4 soap_in_PointerTo_ns1__OpenProcess(struct soap *soap, const char *tag, _ns1__OpenProcess **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__OpenProcess **)soap_malloc(soap, sizeof(_ns1__OpenProcess *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__OpenProcess *)soap_instantiate__ns1__OpenProcess(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__OpenProcess **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__OpenProcess, sizeof(_ns1__OpenProcess), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__OpenProcess(struct soap *soap, _ns1__OpenProcess *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__OpenProcess(soap, tag ? tag : "ns1:OpenProcess", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__OpenProcess ** SOAP_FMAC4 soap_get_PointerTo_ns1__OpenProcess(struct soap *soap, _ns1__OpenProcess **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__OpenProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetMangeMapUpdate(struct soap *soap, _ns1__GetMangeMapUpdate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetMangeMapUpdate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetMangeMapUpdate(struct soap *soap, const char *tag, int id, _ns1__GetMangeMapUpdate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetMangeMapUpdate, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetMangeMapUpdate ? type : NULL);
}

SOAP_FMAC3 _ns1__GetMangeMapUpdate ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetMangeMapUpdate(struct soap *soap, const char *tag, _ns1__GetMangeMapUpdate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetMangeMapUpdate **)soap_malloc(soap, sizeof(_ns1__GetMangeMapUpdate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetMangeMapUpdate *)soap_instantiate__ns1__GetMangeMapUpdate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetMangeMapUpdate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetMangeMapUpdate, sizeof(_ns1__GetMangeMapUpdate), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetMangeMapUpdate(struct soap *soap, _ns1__GetMangeMapUpdate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetMangeMapUpdate(soap, tag ? tag : "ns1:GetMangeMapUpdate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetMangeMapUpdate ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetMangeMapUpdate(struct soap *soap, _ns1__GetMangeMapUpdate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetMangeMapUpdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetUnitMapVer(struct soap *soap, _ns1__GetUnitMapVer *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetUnitMapVer))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetUnitMapVer(struct soap *soap, const char *tag, int id, _ns1__GetUnitMapVer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetUnitMapVer, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetUnitMapVer ? type : NULL);
}

SOAP_FMAC3 _ns1__GetUnitMapVer ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetUnitMapVer(struct soap *soap, const char *tag, _ns1__GetUnitMapVer **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetUnitMapVer **)soap_malloc(soap, sizeof(_ns1__GetUnitMapVer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetUnitMapVer *)soap_instantiate__ns1__GetUnitMapVer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetUnitMapVer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetUnitMapVer, sizeof(_ns1__GetUnitMapVer), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetUnitMapVer(struct soap *soap, _ns1__GetUnitMapVer *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetUnitMapVer(soap, tag ? tag : "ns1:GetUnitMapVer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetUnitMapVer ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetUnitMapVer(struct soap *soap, _ns1__GetUnitMapVer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetUnitMapVer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdateGzclMap(struct soap *soap, _ns1__UpdateGzclMap *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdateGzclMap))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdateGzclMap(struct soap *soap, const char *tag, int id, _ns1__UpdateGzclMap *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdateGzclMap, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__UpdateGzclMap ? type : NULL);
}

SOAP_FMAC3 _ns1__UpdateGzclMap ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdateGzclMap(struct soap *soap, const char *tag, _ns1__UpdateGzclMap **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdateGzclMap **)soap_malloc(soap, sizeof(_ns1__UpdateGzclMap *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdateGzclMap *)soap_instantiate__ns1__UpdateGzclMap(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__UpdateGzclMap **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdateGzclMap, sizeof(_ns1__UpdateGzclMap), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdateGzclMap(struct soap *soap, _ns1__UpdateGzclMap *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__UpdateGzclMap(soap, tag ? tag : "ns1:UpdateGzclMap", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdateGzclMap ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdateGzclMap(struct soap *soap, _ns1__UpdateGzclMap **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdateGzclMap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetMapListTime(struct soap *soap, _ns1__GetMapListTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetMapListTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetMapListTime(struct soap *soap, const char *tag, int id, _ns1__GetMapListTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetMapListTime, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetMapListTime ? type : NULL);
}

SOAP_FMAC3 _ns1__GetMapListTime ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetMapListTime(struct soap *soap, const char *tag, _ns1__GetMapListTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetMapListTime **)soap_malloc(soap, sizeof(_ns1__GetMapListTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetMapListTime *)soap_instantiate__ns1__GetMapListTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetMapListTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetMapListTime, sizeof(_ns1__GetMapListTime), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetMapListTime(struct soap *soap, _ns1__GetMapListTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetMapListTime(soap, tag ? tag : "ns1:GetMapListTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetMapListTime ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetMapListTime(struct soap *soap, _ns1__GetMapListTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetMapListTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ServerLevel(struct soap *soap, _ns1__ServerLevel *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ServerLevel))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ServerLevel(struct soap *soap, const char *tag, int id, _ns1__ServerLevel *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ServerLevel, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__ServerLevel ? type : NULL);
}

SOAP_FMAC3 _ns1__ServerLevel ** SOAP_FMAC4 soap_in_PointerTo_ns1__ServerLevel(struct soap *soap, const char *tag, _ns1__ServerLevel **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ServerLevel **)soap_malloc(soap, sizeof(_ns1__ServerLevel *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ServerLevel *)soap_instantiate__ns1__ServerLevel(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ServerLevel **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ServerLevel, sizeof(_ns1__ServerLevel), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ServerLevel(struct soap *soap, _ns1__ServerLevel *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ServerLevel(soap, tag ? tag : "ns1:ServerLevel", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ServerLevel ** SOAP_FMAC4 soap_get_PointerTo_ns1__ServerLevel(struct soap *soap, _ns1__ServerLevel **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ServerLevel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetTableData(struct soap *soap, _ns1__GetTableData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetTableData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetTableData(struct soap *soap, const char *tag, int id, _ns1__GetTableData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetTableData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetTableData ? type : NULL);
}

SOAP_FMAC3 _ns1__GetTableData ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetTableData(struct soap *soap, const char *tag, _ns1__GetTableData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetTableData **)soap_malloc(soap, sizeof(_ns1__GetTableData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetTableData *)soap_instantiate__ns1__GetTableData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetTableData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetTableData, sizeof(_ns1__GetTableData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetTableData(struct soap *soap, _ns1__GetTableData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetTableData(soap, tag ? tag : "ns1:GetTableData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetTableData ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetTableData(struct soap *soap, _ns1__GetTableData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetTableData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetMap(struct soap *soap, _ns1__GetMap *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetMap))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetMap(struct soap *soap, const char *tag, int id, _ns1__GetMap *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetMap, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetMap ? type : NULL);
}

SOAP_FMAC3 _ns1__GetMap ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetMap(struct soap *soap, const char *tag, _ns1__GetMap **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetMap **)soap_malloc(soap, sizeof(_ns1__GetMap *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetMap *)soap_instantiate__ns1__GetMap(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetMap **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetMap, sizeof(_ns1__GetMap), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetMap(struct soap *soap, _ns1__GetMap *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetMap(soap, tag ? tag : "ns1:GetMap", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetMap ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetMap(struct soap *soap, _ns1__GetMap **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetMap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CheckMapVer(struct soap *soap, _ns1__CheckMapVer *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CheckMapVer))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CheckMapVer(struct soap *soap, const char *tag, int id, _ns1__CheckMapVer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CheckMapVer, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__CheckMapVer ? type : NULL);
}

SOAP_FMAC3 _ns1__CheckMapVer ** SOAP_FMAC4 soap_in_PointerTo_ns1__CheckMapVer(struct soap *soap, const char *tag, _ns1__CheckMapVer **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CheckMapVer **)soap_malloc(soap, sizeof(_ns1__CheckMapVer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CheckMapVer *)soap_instantiate__ns1__CheckMapVer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CheckMapVer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CheckMapVer, sizeof(_ns1__CheckMapVer), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CheckMapVer(struct soap *soap, _ns1__CheckMapVer *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CheckMapVer(soap, tag ? tag : "ns1:CheckMapVer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CheckMapVer ** SOAP_FMAC4 soap_get_PointerTo_ns1__CheckMapVer(struct soap *soap, _ns1__CheckMapVer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CheckMapVer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetMangeXb(struct soap *soap, _ns1__GetMangeXb *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetMangeXb))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetMangeXb(struct soap *soap, const char *tag, int id, _ns1__GetMangeXb *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetMangeXb, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetMangeXb ? type : NULL);
}

SOAP_FMAC3 _ns1__GetMangeXb ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetMangeXb(struct soap *soap, const char *tag, _ns1__GetMangeXb **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetMangeXb **)soap_malloc(soap, sizeof(_ns1__GetMangeXb *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetMangeXb *)soap_instantiate__ns1__GetMangeXb(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetMangeXb **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetMangeXb, sizeof(_ns1__GetMangeXb), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetMangeXb(struct soap *soap, _ns1__GetMangeXb *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetMangeXb(soap, tag ? tag : "ns1:GetMangeXb", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetMangeXb ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetMangeXb(struct soap *soap, _ns1__GetMangeXb **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetMangeXb(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetMangeUnit(struct soap *soap, _ns1__GetMangeUnit *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetMangeUnit))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetMangeUnit(struct soap *soap, const char *tag, int id, _ns1__GetMangeUnit *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetMangeUnit, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetMangeUnit ? type : NULL);
}

SOAP_FMAC3 _ns1__GetMangeUnit ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetMangeUnit(struct soap *soap, const char *tag, _ns1__GetMangeUnit **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetMangeUnit **)soap_malloc(soap, sizeof(_ns1__GetMangeUnit *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetMangeUnit *)soap_instantiate__ns1__GetMangeUnit(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetMangeUnit **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetMangeUnit, sizeof(_ns1__GetMangeUnit), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetMangeUnit(struct soap *soap, _ns1__GetMangeUnit *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetMangeUnit(soap, tag ? tag : "ns1:GetMangeUnit", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetMangeUnit ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetMangeUnit(struct soap *soap, _ns1__GetMangeUnit **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetMangeUnit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetMaList(struct soap *soap, _ns1__GetMaList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetMaList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetMaList(struct soap *soap, const char *tag, int id, _ns1__GetMaList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetMaList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetMaList ? type : NULL);
}

SOAP_FMAC3 _ns1__GetMaList ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetMaList(struct soap *soap, const char *tag, _ns1__GetMaList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetMaList **)soap_malloc(soap, sizeof(_ns1__GetMaList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetMaList *)soap_instantiate__ns1__GetMaList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetMaList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetMaList, sizeof(_ns1__GetMaList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetMaList(struct soap *soap, _ns1__GetMaList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetMaList(soap, tag ? tag : "ns1:GetMaList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetMaList ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetMaList(struct soap *soap, _ns1__GetMaList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetMaList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetMapDeviceData(struct soap *soap, _ns1__GetMapDeviceData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetMapDeviceData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetMapDeviceData(struct soap *soap, const char *tag, int id, _ns1__GetMapDeviceData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetMapDeviceData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetMapDeviceData ? type : NULL);
}

SOAP_FMAC3 _ns1__GetMapDeviceData ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetMapDeviceData(struct soap *soap, const char *tag, _ns1__GetMapDeviceData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetMapDeviceData **)soap_malloc(soap, sizeof(_ns1__GetMapDeviceData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetMapDeviceData *)soap_instantiate__ns1__GetMapDeviceData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetMapDeviceData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetMapDeviceData, sizeof(_ns1__GetMapDeviceData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetMapDeviceData(struct soap *soap, _ns1__GetMapDeviceData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetMapDeviceData(soap, tag ? tag : "ns1:GetMapDeviceData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetMapDeviceData ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetMapDeviceData(struct soap *soap, _ns1__GetMapDeviceData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetMapDeviceData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetMapTabName(struct soap *soap, _ns1__GetMapTabName *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetMapTabName))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetMapTabName(struct soap *soap, const char *tag, int id, _ns1__GetMapTabName *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetMapTabName, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetMapTabName ? type : NULL);
}

SOAP_FMAC3 _ns1__GetMapTabName ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetMapTabName(struct soap *soap, const char *tag, _ns1__GetMapTabName **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetMapTabName **)soap_malloc(soap, sizeof(_ns1__GetMapTabName *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetMapTabName *)soap_instantiate__ns1__GetMapTabName(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetMapTabName **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetMapTabName, sizeof(_ns1__GetMapTabName), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetMapTabName(struct soap *soap, _ns1__GetMapTabName *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetMapTabName(soap, tag ? tag : "ns1:GetMapTabName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetMapTabName ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetMapTabName(struct soap *soap, _ns1__GetMapTabName **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetMapTabName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetMapUpdateTime(struct soap *soap, _ns1__GetMapUpdateTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetMapUpdateTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetMapUpdateTime(struct soap *soap, const char *tag, int id, _ns1__GetMapUpdateTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetMapUpdateTime, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetMapUpdateTime ? type : NULL);
}

SOAP_FMAC3 _ns1__GetMapUpdateTime ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetMapUpdateTime(struct soap *soap, const char *tag, _ns1__GetMapUpdateTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetMapUpdateTime **)soap_malloc(soap, sizeof(_ns1__GetMapUpdateTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetMapUpdateTime *)soap_instantiate__ns1__GetMapUpdateTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetMapUpdateTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetMapUpdateTime, sizeof(_ns1__GetMapUpdateTime), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetMapUpdateTime(struct soap *soap, _ns1__GetMapUpdateTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetMapUpdateTime(soap, tag ? tag : "ns1:GetMapUpdateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetMapUpdateTime ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetMapUpdateTime(struct soap *soap, _ns1__GetMapUpdateTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetMapUpdateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__WriteFile(struct soap *soap, _ns1__WriteFile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__WriteFile))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__WriteFile(struct soap *soap, const char *tag, int id, _ns1__WriteFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__WriteFile, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__WriteFile ? type : NULL);
}

SOAP_FMAC3 _ns1__WriteFile ** SOAP_FMAC4 soap_in_PointerTo_ns1__WriteFile(struct soap *soap, const char *tag, _ns1__WriteFile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__WriteFile **)soap_malloc(soap, sizeof(_ns1__WriteFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__WriteFile *)soap_instantiate__ns1__WriteFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__WriteFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__WriteFile, sizeof(_ns1__WriteFile), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__WriteFile(struct soap *soap, _ns1__WriteFile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__WriteFile(soap, tag ? tag : "ns1:WriteFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__WriteFile ** SOAP_FMAC4 soap_get_PointerTo_ns1__WriteFile(struct soap *soap, _ns1__WriteFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__WriteFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DownLoadFile(struct soap *soap, _ns1__DownLoadFile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DownLoadFile))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DownLoadFile(struct soap *soap, const char *tag, int id, _ns1__DownLoadFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DownLoadFile, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__DownLoadFile ? type : NULL);
}

SOAP_FMAC3 _ns1__DownLoadFile ** SOAP_FMAC4 soap_in_PointerTo_ns1__DownLoadFile(struct soap *soap, const char *tag, _ns1__DownLoadFile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DownLoadFile **)soap_malloc(soap, sizeof(_ns1__DownLoadFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DownLoadFile *)soap_instantiate__ns1__DownLoadFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__DownLoadFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DownLoadFile, sizeof(_ns1__DownLoadFile), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DownLoadFile(struct soap *soap, _ns1__DownLoadFile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__DownLoadFile(soap, tag ? tag : "ns1:DownLoadFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DownLoadFile ** SOAP_FMAC4 soap_get_PointerTo_ns1__DownLoadFile(struct soap *soap, _ns1__DownLoadFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DownLoadFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ExecuteSqlForFile(struct soap *soap, _ns1__ExecuteSqlForFile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ExecuteSqlForFile))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ExecuteSqlForFile(struct soap *soap, const char *tag, int id, _ns1__ExecuteSqlForFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ExecuteSqlForFile, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__ExecuteSqlForFile ? type : NULL);
}

SOAP_FMAC3 _ns1__ExecuteSqlForFile ** SOAP_FMAC4 soap_in_PointerTo_ns1__ExecuteSqlForFile(struct soap *soap, const char *tag, _ns1__ExecuteSqlForFile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ExecuteSqlForFile **)soap_malloc(soap, sizeof(_ns1__ExecuteSqlForFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ExecuteSqlForFile *)soap_instantiate__ns1__ExecuteSqlForFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ExecuteSqlForFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ExecuteSqlForFile, sizeof(_ns1__ExecuteSqlForFile), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ExecuteSqlForFile(struct soap *soap, _ns1__ExecuteSqlForFile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ExecuteSqlForFile(soap, tag ? tag : "ns1:ExecuteSqlForFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ExecuteSqlForFile ** SOAP_FMAC4 soap_get_PointerTo_ns1__ExecuteSqlForFile(struct soap *soap, _ns1__ExecuteSqlForFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ExecuteSqlForFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetFieldInfo(struct soap *soap, _ns1__GetFieldInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetFieldInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetFieldInfo(struct soap *soap, const char *tag, int id, _ns1__GetFieldInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetFieldInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetFieldInfo ? type : NULL);
}

SOAP_FMAC3 _ns1__GetFieldInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetFieldInfo(struct soap *soap, const char *tag, _ns1__GetFieldInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetFieldInfo **)soap_malloc(soap, sizeof(_ns1__GetFieldInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetFieldInfo *)soap_instantiate__ns1__GetFieldInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetFieldInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetFieldInfo, sizeof(_ns1__GetFieldInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetFieldInfo(struct soap *soap, _ns1__GetFieldInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetFieldInfo(soap, tag ? tag : "ns1:GetFieldInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetFieldInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetFieldInfo(struct soap *soap, _ns1__GetFieldInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetFieldInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__IsOracleTable(struct soap *soap, _ns1__IsOracleTable *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__IsOracleTable))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__IsOracleTable(struct soap *soap, const char *tag, int id, _ns1__IsOracleTable *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__IsOracleTable, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__IsOracleTable ? type : NULL);
}

SOAP_FMAC3 _ns1__IsOracleTable ** SOAP_FMAC4 soap_in_PointerTo_ns1__IsOracleTable(struct soap *soap, const char *tag, _ns1__IsOracleTable **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__IsOracleTable **)soap_malloc(soap, sizeof(_ns1__IsOracleTable *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__IsOracleTable *)soap_instantiate__ns1__IsOracleTable(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__IsOracleTable **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__IsOracleTable, sizeof(_ns1__IsOracleTable), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__IsOracleTable(struct soap *soap, _ns1__IsOracleTable *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__IsOracleTable(soap, tag ? tag : "ns1:IsOracleTable", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__IsOracleTable ** SOAP_FMAC4 soap_get_PointerTo_ns1__IsOracleTable(struct soap *soap, _ns1__IsOracleTable **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__IsOracleTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetTabList(struct soap *soap, _ns1__GetTabList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetTabList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetTabList(struct soap *soap, const char *tag, int id, _ns1__GetTabList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetTabList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetTabList ? type : NULL);
}

SOAP_FMAC3 _ns1__GetTabList ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetTabList(struct soap *soap, const char *tag, _ns1__GetTabList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetTabList **)soap_malloc(soap, sizeof(_ns1__GetTabList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetTabList *)soap_instantiate__ns1__GetTabList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetTabList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetTabList, sizeof(_ns1__GetTabList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetTabList(struct soap *soap, _ns1__GetTabList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetTabList(soap, tag ? tag : "ns1:GetTabList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetTabList ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetTabList(struct soap *soap, _ns1__GetTabList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetTabList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DownCQData(struct soap *soap, _ns1__DownCQData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DownCQData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DownCQData(struct soap *soap, const char *tag, int id, _ns1__DownCQData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DownCQData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__DownCQData ? type : NULL);
}

SOAP_FMAC3 _ns1__DownCQData ** SOAP_FMAC4 soap_in_PointerTo_ns1__DownCQData(struct soap *soap, const char *tag, _ns1__DownCQData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DownCQData **)soap_malloc(soap, sizeof(_ns1__DownCQData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DownCQData *)soap_instantiate__ns1__DownCQData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__DownCQData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DownCQData, sizeof(_ns1__DownCQData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DownCQData(struct soap *soap, _ns1__DownCQData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__DownCQData(soap, tag ? tag : "ns1:DownCQData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DownCQData ** SOAP_FMAC4 soap_get_PointerTo_ns1__DownCQData(struct soap *soap, _ns1__DownCQData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DownCQData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AlterTable(struct soap *soap, _ns1__AlterTable *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AlterTable))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AlterTable(struct soap *soap, const char *tag, int id, _ns1__AlterTable *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AlterTable, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__AlterTable ? type : NULL);
}

SOAP_FMAC3 _ns1__AlterTable ** SOAP_FMAC4 soap_in_PointerTo_ns1__AlterTable(struct soap *soap, const char *tag, _ns1__AlterTable **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AlterTable **)soap_malloc(soap, sizeof(_ns1__AlterTable *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AlterTable *)soap_instantiate__ns1__AlterTable(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__AlterTable **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AlterTable, sizeof(_ns1__AlterTable), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AlterTable(struct soap *soap, _ns1__AlterTable *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__AlterTable(soap, tag ? tag : "ns1:AlterTable", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AlterTable ** SOAP_FMAC4 soap_get_PointerTo_ns1__AlterTable(struct soap *soap, _ns1__AlterTable **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AlterTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetFileNew(struct soap *soap, _ns1__GetFileNew *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetFileNew))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetFileNew(struct soap *soap, const char *tag, int id, _ns1__GetFileNew *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetFileNew, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetFileNew ? type : NULL);
}

SOAP_FMAC3 _ns1__GetFileNew ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetFileNew(struct soap *soap, const char *tag, _ns1__GetFileNew **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetFileNew **)soap_malloc(soap, sizeof(_ns1__GetFileNew *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetFileNew *)soap_instantiate__ns1__GetFileNew(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetFileNew **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetFileNew, sizeof(_ns1__GetFileNew), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetFileNew(struct soap *soap, _ns1__GetFileNew *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetFileNew(soap, tag ? tag : "ns1:GetFileNew", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetFileNew ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetFileNew(struct soap *soap, _ns1__GetFileNew **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetFileNew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DownMapfile(struct soap *soap, _ns1__DownMapfile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DownMapfile))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DownMapfile(struct soap *soap, const char *tag, int id, _ns1__DownMapfile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DownMapfile, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__DownMapfile ? type : NULL);
}

SOAP_FMAC3 _ns1__DownMapfile ** SOAP_FMAC4 soap_in_PointerTo_ns1__DownMapfile(struct soap *soap, const char *tag, _ns1__DownMapfile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DownMapfile **)soap_malloc(soap, sizeof(_ns1__DownMapfile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DownMapfile *)soap_instantiate__ns1__DownMapfile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__DownMapfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DownMapfile, sizeof(_ns1__DownMapfile), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DownMapfile(struct soap *soap, _ns1__DownMapfile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__DownMapfile(soap, tag ? tag : "ns1:DownMapfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DownMapfile ** SOAP_FMAC4 soap_get_PointerTo_ns1__DownMapfile(struct soap *soap, _ns1__DownMapfile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DownMapfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetDownFileInfo(struct soap *soap, _ns1__GetDownFileInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetDownFileInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetDownFileInfo(struct soap *soap, const char *tag, int id, _ns1__GetDownFileInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetDownFileInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetDownFileInfo ? type : NULL);
}

SOAP_FMAC3 _ns1__GetDownFileInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetDownFileInfo(struct soap *soap, const char *tag, _ns1__GetDownFileInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetDownFileInfo **)soap_malloc(soap, sizeof(_ns1__GetDownFileInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetDownFileInfo *)soap_instantiate__ns1__GetDownFileInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetDownFileInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetDownFileInfo, sizeof(_ns1__GetDownFileInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetDownFileInfo(struct soap *soap, _ns1__GetDownFileInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetDownFileInfo(soap, tag ? tag : "ns1:GetDownFileInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetDownFileInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetDownFileInfo(struct soap *soap, _ns1__GetDownFileInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetDownFileInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetGxDeviceData(struct soap *soap, _ns1__GetGxDeviceData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetGxDeviceData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetGxDeviceData(struct soap *soap, const char *tag, int id, _ns1__GetGxDeviceData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetGxDeviceData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetGxDeviceData ? type : NULL);
}

SOAP_FMAC3 _ns1__GetGxDeviceData ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetGxDeviceData(struct soap *soap, const char *tag, _ns1__GetGxDeviceData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetGxDeviceData **)soap_malloc(soap, sizeof(_ns1__GetGxDeviceData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetGxDeviceData *)soap_instantiate__ns1__GetGxDeviceData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetGxDeviceData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetGxDeviceData, sizeof(_ns1__GetGxDeviceData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetGxDeviceData(struct soap *soap, _ns1__GetGxDeviceData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetGxDeviceData(soap, tag ? tag : "ns1:GetGxDeviceData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetGxDeviceData ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetGxDeviceData(struct soap *soap, _ns1__GetGxDeviceData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetGxDeviceData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetMapDeviceType(struct soap *soap, _ns1__GetMapDeviceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetMapDeviceType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetMapDeviceType(struct soap *soap, const char *tag, int id, _ns1__GetMapDeviceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetMapDeviceType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetMapDeviceType ? type : NULL);
}

SOAP_FMAC3 _ns1__GetMapDeviceType ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetMapDeviceType(struct soap *soap, const char *tag, _ns1__GetMapDeviceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetMapDeviceType **)soap_malloc(soap, sizeof(_ns1__GetMapDeviceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetMapDeviceType *)soap_instantiate__ns1__GetMapDeviceType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetMapDeviceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetMapDeviceType, sizeof(_ns1__GetMapDeviceType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetMapDeviceType(struct soap *soap, _ns1__GetMapDeviceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetMapDeviceType(soap, tag ? tag : "ns1:GetMapDeviceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetMapDeviceType ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetMapDeviceType(struct soap *soap, _ns1__GetMapDeviceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetMapDeviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetXbStationList(struct soap *soap, _ns1__GetXbStationList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetXbStationList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetXbStationList(struct soap *soap, const char *tag, int id, _ns1__GetXbStationList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetXbStationList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetXbStationList ? type : NULL);
}

SOAP_FMAC3 _ns1__GetXbStationList ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetXbStationList(struct soap *soap, const char *tag, _ns1__GetXbStationList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetXbStationList **)soap_malloc(soap, sizeof(_ns1__GetXbStationList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetXbStationList *)soap_instantiate__ns1__GetXbStationList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetXbStationList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetXbStationList, sizeof(_ns1__GetXbStationList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetXbStationList(struct soap *soap, _ns1__GetXbStationList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetXbStationList(soap, tag ? tag : "ns1:GetXbStationList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetXbStationList ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetXbStationList(struct soap *soap, _ns1__GetXbStationList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetXbStationList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetXbList(struct soap *soap, _ns1__GetXbList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetXbList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetXbList(struct soap *soap, const char *tag, int id, _ns1__GetXbList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetXbList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetXbList ? type : NULL);
}

SOAP_FMAC3 _ns1__GetXbList ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetXbList(struct soap *soap, const char *tag, _ns1__GetXbList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetXbList **)soap_malloc(soap, sizeof(_ns1__GetXbList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetXbList *)soap_instantiate__ns1__GetXbList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetXbList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetXbList, sizeof(_ns1__GetXbList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetXbList(struct soap *soap, _ns1__GetXbList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetXbList(soap, tag ? tag : "ns1:GetXbList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetXbList ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetXbList(struct soap *soap, _ns1__GetXbList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetXbList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetFileSize(struct soap *soap, _ns1__GetFileSize *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetFileSize))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetFileSize(struct soap *soap, const char *tag, int id, _ns1__GetFileSize *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetFileSize, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetFileSize ? type : NULL);
}

SOAP_FMAC3 _ns1__GetFileSize ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetFileSize(struct soap *soap, const char *tag, _ns1__GetFileSize **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetFileSize **)soap_malloc(soap, sizeof(_ns1__GetFileSize *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetFileSize *)soap_instantiate__ns1__GetFileSize(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetFileSize **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetFileSize, sizeof(_ns1__GetFileSize), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetFileSize(struct soap *soap, _ns1__GetFileSize *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetFileSize(soap, tag ? tag : "ns1:GetFileSize", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetFileSize ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetFileSize(struct soap *soap, _ns1__GetFileSize **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetFileSize(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetUnitPersonInfo(struct soap *soap, _ns1__GetUnitPersonInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetUnitPersonInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetUnitPersonInfo(struct soap *soap, const char *tag, int id, _ns1__GetUnitPersonInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetUnitPersonInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetUnitPersonInfo ? type : NULL);
}

SOAP_FMAC3 _ns1__GetUnitPersonInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetUnitPersonInfo(struct soap *soap, const char *tag, _ns1__GetUnitPersonInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetUnitPersonInfo **)soap_malloc(soap, sizeof(_ns1__GetUnitPersonInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetUnitPersonInfo *)soap_instantiate__ns1__GetUnitPersonInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetUnitPersonInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetUnitPersonInfo, sizeof(_ns1__GetUnitPersonInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetUnitPersonInfo(struct soap *soap, _ns1__GetUnitPersonInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetUnitPersonInfo(soap, tag ? tag : "ns1:GetUnitPersonInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetUnitPersonInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetUnitPersonInfo(struct soap *soap, _ns1__GetUnitPersonInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetUnitPersonInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetUnitStruct(struct soap *soap, _ns1__GetUnitStruct *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetUnitStruct))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetUnitStruct(struct soap *soap, const char *tag, int id, _ns1__GetUnitStruct *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetUnitStruct, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetUnitStruct ? type : NULL);
}

SOAP_FMAC3 _ns1__GetUnitStruct ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetUnitStruct(struct soap *soap, const char *tag, _ns1__GetUnitStruct **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetUnitStruct **)soap_malloc(soap, sizeof(_ns1__GetUnitStruct *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetUnitStruct *)soap_instantiate__ns1__GetUnitStruct(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetUnitStruct **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetUnitStruct, sizeof(_ns1__GetUnitStruct), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetUnitStruct(struct soap *soap, _ns1__GetUnitStruct *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetUnitStruct(soap, tag ? tag : "ns1:GetUnitStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetUnitStruct ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetUnitStruct(struct soap *soap, _ns1__GetUnitStruct **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetUnitStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetUnitStation(struct soap *soap, _ns1__GetUnitStation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetUnitStation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetUnitStation(struct soap *soap, const char *tag, int id, _ns1__GetUnitStation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetUnitStation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetUnitStation ? type : NULL);
}

SOAP_FMAC3 _ns1__GetUnitStation ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetUnitStation(struct soap *soap, const char *tag, _ns1__GetUnitStation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetUnitStation **)soap_malloc(soap, sizeof(_ns1__GetUnitStation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetUnitStation *)soap_instantiate__ns1__GetUnitStation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetUnitStation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetUnitStation, sizeof(_ns1__GetUnitStation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetUnitStation(struct soap *soap, _ns1__GetUnitStation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetUnitStation(soap, tag ? tag : "ns1:GetUnitStation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetUnitStation ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetUnitStation(struct soap *soap, _ns1__GetUnitStation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetUnitStation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetDwList(struct soap *soap, _ns1__GetDwList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetDwList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetDwList(struct soap *soap, const char *tag, int id, _ns1__GetDwList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetDwList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetDwList ? type : NULL);
}

SOAP_FMAC3 _ns1__GetDwList ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetDwList(struct soap *soap, const char *tag, _ns1__GetDwList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetDwList **)soap_malloc(soap, sizeof(_ns1__GetDwList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetDwList *)soap_instantiate__ns1__GetDwList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetDwList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetDwList, sizeof(_ns1__GetDwList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetDwList(struct soap *soap, _ns1__GetDwList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetDwList(soap, tag ? tag : "ns1:GetDwList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetDwList ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetDwList(struct soap *soap, _ns1__GetDwList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetDwList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetOpenFireInfo(struct soap *soap, _ns1__GetOpenFireInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetOpenFireInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetOpenFireInfo(struct soap *soap, const char *tag, int id, _ns1__GetOpenFireInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetOpenFireInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetOpenFireInfo ? type : NULL);
}

SOAP_FMAC3 _ns1__GetOpenFireInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetOpenFireInfo(struct soap *soap, const char *tag, _ns1__GetOpenFireInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetOpenFireInfo **)soap_malloc(soap, sizeof(_ns1__GetOpenFireInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetOpenFireInfo *)soap_instantiate__ns1__GetOpenFireInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetOpenFireInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetOpenFireInfo, sizeof(_ns1__GetOpenFireInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetOpenFireInfo(struct soap *soap, _ns1__GetOpenFireInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetOpenFireInfo(soap, tag ? tag : "ns1:GetOpenFireInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetOpenFireInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetOpenFireInfo(struct soap *soap, _ns1__GetOpenFireInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetOpenFireInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__MobDownLoadData(struct soap *soap, _ns1__MobDownLoadData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__MobDownLoadData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__MobDownLoadData(struct soap *soap, const char *tag, int id, _ns1__MobDownLoadData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__MobDownLoadData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__MobDownLoadData ? type : NULL);
}

SOAP_FMAC3 _ns1__MobDownLoadData ** SOAP_FMAC4 soap_in_PointerTo_ns1__MobDownLoadData(struct soap *soap, const char *tag, _ns1__MobDownLoadData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__MobDownLoadData **)soap_malloc(soap, sizeof(_ns1__MobDownLoadData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__MobDownLoadData *)soap_instantiate__ns1__MobDownLoadData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__MobDownLoadData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__MobDownLoadData, sizeof(_ns1__MobDownLoadData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__MobDownLoadData(struct soap *soap, _ns1__MobDownLoadData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__MobDownLoadData(soap, tag ? tag : "ns1:MobDownLoadData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__MobDownLoadData ** SOAP_FMAC4 soap_get_PointerTo_ns1__MobDownLoadData(struct soap *soap, _ns1__MobDownLoadData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__MobDownLoadData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DownLoadMobGPSData(struct soap *soap, _ns1__DownLoadMobGPSData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DownLoadMobGPSData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DownLoadMobGPSData(struct soap *soap, const char *tag, int id, _ns1__DownLoadMobGPSData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DownLoadMobGPSData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__DownLoadMobGPSData ? type : NULL);
}

SOAP_FMAC3 _ns1__DownLoadMobGPSData ** SOAP_FMAC4 soap_in_PointerTo_ns1__DownLoadMobGPSData(struct soap *soap, const char *tag, _ns1__DownLoadMobGPSData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DownLoadMobGPSData **)soap_malloc(soap, sizeof(_ns1__DownLoadMobGPSData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DownLoadMobGPSData *)soap_instantiate__ns1__DownLoadMobGPSData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__DownLoadMobGPSData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DownLoadMobGPSData, sizeof(_ns1__DownLoadMobGPSData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DownLoadMobGPSData(struct soap *soap, _ns1__DownLoadMobGPSData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__DownLoadMobGPSData(soap, tag ? tag : "ns1:DownLoadMobGPSData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DownLoadMobGPSData ** SOAP_FMAC4 soap_get_PointerTo_ns1__DownLoadMobGPSData(struct soap *soap, _ns1__DownLoadMobGPSData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DownLoadMobGPSData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetDcsData(struct soap *soap, _ns1__GetDcsData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetDcsData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetDcsData(struct soap *soap, const char *tag, int id, _ns1__GetDcsData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetDcsData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetDcsData ? type : NULL);
}

SOAP_FMAC3 _ns1__GetDcsData ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetDcsData(struct soap *soap, const char *tag, _ns1__GetDcsData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetDcsData **)soap_malloc(soap, sizeof(_ns1__GetDcsData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetDcsData *)soap_instantiate__ns1__GetDcsData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetDcsData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetDcsData, sizeof(_ns1__GetDcsData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetDcsData(struct soap *soap, _ns1__GetDcsData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetDcsData(soap, tag ? tag : "ns1:GetDcsData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetDcsData ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetDcsData(struct soap *soap, _ns1__GetDcsData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetDcsData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetBgImg(struct soap *soap, _ns1__GetBgImg *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetBgImg))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetBgImg(struct soap *soap, const char *tag, int id, _ns1__GetBgImg *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetBgImg, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetBgImg ? type : NULL);
}

SOAP_FMAC3 _ns1__GetBgImg ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetBgImg(struct soap *soap, const char *tag, _ns1__GetBgImg **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetBgImg **)soap_malloc(soap, sizeof(_ns1__GetBgImg *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetBgImg *)soap_instantiate__ns1__GetBgImg(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetBgImg **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetBgImg, sizeof(_ns1__GetBgImg), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetBgImg(struct soap *soap, _ns1__GetBgImg *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetBgImg(soap, tag ? tag : "ns1:GetBgImg", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetBgImg ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetBgImg(struct soap *soap, _ns1__GetBgImg **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetBgImg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetDevPic(struct soap *soap, _ns1__GetDevPic *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetDevPic))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetDevPic(struct soap *soap, const char *tag, int id, _ns1__GetDevPic *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetDevPic, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetDevPic ? type : NULL);
}

SOAP_FMAC3 _ns1__GetDevPic ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetDevPic(struct soap *soap, const char *tag, _ns1__GetDevPic **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetDevPic **)soap_malloc(soap, sizeof(_ns1__GetDevPic *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetDevPic *)soap_instantiate__ns1__GetDevPic(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetDevPic **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetDevPic, sizeof(_ns1__GetDevPic), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetDevPic(struct soap *soap, _ns1__GetDevPic *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetDevPic(soap, tag ? tag : "ns1:GetDevPic", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetDevPic ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetDevPic(struct soap *soap, _ns1__GetDevPic **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetDevPic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetJxPic(struct soap *soap, _ns1__GetJxPic *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetJxPic))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetJxPic(struct soap *soap, const char *tag, int id, _ns1__GetJxPic *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetJxPic, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetJxPic ? type : NULL);
}

SOAP_FMAC3 _ns1__GetJxPic ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetJxPic(struct soap *soap, const char *tag, _ns1__GetJxPic **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetJxPic **)soap_malloc(soap, sizeof(_ns1__GetJxPic *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetJxPic *)soap_instantiate__ns1__GetJxPic(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetJxPic **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetJxPic, sizeof(_ns1__GetJxPic), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetJxPic(struct soap *soap, _ns1__GetJxPic *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetJxPic(soap, tag ? tag : "ns1:GetJxPic", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetJxPic ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetJxPic(struct soap *soap, _ns1__GetJxPic **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetJxPic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetStationJxData(struct soap *soap, _ns1__GetStationJxData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetStationJxData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetStationJxData(struct soap *soap, const char *tag, int id, _ns1__GetStationJxData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetStationJxData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetStationJxData ? type : NULL);
}

SOAP_FMAC3 _ns1__GetStationJxData ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetStationJxData(struct soap *soap, const char *tag, _ns1__GetStationJxData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetStationJxData **)soap_malloc(soap, sizeof(_ns1__GetStationJxData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetStationJxData *)soap_instantiate__ns1__GetStationJxData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetStationJxData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetStationJxData, sizeof(_ns1__GetStationJxData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetStationJxData(struct soap *soap, _ns1__GetStationJxData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetStationJxData(soap, tag ? tag : "ns1:GetStationJxData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetStationJxData ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetStationJxData(struct soap *soap, _ns1__GetStationJxData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetStationJxData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetJxData(struct soap *soap, _ns1__GetJxData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetJxData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetJxData(struct soap *soap, const char *tag, int id, _ns1__GetJxData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetJxData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetJxData ? type : NULL);
}

SOAP_FMAC3 _ns1__GetJxData ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetJxData(struct soap *soap, const char *tag, _ns1__GetJxData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetJxData **)soap_malloc(soap, sizeof(_ns1__GetJxData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetJxData *)soap_instantiate__ns1__GetJxData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetJxData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetJxData, sizeof(_ns1__GetJxData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetJxData(struct soap *soap, _ns1__GetJxData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetJxData(soap, tag ? tag : "ns1:GetJxData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetJxData ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetJxData(struct soap *soap, _ns1__GetJxData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetJxData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetDeviceXj(struct soap *soap, _ns1__GetDeviceXj *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetDeviceXj))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetDeviceXj(struct soap *soap, const char *tag, int id, _ns1__GetDeviceXj *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetDeviceXj, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetDeviceXj ? type : NULL);
}

SOAP_FMAC3 _ns1__GetDeviceXj ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetDeviceXj(struct soap *soap, const char *tag, _ns1__GetDeviceXj **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetDeviceXj **)soap_malloc(soap, sizeof(_ns1__GetDeviceXj *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetDeviceXj *)soap_instantiate__ns1__GetDeviceXj(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetDeviceXj **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetDeviceXj, sizeof(_ns1__GetDeviceXj), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetDeviceXj(struct soap *soap, _ns1__GetDeviceXj *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetDeviceXj(soap, tag ? tag : "ns1:GetDeviceXj", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetDeviceXj ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetDeviceXj(struct soap *soap, _ns1__GetDeviceXj **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetDeviceXj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetDwPic(struct soap *soap, _ns1__GetDwPic *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetDwPic))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetDwPic(struct soap *soap, const char *tag, int id, _ns1__GetDwPic *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetDwPic, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetDwPic ? type : NULL);
}

SOAP_FMAC3 _ns1__GetDwPic ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetDwPic(struct soap *soap, const char *tag, _ns1__GetDwPic **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetDwPic **)soap_malloc(soap, sizeof(_ns1__GetDwPic *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetDwPic *)soap_instantiate__ns1__GetDwPic(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetDwPic **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetDwPic, sizeof(_ns1__GetDwPic), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetDwPic(struct soap *soap, _ns1__GetDwPic *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetDwPic(soap, tag ? tag : "ns1:GetDwPic", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetDwPic ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetDwPic(struct soap *soap, _ns1__GetDwPic **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetDwPic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetDwInfo(struct soap *soap, _ns1__GetDwInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetDwInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetDwInfo(struct soap *soap, const char *tag, int id, _ns1__GetDwInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetDwInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetDwInfo ? type : NULL);
}

SOAP_FMAC3 _ns1__GetDwInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetDwInfo(struct soap *soap, const char *tag, _ns1__GetDwInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetDwInfo **)soap_malloc(soap, sizeof(_ns1__GetDwInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetDwInfo *)soap_instantiate__ns1__GetDwInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetDwInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetDwInfo, sizeof(_ns1__GetDwInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetDwInfo(struct soap *soap, _ns1__GetDwInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetDwInfo(soap, tag ? tag : "ns1:GetDwInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetDwInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetDwInfo(struct soap *soap, _ns1__GetDwInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetDwInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPicNames(struct soap *soap, _ns1__GetPicNames *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPicNames))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPicNames(struct soap *soap, const char *tag, int id, _ns1__GetPicNames *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPicNames, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetPicNames ? type : NULL);
}

SOAP_FMAC3 _ns1__GetPicNames ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPicNames(struct soap *soap, const char *tag, _ns1__GetPicNames **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPicNames **)soap_malloc(soap, sizeof(_ns1__GetPicNames *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPicNames *)soap_instantiate__ns1__GetPicNames(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetPicNames **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPicNames, sizeof(_ns1__GetPicNames), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPicNames(struct soap *soap, _ns1__GetPicNames *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPicNames(soap, tag ? tag : "ns1:GetPicNames", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPicNames ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPicNames(struct soap *soap, _ns1__GetPicNames **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPicNames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DownloadPic(struct soap *soap, _ns1__DownloadPic *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DownloadPic))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DownloadPic(struct soap *soap, const char *tag, int id, _ns1__DownloadPic *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DownloadPic, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__DownloadPic ? type : NULL);
}

SOAP_FMAC3 _ns1__DownloadPic ** SOAP_FMAC4 soap_in_PointerTo_ns1__DownloadPic(struct soap *soap, const char *tag, _ns1__DownloadPic **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DownloadPic **)soap_malloc(soap, sizeof(_ns1__DownloadPic *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DownloadPic *)soap_instantiate__ns1__DownloadPic(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__DownloadPic **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DownloadPic, sizeof(_ns1__DownloadPic), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DownloadPic(struct soap *soap, _ns1__DownloadPic *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__DownloadPic(soap, tag ? tag : "ns1:DownloadPic", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DownloadPic ** SOAP_FMAC4 soap_get_PointerTo_ns1__DownloadPic(struct soap *soap, _ns1__DownloadPic **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DownloadPic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__upPic(struct soap *soap, _ns1__upPic *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__upPic))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__upPic(struct soap *soap, const char *tag, int id, _ns1__upPic *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__upPic, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__upPic ? type : NULL);
}

SOAP_FMAC3 _ns1__upPic ** SOAP_FMAC4 soap_in_PointerTo_ns1__upPic(struct soap *soap, const char *tag, _ns1__upPic **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__upPic **)soap_malloc(soap, sizeof(_ns1__upPic *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__upPic *)soap_instantiate__ns1__upPic(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__upPic **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__upPic, sizeof(_ns1__upPic), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__upPic(struct soap *soap, _ns1__upPic *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__upPic(soap, tag ? tag : "ns1:upPic", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__upPic ** SOAP_FMAC4 soap_get_PointerTo_ns1__upPic(struct soap *soap, _ns1__upPic **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__upPic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpLoadFile(struct soap *soap, _ns1__UpLoadFile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpLoadFile))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpLoadFile(struct soap *soap, const char *tag, int id, _ns1__UpLoadFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpLoadFile, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__UpLoadFile ? type : NULL);
}

SOAP_FMAC3 _ns1__UpLoadFile ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpLoadFile(struct soap *soap, const char *tag, _ns1__UpLoadFile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpLoadFile **)soap_malloc(soap, sizeof(_ns1__UpLoadFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpLoadFile *)soap_instantiate__ns1__UpLoadFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__UpLoadFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpLoadFile, sizeof(_ns1__UpLoadFile), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpLoadFile(struct soap *soap, _ns1__UpLoadFile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__UpLoadFile(soap, tag ? tag : "ns1:UpLoadFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpLoadFile ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpLoadFile(struct soap *soap, _ns1__UpLoadFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpLoadFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAPVupdater(struct soap *soap, _ns1__GetAPVupdater *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAPVupdater))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAPVupdater(struct soap *soap, const char *tag, int id, _ns1__GetAPVupdater *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAPVupdater, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetAPVupdater ? type : NULL);
}

SOAP_FMAC3 _ns1__GetAPVupdater ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAPVupdater(struct soap *soap, const char *tag, _ns1__GetAPVupdater **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAPVupdater **)soap_malloc(soap, sizeof(_ns1__GetAPVupdater *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAPVupdater *)soap_instantiate__ns1__GetAPVupdater(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetAPVupdater **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAPVupdater, sizeof(_ns1__GetAPVupdater), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAPVupdater(struct soap *soap, _ns1__GetAPVupdater *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetAPVupdater(soap, tag ? tag : "ns1:GetAPVupdater", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAPVupdater ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAPVupdater(struct soap *soap, _ns1__GetAPVupdater **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAPVupdater(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetXHYDGLXTupdater(struct soap *soap, _ns1__GetXHYDGLXTupdater *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetXHYDGLXTupdater))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetXHYDGLXTupdater(struct soap *soap, const char *tag, int id, _ns1__GetXHYDGLXTupdater *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetXHYDGLXTupdater, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetXHYDGLXTupdater ? type : NULL);
}

SOAP_FMAC3 _ns1__GetXHYDGLXTupdater ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetXHYDGLXTupdater(struct soap *soap, const char *tag, _ns1__GetXHYDGLXTupdater **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetXHYDGLXTupdater **)soap_malloc(soap, sizeof(_ns1__GetXHYDGLXTupdater *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetXHYDGLXTupdater *)soap_instantiate__ns1__GetXHYDGLXTupdater(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetXHYDGLXTupdater **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetXHYDGLXTupdater, sizeof(_ns1__GetXHYDGLXTupdater), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetXHYDGLXTupdater(struct soap *soap, _ns1__GetXHYDGLXTupdater *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetXHYDGLXTupdater(soap, tag ? tag : "ns1:GetXHYDGLXTupdater", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetXHYDGLXTupdater ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetXHYDGLXTupdater(struct soap *soap, _ns1__GetXHYDGLXTupdater **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetXHYDGLXTupdater(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ExecuteSqlForColb(struct soap *soap, _ns1__ExecuteSqlForColb *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ExecuteSqlForColb))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ExecuteSqlForColb(struct soap *soap, const char *tag, int id, _ns1__ExecuteSqlForColb *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ExecuteSqlForColb, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__ExecuteSqlForColb ? type : NULL);
}

SOAP_FMAC3 _ns1__ExecuteSqlForColb ** SOAP_FMAC4 soap_in_PointerTo_ns1__ExecuteSqlForColb(struct soap *soap, const char *tag, _ns1__ExecuteSqlForColb **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ExecuteSqlForColb **)soap_malloc(soap, sizeof(_ns1__ExecuteSqlForColb *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ExecuteSqlForColb *)soap_instantiate__ns1__ExecuteSqlForColb(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ExecuteSqlForColb **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ExecuteSqlForColb, sizeof(_ns1__ExecuteSqlForColb), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ExecuteSqlForColb(struct soap *soap, _ns1__ExecuteSqlForColb *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ExecuteSqlForColb(soap, tag ? tag : "ns1:ExecuteSqlForColb", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ExecuteSqlForColb ** SOAP_FMAC4 soap_get_PointerTo_ns1__ExecuteSqlForColb(struct soap *soap, _ns1__ExecuteSqlForColb **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ExecuteSqlForColb(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpLoadData(struct soap *soap, _ns1__UpLoadData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpLoadData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpLoadData(struct soap *soap, const char *tag, int id, _ns1__UpLoadData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpLoadData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__UpLoadData ? type : NULL);
}

SOAP_FMAC3 _ns1__UpLoadData ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpLoadData(struct soap *soap, const char *tag, _ns1__UpLoadData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpLoadData **)soap_malloc(soap, sizeof(_ns1__UpLoadData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpLoadData *)soap_instantiate__ns1__UpLoadData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__UpLoadData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpLoadData, sizeof(_ns1__UpLoadData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpLoadData(struct soap *soap, _ns1__UpLoadData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__UpLoadData(soap, tag ? tag : "ns1:UpLoadData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpLoadData ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpLoadData(struct soap *soap, _ns1__UpLoadData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpLoadData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__TcdSendup(struct soap *soap, _ns1__TcdSendup *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__TcdSendup))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__TcdSendup(struct soap *soap, const char *tag, int id, _ns1__TcdSendup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__TcdSendup, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__TcdSendup ? type : NULL);
}

SOAP_FMAC3 _ns1__TcdSendup ** SOAP_FMAC4 soap_in_PointerTo_ns1__TcdSendup(struct soap *soap, const char *tag, _ns1__TcdSendup **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__TcdSendup **)soap_malloc(soap, sizeof(_ns1__TcdSendup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__TcdSendup *)soap_instantiate__ns1__TcdSendup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__TcdSendup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__TcdSendup, sizeof(_ns1__TcdSendup), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__TcdSendup(struct soap *soap, _ns1__TcdSendup *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__TcdSendup(soap, tag ? tag : "ns1:TcdSendup", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__TcdSendup ** SOAP_FMAC4 soap_get_PointerTo_ns1__TcdSendup(struct soap *soap, _ns1__TcdSendup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__TcdSendup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__TcdQuery(struct soap *soap, _ns1__TcdQuery *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__TcdQuery))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__TcdQuery(struct soap *soap, const char *tag, int id, _ns1__TcdQuery *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__TcdQuery, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__TcdQuery ? type : NULL);
}

SOAP_FMAC3 _ns1__TcdQuery ** SOAP_FMAC4 soap_in_PointerTo_ns1__TcdQuery(struct soap *soap, const char *tag, _ns1__TcdQuery **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__TcdQuery **)soap_malloc(soap, sizeof(_ns1__TcdQuery *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__TcdQuery *)soap_instantiate__ns1__TcdQuery(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__TcdQuery **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__TcdQuery, sizeof(_ns1__TcdQuery), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__TcdQuery(struct soap *soap, _ns1__TcdQuery *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__TcdQuery(soap, tag ? tag : "ns1:TcdQuery", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__TcdQuery ** SOAP_FMAC4 soap_get_PointerTo_ns1__TcdQuery(struct soap *soap, _ns1__TcdQuery **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__TcdQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__QueryPhotobw(struct soap *soap, _ns1__QueryPhotobw *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__QueryPhotobw))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__QueryPhotobw(struct soap *soap, const char *tag, int id, _ns1__QueryPhotobw *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__QueryPhotobw, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__QueryPhotobw ? type : NULL);
}

SOAP_FMAC3 _ns1__QueryPhotobw ** SOAP_FMAC4 soap_in_PointerTo_ns1__QueryPhotobw(struct soap *soap, const char *tag, _ns1__QueryPhotobw **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__QueryPhotobw **)soap_malloc(soap, sizeof(_ns1__QueryPhotobw *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__QueryPhotobw *)soap_instantiate__ns1__QueryPhotobw(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__QueryPhotobw **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__QueryPhotobw, sizeof(_ns1__QueryPhotobw), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__QueryPhotobw(struct soap *soap, _ns1__QueryPhotobw *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__QueryPhotobw(soap, tag ? tag : "ns1:QueryPhotobw", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__QueryPhotobw ** SOAP_FMAC4 soap_get_PointerTo_ns1__QueryPhotobw(struct soap *soap, _ns1__QueryPhotobw **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__QueryPhotobw(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetOsDateTime(struct soap *soap, _ns1__GetOsDateTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetOsDateTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetOsDateTime(struct soap *soap, const char *tag, int id, _ns1__GetOsDateTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetOsDateTime, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetOsDateTime ? type : NULL);
}

SOAP_FMAC3 _ns1__GetOsDateTime ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetOsDateTime(struct soap *soap, const char *tag, _ns1__GetOsDateTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetOsDateTime **)soap_malloc(soap, sizeof(_ns1__GetOsDateTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetOsDateTime *)soap_instantiate__ns1__GetOsDateTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetOsDateTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetOsDateTime, sizeof(_ns1__GetOsDateTime), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetOsDateTime(struct soap *soap, _ns1__GetOsDateTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetOsDateTime(soap, tag ? tag : "ns1:GetOsDateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetOsDateTime ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetOsDateTime(struct soap *soap, _ns1__GetOsDateTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetOsDateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__signedUserInfo(struct soap *soap, _ns1__signedUserInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__signedUserInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__signedUserInfo(struct soap *soap, const char *tag, int id, _ns1__signedUserInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__signedUserInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__signedUserInfo ? type : NULL);
}

SOAP_FMAC3 _ns1__signedUserInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__signedUserInfo(struct soap *soap, const char *tag, _ns1__signedUserInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__signedUserInfo **)soap_malloc(soap, sizeof(_ns1__signedUserInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__signedUserInfo *)soap_instantiate__ns1__signedUserInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__signedUserInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__signedUserInfo, sizeof(_ns1__signedUserInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__signedUserInfo(struct soap *soap, _ns1__signedUserInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__signedUserInfo(soap, tag ? tag : "ns1:signedUserInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__signedUserInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__signedUserInfo(struct soap *soap, _ns1__signedUserInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__signedUserInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetGxdataUpTime(struct soap *soap, _ns1__GetGxdataUpTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetGxdataUpTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetGxdataUpTime(struct soap *soap, const char *tag, int id, _ns1__GetGxdataUpTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetGxdataUpTime, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetGxdataUpTime ? type : NULL);
}

SOAP_FMAC3 _ns1__GetGxdataUpTime ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetGxdataUpTime(struct soap *soap, const char *tag, _ns1__GetGxdataUpTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetGxdataUpTime **)soap_malloc(soap, sizeof(_ns1__GetGxdataUpTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetGxdataUpTime *)soap_instantiate__ns1__GetGxdataUpTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetGxdataUpTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetGxdataUpTime, sizeof(_ns1__GetGxdataUpTime), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetGxdataUpTime(struct soap *soap, _ns1__GetGxdataUpTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetGxdataUpTime(soap, tag ? tag : "ns1:GetGxdataUpTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetGxdataUpTime ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetGxdataUpTime(struct soap *soap, _ns1__GetGxdataUpTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetGxdataUpTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DownAllPic(struct soap *soap, _ns1__DownAllPic *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DownAllPic))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DownAllPic(struct soap *soap, const char *tag, int id, _ns1__DownAllPic *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DownAllPic, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__DownAllPic ? type : NULL);
}

SOAP_FMAC3 _ns1__DownAllPic ** SOAP_FMAC4 soap_in_PointerTo_ns1__DownAllPic(struct soap *soap, const char *tag, _ns1__DownAllPic **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DownAllPic **)soap_malloc(soap, sizeof(_ns1__DownAllPic *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DownAllPic *)soap_instantiate__ns1__DownAllPic(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__DownAllPic **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DownAllPic, sizeof(_ns1__DownAllPic), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DownAllPic(struct soap *soap, _ns1__DownAllPic *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__DownAllPic(soap, tag ? tag : "ns1:DownAllPic", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DownAllPic ** SOAP_FMAC4 soap_get_PointerTo_ns1__DownAllPic(struct soap *soap, _ns1__DownAllPic **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DownAllPic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DownPic(struct soap *soap, _ns1__DownPic *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DownPic))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DownPic(struct soap *soap, const char *tag, int id, _ns1__DownPic *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DownPic, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__DownPic ? type : NULL);
}

SOAP_FMAC3 _ns1__DownPic ** SOAP_FMAC4 soap_in_PointerTo_ns1__DownPic(struct soap *soap, const char *tag, _ns1__DownPic **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DownPic **)soap_malloc(soap, sizeof(_ns1__DownPic *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DownPic *)soap_instantiate__ns1__DownPic(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__DownPic **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DownPic, sizeof(_ns1__DownPic), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DownPic(struct soap *soap, _ns1__DownPic *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__DownPic(soap, tag ? tag : "ns1:DownPic", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DownPic ** SOAP_FMAC4 soap_get_PointerTo_ns1__DownPic(struct soap *soap, _ns1__DownPic **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DownPic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SaveFileData(struct soap *soap, _ns1__SaveFileData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SaveFileData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SaveFileData(struct soap *soap, const char *tag, int id, _ns1__SaveFileData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SaveFileData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SaveFileData ? type : NULL);
}

SOAP_FMAC3 _ns1__SaveFileData ** SOAP_FMAC4 soap_in_PointerTo_ns1__SaveFileData(struct soap *soap, const char *tag, _ns1__SaveFileData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SaveFileData **)soap_malloc(soap, sizeof(_ns1__SaveFileData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SaveFileData *)soap_instantiate__ns1__SaveFileData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SaveFileData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SaveFileData, sizeof(_ns1__SaveFileData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SaveFileData(struct soap *soap, _ns1__SaveFileData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SaveFileData(soap, tag ? tag : "ns1:SaveFileData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SaveFileData ** SOAP_FMAC4 soap_get_PointerTo_ns1__SaveFileData(struct soap *soap, _ns1__SaveFileData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SaveFileData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SaveData(struct soap *soap, _ns1__SaveData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SaveData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SaveData(struct soap *soap, const char *tag, int id, _ns1__SaveData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SaveData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SaveData ? type : NULL);
}

SOAP_FMAC3 _ns1__SaveData ** SOAP_FMAC4 soap_in_PointerTo_ns1__SaveData(struct soap *soap, const char *tag, _ns1__SaveData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SaveData **)soap_malloc(soap, sizeof(_ns1__SaveData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SaveData *)soap_instantiate__ns1__SaveData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SaveData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SaveData, sizeof(_ns1__SaveData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SaveData(struct soap *soap, _ns1__SaveData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SaveData(soap, tag ? tag : "ns1:SaveData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SaveData ** SOAP_FMAC4 soap_get_PointerTo_ns1__SaveData(struct soap *soap, _ns1__SaveData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SaveData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ExecuteSql(struct soap *soap, _ns1__ExecuteSql *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ExecuteSql))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ExecuteSql(struct soap *soap, const char *tag, int id, _ns1__ExecuteSql *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ExecuteSql, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__ExecuteSql ? type : NULL);
}

SOAP_FMAC3 _ns1__ExecuteSql ** SOAP_FMAC4 soap_in_PointerTo_ns1__ExecuteSql(struct soap *soap, const char *tag, _ns1__ExecuteSql **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ExecuteSql **)soap_malloc(soap, sizeof(_ns1__ExecuteSql *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ExecuteSql *)soap_instantiate__ns1__ExecuteSql(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ExecuteSql **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ExecuteSql, sizeof(_ns1__ExecuteSql), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ExecuteSql(struct soap *soap, _ns1__ExecuteSql *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ExecuteSql(soap, tag ? tag : "ns1:ExecuteSql", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ExecuteSql ** SOAP_FMAC4 soap_get_PointerTo_ns1__ExecuteSql(struct soap *soap, _ns1__ExecuteSql **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ExecuteSql(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__QueryDataCount(struct soap *soap, _ns1__QueryDataCount *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__QueryDataCount))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__QueryDataCount(struct soap *soap, const char *tag, int id, _ns1__QueryDataCount *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__QueryDataCount, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__QueryDataCount ? type : NULL);
}

SOAP_FMAC3 _ns1__QueryDataCount ** SOAP_FMAC4 soap_in_PointerTo_ns1__QueryDataCount(struct soap *soap, const char *tag, _ns1__QueryDataCount **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__QueryDataCount **)soap_malloc(soap, sizeof(_ns1__QueryDataCount *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__QueryDataCount *)soap_instantiate__ns1__QueryDataCount(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__QueryDataCount **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__QueryDataCount, sizeof(_ns1__QueryDataCount), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__QueryDataCount(struct soap *soap, _ns1__QueryDataCount *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__QueryDataCount(soap, tag ? tag : "ns1:QueryDataCount", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__QueryDataCount ** SOAP_FMAC4 soap_get_PointerTo_ns1__QueryDataCount(struct soap *soap, _ns1__QueryDataCount **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__QueryDataCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__QueryData(struct soap *soap, _ns1__QueryData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__QueryData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__QueryData(struct soap *soap, const char *tag, int id, _ns1__QueryData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__QueryData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__QueryData ? type : NULL);
}

SOAP_FMAC3 _ns1__QueryData ** SOAP_FMAC4 soap_in_PointerTo_ns1__QueryData(struct soap *soap, const char *tag, _ns1__QueryData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__QueryData **)soap_malloc(soap, sizeof(_ns1__QueryData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__QueryData *)soap_instantiate__ns1__QueryData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__QueryData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__QueryData, sizeof(_ns1__QueryData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__QueryData(struct soap *soap, _ns1__QueryData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__QueryData(soap, tag ? tag : "ns1:QueryData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__QueryData ** SOAP_FMAC4 soap_get_PointerTo_ns1__QueryData(struct soap *soap, _ns1__QueryData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__QueryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetDBString(struct soap *soap, _ns1__GetDBString *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetDBString))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetDBString(struct soap *soap, const char *tag, int id, _ns1__GetDBString *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetDBString, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetDBString ? type : NULL);
}

SOAP_FMAC3 _ns1__GetDBString ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetDBString(struct soap *soap, const char *tag, _ns1__GetDBString **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetDBString **)soap_malloc(soap, sizeof(_ns1__GetDBString *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetDBString *)soap_instantiate__ns1__GetDBString(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetDBString **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetDBString, sizeof(_ns1__GetDBString), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetDBString(struct soap *soap, _ns1__GetDBString *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetDBString(soap, tag ? tag : "ns1:GetDBString", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetDBString ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetDBString(struct soap *soap, _ns1__GetDBString **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetDBString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__HelloWorld(struct soap *soap, _ns1__HelloWorld *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__HelloWorld))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__HelloWorld(struct soap *soap, const char *tag, int id, _ns1__HelloWorld *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__HelloWorld, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__HelloWorld ? type : NULL);
}

SOAP_FMAC3 _ns1__HelloWorld ** SOAP_FMAC4 soap_in_PointerTo_ns1__HelloWorld(struct soap *soap, const char *tag, _ns1__HelloWorld **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__HelloWorld **)soap_malloc(soap, sizeof(_ns1__HelloWorld *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__HelloWorld *)soap_instantiate__ns1__HelloWorld(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__HelloWorld **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__HelloWorld, sizeof(_ns1__HelloWorld), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__HelloWorld(struct soap *soap, _ns1__HelloWorld *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__HelloWorld(soap, tag ? tag : "ns1:HelloWorld", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__HelloWorld ** SOAP_FMAC4 soap_get_PointerTo_ns1__HelloWorld(struct soap *soap, _ns1__HelloWorld **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__HelloWorld(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CheckDevCode(struct soap *soap, _ns1__CheckDevCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CheckDevCode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CheckDevCode(struct soap *soap, const char *tag, int id, _ns1__CheckDevCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CheckDevCode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__CheckDevCode ? type : NULL);
}

SOAP_FMAC3 _ns1__CheckDevCode ** SOAP_FMAC4 soap_in_PointerTo_ns1__CheckDevCode(struct soap *soap, const char *tag, _ns1__CheckDevCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CheckDevCode **)soap_malloc(soap, sizeof(_ns1__CheckDevCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CheckDevCode *)soap_instantiate__ns1__CheckDevCode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CheckDevCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CheckDevCode, sizeof(_ns1__CheckDevCode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CheckDevCode(struct soap *soap, _ns1__CheckDevCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CheckDevCode(soap, tag ? tag : "ns1:CheckDevCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CheckDevCode ** SOAP_FMAC4 soap_get_PointerTo_ns1__CheckDevCode(struct soap *soap, _ns1__CheckDevCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CheckDevCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetDevCode(struct soap *soap, _ns1__GetDevCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetDevCode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetDevCode(struct soap *soap, const char *tag, int id, _ns1__GetDevCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetDevCode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetDevCode ? type : NULL);
}

SOAP_FMAC3 _ns1__GetDevCode ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetDevCode(struct soap *soap, const char *tag, _ns1__GetDevCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetDevCode **)soap_malloc(soap, sizeof(_ns1__GetDevCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetDevCode *)soap_instantiate__ns1__GetDevCode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetDevCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetDevCode, sizeof(_ns1__GetDevCode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetDevCode(struct soap *soap, _ns1__GetDevCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetDevCode(soap, tag ? tag : "ns1:GetDevCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetDevCode ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetDevCode(struct soap *soap, _ns1__GetDevCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetDevCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetRyUnit(struct soap *soap, _ns1__GetRyUnit *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetRyUnit))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetRyUnit(struct soap *soap, const char *tag, int id, _ns1__GetRyUnit *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetRyUnit, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetRyUnit ? type : NULL);
}

SOAP_FMAC3 _ns1__GetRyUnit ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetRyUnit(struct soap *soap, const char *tag, _ns1__GetRyUnit **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetRyUnit **)soap_malloc(soap, sizeof(_ns1__GetRyUnit *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetRyUnit *)soap_instantiate__ns1__GetRyUnit(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetRyUnit **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetRyUnit, sizeof(_ns1__GetRyUnit), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetRyUnit(struct soap *soap, _ns1__GetRyUnit *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetRyUnit(soap, tag ? tag : "ns1:GetRyUnit", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetRyUnit ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetRyUnit(struct soap *soap, _ns1__GetRyUnit **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetRyUnit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CheckLoginUser(struct soap *soap, _ns1__CheckLoginUser *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CheckLoginUser))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CheckLoginUser(struct soap *soap, const char *tag, int id, _ns1__CheckLoginUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CheckLoginUser, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__CheckLoginUser ? type : NULL);
}

SOAP_FMAC3 _ns1__CheckLoginUser ** SOAP_FMAC4 soap_in_PointerTo_ns1__CheckLoginUser(struct soap *soap, const char *tag, _ns1__CheckLoginUser **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CheckLoginUser **)soap_malloc(soap, sizeof(_ns1__CheckLoginUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CheckLoginUser *)soap_instantiate__ns1__CheckLoginUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CheckLoginUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CheckLoginUser, sizeof(_ns1__CheckLoginUser), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CheckLoginUser(struct soap *soap, _ns1__CheckLoginUser *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CheckLoginUser(soap, tag ? tag : "ns1:CheckLoginUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CheckLoginUser ** SOAP_FMAC4 soap_get_PointerTo_ns1__CheckLoginUser(struct soap *soap, _ns1__CheckLoginUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CheckLoginUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPropName(struct soap *soap, _ns1__GetPropName *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPropName))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPropName(struct soap *soap, const char *tag, int id, _ns1__GetPropName *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPropName, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetPropName ? type : NULL);
}

SOAP_FMAC3 _ns1__GetPropName ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPropName(struct soap *soap, const char *tag, _ns1__GetPropName **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPropName **)soap_malloc(soap, sizeof(_ns1__GetPropName *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPropName *)soap_instantiate__ns1__GetPropName(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetPropName **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPropName, sizeof(_ns1__GetPropName), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPropName(struct soap *soap, _ns1__GetPropName *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPropName(soap, tag ? tag : "ns1:GetPropName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPropName ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPropName(struct soap *soap, _ns1__GetPropName **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPropName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPropList(struct soap *soap, _ns1__GetPropList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPropList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPropList(struct soap *soap, const char *tag, int id, _ns1__GetPropList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPropList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetPropList ? type : NULL);
}

SOAP_FMAC3 _ns1__GetPropList ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPropList(struct soap *soap, const char *tag, _ns1__GetPropList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPropList **)soap_malloc(soap, sizeof(_ns1__GetPropList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPropList *)soap_instantiate__ns1__GetPropList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetPropList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPropList, sizeof(_ns1__GetPropList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPropList(struct soap *soap, _ns1__GetPropList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPropList(soap, tag ? tag : "ns1:GetPropList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPropList ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPropList(struct soap *soap, _ns1__GetPropList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPropList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetYjzhZskDevFlowChartList(struct soap *soap, _ns1__GetYjzhZskDevFlowChartList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetYjzhZskDevFlowChartList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetYjzhZskDevFlowChartList(struct soap *soap, const char *tag, int id, _ns1__GetYjzhZskDevFlowChartList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetYjzhZskDevFlowChartList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetYjzhZskDevFlowChartList ? type : NULL);
}

SOAP_FMAC3 _ns1__GetYjzhZskDevFlowChartList ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetYjzhZskDevFlowChartList(struct soap *soap, const char *tag, _ns1__GetYjzhZskDevFlowChartList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetYjzhZskDevFlowChartList **)soap_malloc(soap, sizeof(_ns1__GetYjzhZskDevFlowChartList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetYjzhZskDevFlowChartList *)soap_instantiate__ns1__GetYjzhZskDevFlowChartList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetYjzhZskDevFlowChartList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetYjzhZskDevFlowChartList, sizeof(_ns1__GetYjzhZskDevFlowChartList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetYjzhZskDevFlowChartList(struct soap *soap, _ns1__GetYjzhZskDevFlowChartList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetYjzhZskDevFlowChartList(soap, tag ? tag : "ns1:GetYjzhZskDevFlowChartList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetYjzhZskDevFlowChartList ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetYjzhZskDevFlowChartList(struct soap *soap, _ns1__GetYjzhZskDevFlowChartList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetYjzhZskDevFlowChartList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetYjzhZskOtherFlowChartList(struct soap *soap, _ns1__GetYjzhZskOtherFlowChartList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetYjzhZskOtherFlowChartList(struct soap *soap, const char *tag, int id, _ns1__GetYjzhZskOtherFlowChartList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartList ? type : NULL);
}

SOAP_FMAC3 _ns1__GetYjzhZskOtherFlowChartList ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetYjzhZskOtherFlowChartList(struct soap *soap, const char *tag, _ns1__GetYjzhZskOtherFlowChartList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetYjzhZskOtherFlowChartList **)soap_malloc(soap, sizeof(_ns1__GetYjzhZskOtherFlowChartList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetYjzhZskOtherFlowChartList *)soap_instantiate__ns1__GetYjzhZskOtherFlowChartList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetYjzhZskOtherFlowChartList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetYjzhZskOtherFlowChartList, sizeof(_ns1__GetYjzhZskOtherFlowChartList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetYjzhZskOtherFlowChartList(struct soap *soap, _ns1__GetYjzhZskOtherFlowChartList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetYjzhZskOtherFlowChartList(soap, tag ? tag : "ns1:GetYjzhZskOtherFlowChartList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetYjzhZskOtherFlowChartList ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetYjzhZskOtherFlowChartList(struct soap *soap, _ns1__GetYjzhZskOtherFlowChartList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetYjzhZskOtherFlowChartList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetYjzhZskGzFlow(struct soap *soap, _ns1__GetYjzhZskGzFlow *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetYjzhZskGzFlow))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetYjzhZskGzFlow(struct soap *soap, const char *tag, int id, _ns1__GetYjzhZskGzFlow *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetYjzhZskGzFlow, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetYjzhZskGzFlow ? type : NULL);
}

SOAP_FMAC3 _ns1__GetYjzhZskGzFlow ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetYjzhZskGzFlow(struct soap *soap, const char *tag, _ns1__GetYjzhZskGzFlow **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetYjzhZskGzFlow **)soap_malloc(soap, sizeof(_ns1__GetYjzhZskGzFlow *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetYjzhZskGzFlow *)soap_instantiate__ns1__GetYjzhZskGzFlow(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetYjzhZskGzFlow **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetYjzhZskGzFlow, sizeof(_ns1__GetYjzhZskGzFlow), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetYjzhZskGzFlow(struct soap *soap, _ns1__GetYjzhZskGzFlow *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetYjzhZskGzFlow(soap, tag ? tag : "ns1:GetYjzhZskGzFlow", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetYjzhZskGzFlow ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetYjzhZskGzFlow(struct soap *soap, _ns1__GetYjzhZskGzFlow **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetYjzhZskGzFlow(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfBase64Binary(struct soap *soap, ns1__ArrayOfBase64Binary *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfBase64Binary))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfBase64Binary(struct soap *soap, const char *tag, int id, ns1__ArrayOfBase64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfBase64Binary, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ArrayOfBase64Binary ? type : NULL);
}

SOAP_FMAC3 ns1__ArrayOfBase64Binary ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfBase64Binary(struct soap *soap, const char *tag, ns1__ArrayOfBase64Binary **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfBase64Binary **)soap_malloc(soap, sizeof(ns1__ArrayOfBase64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfBase64Binary *)soap_instantiate_ns1__ArrayOfBase64Binary(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfBase64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfBase64Binary, sizeof(ns1__ArrayOfBase64Binary), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfBase64Binary(struct soap *soap, ns1__ArrayOfBase64Binary *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfBase64Binary(soap, tag ? tag : "ns1:ArrayOfBase64Binary", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfBase64Binary ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfBase64Binary(struct soap *soap, ns1__ArrayOfBase64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfBase64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap *soap, const char *tag, int id, xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_xsd__base64Binary, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xsd__base64Binary ? type : NULL);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__base64Binary **)soap_malloc(soap, sizeof(xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__base64Binary *)soap_instantiate_xsd__base64Binary(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__base64Binary(soap, tag ? tag : "xsd:base64Binary", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTounsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
